# This file contains ngme noise specifications,
# now it has 1. normal 2. nig types of noise.

#' ngme noise specification
#'
#' Function for specifying ngme noise.
#' Use ngme.noise.types() to check all the available types.
#'
#' @param noise_type   type of noise, "nig", "normal"
#' @param theta_V     value for theta_V, theta_V = eta > 0
#' @param V           value for V
#' @param theta_mu     specify a non-stationary noise using theta_mu
#' @param theta_sigma  specify a non-stationary noise using theta_sigma
#' @param B_mu         Basis matrix for mu (if non-stationary)
#' @param B_sigma      Basis matrix for sigma (if non-stationary)
#' @param fix_theta_mu
#' @param fix_theta_sigma
#' @param fix_theta_V
#' @param fix_V
#'
#' @return a list of specification of noise
#' @export
#'
#' @examples
#'
ngme.noise <- function(
  noise_type      = "nig",
  theta_mu        = 0,
  theta_sigma     = 0,
  theta_V         = 1,
  V               = NULL,
  B_mu            = NULL,
  B_sigma         = NULL,
  fix_theta_mu    = FALSE,
  fix_theta_sigma = FALSE,
  fix_theta_V     = FALSE,
  fix_V           = FALSE,
  ...
) {
  # check input
  if (noise_type == "gaussian") noise_type <- "normal"
  stopifnot("Unkown noise type. Please check ngme.noise.types()" =
    noise_type %in% ngme.noise.types())

  stopifnot("ngme_noise: theta_V should be positive" = theta_V > 0)

  if (is.null(B_mu))    B_mu <- as.matrix(1)
  if (is.null(B_sigma)) B_sigma <- as.matrix(1)

  if (!is.matrix(B_mu))
    stop("Please input B_mu as a matrix to use non-stationary mu")
  if (!is.matrix(B_sigma))
    stop("Please input B_sigma as a matrix to use non-stationary sigma")

  if (ncol(B_mu) != length(theta_mu))
    stop("Please make sure ncol(B_mu) == length(theta_mu).")
  if (ncol(B_sigma) != length(theta_sigma))
    stop("Please make sure ncol(B_sigma) == length(theta_sigma).")

  # auto-complete (make sure nrow(B_sigma) == nrow(B_mu) for n=1 case)
  if (nrow(B_mu) == 1 && nrow(B_sigma) != 1) {
    n <- nrow(B_sigma)
    B_mu <- matrix(rep(B_mu, n), nrow = n, byrow = TRUE)
  } else if (nrow(B_mu) != 1 && nrow(B_sigma) == 1) {
    n <- nrow(B_mu)
    B_sigma <- matrix(rep(B_sigma, n), nrow = n, byrow = TRUE)
  }

  structure(
    list(
      n_noise         = nrow(B_mu),
      noise_type      = noise_type,
      theta_V         = theta_V,
      V               = V,
      theta_mu        = theta_mu,
      theta_sigma     = theta_sigma,
      B_mu            = B_mu,
      B_sigma         = B_sigma,
      n_theta_mu      = length(theta_mu),
      n_theta_sigma   = length(theta_sigma),
      n_theta_V       = 1,
      fix_theta_mu    = fix_theta_mu,
      fix_theta_sigma = fix_theta_sigma,
      fix_theta_V     = fix_theta_V,
      fix_V           = fix_V
    ),
    class = "ngme_noise"
  )
}

#' Specify a normal noise
#'
#' @param sd  standard deviation
#' @param theta_sigma  specify a non-stationary noise using theta_sigma
#' @param B_sigma      Basis matrix for sigma (if non-stationary)
#'
#' @return
#' @export
#'
#' @examples
ngme.noise.normal <- function(
  sd = NULL,
  theta_sigma = NULL,
  B_sigma = NULL,
  ...
) {
  if (!is.null(sd) && !is.null(theta_sigma))
    stop("Please only use sd or theta_sigma as input")

  # both are null, use default value
  if (is.null(sd) && is.null(theta_sigma)) {
    theta_sigma <- 0
  }

  if (!is.null(sd)) {
    stopifnot(
      "sd is a double" = is.double(sd),
      "sd should be positive" = sd > 0
    )

    theta_sigma <- log(sd)
  }

  ngme.noise(
    noise_type = "normal",
    theta_sigma = theta_sigma,
    B_sigma = B_sigma,
    ...
  )
}

#' Specify a nig noise (normal inverse Gaussian)
#'
#' The parameterization can be found in ...
#'
#' @param theta_V      value of eta
#' @param theta_mu     specify a non-stationary noise using theta_mu
#' @param theta_sigma  specify a non-stationary noise using theta_sigma
#' @param B_mu         Basis matrix for mu (if non-stationary)
#' @param B_sigma      Basis matrix for sigma (if non-stationary)
#'
#' @return a list of specification for ngme
#' @export
#'
#' @examples
ngme.noise.nig <- function(
  mu            = NULL,
  sigma         = NULL,
  nu            = NULL,
  theta_mu      = NULL,
  theta_sigma   = NULL,
  theta_V       = NULL,
  V             = NULL,
  B_mu          = matrix(1),
  B_sigma       = matrix(1),
  ...
) {
  # if nothing, then fill with default
  if (is.null(mu) && is.null(theta_mu)) theta_mu <- 0
  if (is.null(sigma) && is.null(theta_sigma)) theta_sigma <- 0
  if (is.null(nu) && is.null(theta_V)) theta_V <- 1

  if (!is.null(sigma) && sigma <= 0) stop("ngme_nosie: sigma should be positive.")
  if (!is.null(nu) && nu <= 0) stop("ngme_nosie: nu should be positive.")

  if (!is.null(mu))     theta_mu <- mu
  if (!is.null(sigma))  theta_sigma <- log(sigma)
  if (!is.null(nu))     theta_V <- nu

  ngme.noise(
    theta_mu = theta_mu,
    theta_sigma = theta_sigma,
    theta_V = theta_V,
    V = V,
    B_mu = B_mu,
    B_sigma = B_sigma,
    ...
  )
}

# update ngme.noise
update.ngme.noise <- function(noise, n = NULL) {
  stopifnot("n should be integer" = is.numeric(n))
  B_mu <- noise$B_mu
  noise$B_mu <- matrix(data = rep(B_mu, n / nrow(B_mu)), nrow = n)

  B_sigma <- noise$B_sigma
  noise$B_sigma <- matrix(data = rep(B_sigma, n / nrow(B_sigma)), nrow = n)

  noise$n_noise <- n

  # noise
  do.call(ngme.noise, noise)
}

#' Create ngme noise with a list
#'
#' @param x a list
#'
#' @return a list of specification for ngme
#' @export
#'
#' @examples
create.ngme.noise <- function(x) {
  do.call(ngme.noise, x)
}

#' Print ngme noise
#'
#' @param noise noise object
#' @param padding
#'
#' @return a list (noise specifications)
#' @export
print.ngme_noise <- function(noise, padding=0) {
  pad_space <- paste(rep(" ", padding), collapse = "")
  pad_add4_space <- paste(rep(" ", padding + 4), collapse = "")

  if (is.null(noise)) {
    cat(pad_space); cat("Noise type - "); cat("NULL"); cat("\n")
  } else {
    cat(pad_space); cat("Noise type - "); cat(noise$noise_type); cat("\n")

    cat(pad_space); cat("Noise parameters: \n")
    params <- with(noise, {
      switch(noise_type,
        "normal" = paste0(pad_add4_space, "sd = ",          ngme.format(exp(theta_sigma))),
        "nig"    = paste0(pad_add4_space, "theta_mu = ",    ngme.format(theta_mu),
                    "\n", pad_add4_space, "theta_sigma = ", ngme.format(theta_sigma),
                    "\n", pad_add4_space, "nu = ",          ngme.format(theta_V)),
        stop("unknown noise type")
      )
    })
    cat(params)
  }
  cat("\n")
  invisible(noise)
}

#' plot the density of noise (for stationary)
#'
#' @param ngme_noise
#'
#' @return plot
#' @export
#'
#' @examples
plot.ngme_noise <- function(noise, add = FALSE, ...) {
  mu <- noise$theta_mu
  sigma <- exp(noise$theta_sigma)
  nu <- noise$theta_V
  stopifnot("only implemented for stationary mu" = length(mu) == 1)
  stopifnot("only implemented for stationary sigma" = length(sigma) == 1)

  xx <- seq(-10, 10, length = 400)
  switch(noise$noise_type,
    "nig"     = dd <- dnig(xx, -mu, mu, nu, sigma),
    "normal"  = dd <- dnorm(xx, sd = sigma),
    stop("Plot for this type is not implemented")
  )

  how_to_plot <- if (add) lines else plot

  how_to_plot(xx, dd, type = "l",
    # main = expression(paste(noise$noise_type, "noise with ") + theta[mu]),
    main = paste(noise$noise_type, "noise density"),
    xlab = "x", ylab = "y",
    ...
  )
}