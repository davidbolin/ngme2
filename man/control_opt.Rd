% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/control.R
\name{control_opt}
\alias{control_opt}
\title{Generate control specifications for \code{ngme()} function.}
\usage{
control_opt(
  seed = Sys.time(),
  burnin = 100,
  iterations = 500,
  stepsize = 0.5,
  estimation = TRUE,
  standardize_fixed = TRUE,
  stop_points = 10,
  iters_per_check = iterations/stop_points,
  n_parallel_chain = 2,
  max_num_threads = n_parallel_chain,
  exchange_VW = TRUE,
  n_slope_check = 3,
  std_lim = 0.1,
  trend_lim = 0.01,
  print_check_info = FALSE,
  preconditioner = "fast",
  precond_eps = 1e-05,
  precond_by_diff_chain = TRUE,
  compute_precond_each_iter = FALSE,
  max_relative_step = 0.5,
  max_absolute_step = 0.5,
  reduce_var = FALSE,
  reduce_power = 0.75,
  threshold = 1e-05,
  window_size = 1,
  rao_blackwellization = FALSE,
  n_trace_iter = 10,
  verbose = FALSE,
  sampling_strategy = "all",
  sgd_method = "vanilla",
  sgd_parameters = NULL
)
}
\arguments{
\item{seed}{set the seed for pesudo random number generator}

\item{burnin}{interations for burn-in periods (before optimization)}

\item{iterations}{optimization iterations}

\item{stepsize}{stepsize for each iteration}

\item{estimation}{run the estimation process (call C++ in backend)}

\item{standardize_fixed}{whether or not standardize the fixed effect}

\item{stop_points}{number of stop points for convergence check (or specify iters_per_check)}

\item{iters_per_check}{run how many iterations between each check point (or specify stop_points)}

\item{n_parallel_chain}{number of parallel chains}

\item{max_num_threads}{maximum number of threads used for parallel computing, by default will be set same as n_parallel_chain.
If it is more than n_parallel_chain, the rest will be used to parallel different replicates of the model.}

\item{exchange_VW}{exchange last V and W in each chian}

\item{n_slope_check}{number of stop points for regression}

\item{std_lim}{maximum allowed standard deviation}

\item{trend_lim}{maximum allowed slope}

\item{print_check_info}{print the convergence information}

\item{preconditioner}{preconditioner, can be c("none", "fast", "full")
"none" means no preconditioner, "fast" means precondition everything except for the parameter of K matrix (for speed reason), "full" means precondition everything}

\item{precond_eps}{numerical, the gap used for estimate preconditioner, default is 1e-5}

\item{precond_by_diff_chain}{logical, if TRUE, use different chains to estimate preconditioner (only computed at check points), if FALSE, use the same chain to estimate preconditioner (computed at each iteration)}

\item{compute_precond_each_iter}{logical, if TRUE, compute preconditioner at each iteration, if FALSE, only compute preconditioner at check points (if has only 1 chain running, it will be set TRUE)}

\item{max_relative_step}{max relative step allowed in 1 iteration}

\item{max_absolute_step}{max absolute step allowed in 1 iteration}

\item{reduce_var}{logical, reduce variace}

\item{reduce_power}{numerical the power of reduce level}

\item{threshold}{till when start to reduce the variance}

\item{window_size}{numerical, length of window for final estimates}

\item{rao_blackwellization}{use rao_blackwellization}

\item{n_trace_iter}{use how many iterations to approximate the trace (Hutchinsonâ€™s trick)}

\item{verbose}{print estimation}

\item{sampling_strategy}{subsampling method of replicates of model, c("all", "is")
"all" means using all replicates in each iteration,
"ws" means weighted sampling (each iteration use 1 replicate to compute the gradient, the sample probability is proption to its number of observations)}

\item{sgd_method}{currently support c("vanilla", "momentum")}

\item{sgd_parameters}{for momentum, provide c(beta1, beta2), in each iteration, the step is computed as m = beta1 * m (previous turn) + beta2 * gradient}
}
\value{
list of control variables
}
\description{
These are configurations for \code{ngme}
optimization process.
}
\details{
To enable convergence check, we need multiple chains running.
 We compare the trend of the estimated parameter of length
 \code{n_slope_check} (linear regression) with \code{trend_lim}.
 We compare the standard devation of estimated parameters (in different chains)
 with std_lim.
}
