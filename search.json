[{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Ngme2 AR(1) model","text":"autoregressive model order 1 (AR(1)) specifies output variable depends linearly previous values stochastic term. simplest AR model AR(1) model, given : \\[\\begin{align} X_1 &= \\epsilon_1, \\\\ X_i &= \\alpha X_{-1} + \\epsilon_i, \\; = 2, \\dots , n, \\end{align}\\] \\(|\\alpha| < 1\\), \\(\\epsilon_1, ..,\\epsilon_n\\) either ..d. NIG Gaussian noise. easy verify \\[ K{\\bf X} = \\boldsymbol\\epsilon,\\] \\({\\bf X} = (X_1, \\dots, X_n)\\), \\({\\boldsymbol \\epsilon} = (\\epsilon_1, \\dots, \\epsilon_n)\\), \\[ K =   \\begin{bmatrix}     1 \\\\     -\\alpha &  1 \\\\     & \\ddots & \\ddots \\\\     & & -\\alpha &  1   \\end{bmatrix}. \\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Ngme2 AR(1) model","text":"Use model_ar1 f(model=\"ar1\") (formula) specify AR(1) model. Notice AR(1) process well defined integer mesh (can gaps), see following examples:","code":"library(ngme2) set.seed(16)  m1 <- model_ar1(3:5, noise = noise_normal()) # check the operator matrix m1$K #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>                  #> [1,]  1.0  .   . #> [2,] -0.5  1.0 . #> [3,]  .   -0.5 1 # length is 5 - 3 + 1  m2 <- model_ar1(c(2011, 2012, 2015, 2016), noise = noise_nig(mu=5, sigma=1.5)) m2$K #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                                 #> [1,]  1.0  .    .    .    .   . #> [2,] -0.5  1.0  .    .    .   . #> [3,]  .   -0.5  1.0  .    .   . #> [4,]  .    .   -0.5  1.0  .   . #> [5,]  .    .    .   -0.5  1.0 . #> [6,]  .    .    .    .   -0.5 1 # length is 2016 - 2011 + 1 = 6  # specify mesh with replicate m3 <- model_ar1(c(1:5, 1:5), replicate = c(rep(1, 5), rep(2, 5))) m3$K #> 5 x 5 sparse Matrix of class \"dgCMatrix\" #>                            #> [1,]  1.0  .    .    .   . #> [2,] -0.5  1.0  .    .   . #> [3,]  .   -0.5  1.0  .   . #> [4,]  .    .   -0.5  1.0 . #> [5,]  .    .    .   -0.5 1 # index with double is not supported # not run: # model_ar1(rnorm(10))"},{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Ngme2 AR(1) model","text":"Simulating AR(1) model ngme2 simple. Just pass corresponding model simulate function.","code":"n_obs <- 500 day <- 1:n_obs Y <- simulate(   model_ar1(day, alpha = 0.5, noise = noise_nig(mu = 2, sigma = 2)),   seed = 16 )  # check the acf to see the correlation acf(Y)"},{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Ngme2 AR(1) model","text":"part show estiamte AR model using ngme function. can use control_opt modify control variables ngme. See ?control_opt optioins.","code":"x1 = runif(n_obs) x2 = rexp(n_obs) beta <- c(-3, -1, 2) X <- (model.matrix(Y ~ x1 + x2))  # design matrix Y <- as.numeric(Y + X %*% beta) # add some fixed effects Y <- Y + rnorm(n_obs, sd = 1) # add measurement noise  # Fit the model with the AR1 model ngme_out <- ngme(   Y ~ x1 + x2 + f(     1:n_obs,     name = \"my_ar\",     model = \"ar1\",     noise = noise_nig(),     theta_K = 0.9  # starting point for the alpha (parameter of K)   ),   data = data.frame(x1=x1, x2=x2, Y=Y),   control_opt = control_opt(     burnin = 100,     iterations = 2000,     std_lim = 0.6,     n_parallel_chain = 4,     stop_points = 10,     print_check_info = FALSE,     seed = 3   ) ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! ngme_out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -3.010, -0.698,  1.866 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1.73 #>  #>  #> Latent models:  #> $my_ar #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.879 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0.468 #>       sigma = 1.69 #>       nu = 0.901 #>  #> Number of replicates is  1  # traceplot of fixed effects and measurementn noise traceplot(ngme_out) # traceplot of ar1 model traceplot(ngme_out, \"my_ar\") # comparing the density of the noise estimated and the noise simulated plot(ngme_out[[1]]$latents[[1]]$noise,   noise_nig(mu = 2, sigma = 2))"},{"path":"https://davidbolin.github.io/ngme2/articles/Installation_and_configuration.html","id":"mac-os-x","dir":"Articles","previous_headings":"","what":"Mac OS X","title":"Installation and configuration","text":"Mac OS X system, default C++ compiler OS X support OpenMP. order make use OpenMP enable multi-threading OS X, need use compilers supports OpneMP.","code":"➜ clang -fopenmp hello.cpp clang: error: unsupported option '-fopenmp'"},{"path":"https://davidbolin.github.io/ngme2/articles/Installation_and_configuration.html","id":"install-a-openmp-supported-clang-as-default-cc-compiler-","dir":"Articles","previous_headings":"Mac OS X","what":"1. Install a OpenMP supported clang as default C/C++ compiler.","title":"Installation and configuration","text":"’s need install another compiler supports OpenMP. use homebrew installing llvm clang compiler using following scripts. (Check homebrew can just run following command install homebrew.) successful, able see following prompt. make llvm clang default compiler, need update PATH variable, reopen terminal make work: Now able use llvm clang OpenMP support. Let’s test : case, llvm lib include folder already added default clang search path. (can check search path run commands like clang hello.cpp -v, otherwise may need include mannually -L -, can also export system variable suggested, use makefile compile).","code":"/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ➜ brew install llvm  ... To use the bundled libc++ please add the following LDFLAGS:   LDFLAGS=\"-L/usr/local/opt/llvm/lib/c++ -Wl,-rpath,/usr/local/opt/llvm/lib/c++\"  llvm is keg-only, which means it was not symlinked into /usr/local, because macOS already provides this software and installing another version in parallel can cause all kinds of trouble.  If you need to have llvm first in your PATH, run:   echo 'export PATH=\"/usr/local/opt/llvm/bin:$PATH\"' >> ~/.zshrc  For compilers to find llvm you may need to set:   export LDFLAGS=\"-L/usr/local/opt/llvm/lib\"   export CPPFLAGS=\"-I/usr/local/opt/llvm/include\" ➜ echo 'export PATH=\"/usr/local/opt/llvm/bin:$PATH\"' >> ~/.zshrc ➜ clang -fopenmp hello.cpp"},{"path":"https://davidbolin.github.io/ngme2/articles/Installation_and_configuration.html","id":"configure-the-r-environment-to-make-use-of-the-new-compiler-","dir":"Articles","previous_headings":"Mac OS X","what":"2. Configure the R environment to make use of the new compiler.","title":"Installation and configuration","text":"Next want use OpenMP R code (maybe exported R function using Rcpp package), make sure R call new compiler, original one. , can mannually set Makeconf file (makefile configuration R) $R_HOME/etc/Makeconf. can check R_HOME address using R.home() R termnial. case, R called compiler still default clang, explicitly replace . Replace configuration lines following (llvm clang installed): Now able use OpenMP facility (multiple chain estimation) ngme2.","code":"R.home() ## [1] \"/Library/Frameworks/R.framework/Resources\" CC = /usr/local/opt/llvm/bin/clang CXX = /usr/local/opt/llvm/bin/clang++ CXX11 = $(CXX) CXX14 = $(CXX) CXX17 = $(CXX) CXX20 = $(CXX) SHLIB_OPENMP_CFLAGS = -fopenmp SHLIB_OPENMP_CXXFLAGS = -fopenmp"},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Ngme2 random walk model","text":"ngme2, currently support random walk model first-order second order. Remeber ngme2, models form: \\[K \\mathbf{W} = \\boldsymbol{\\epsilon},\\] \\(K\\) operator matrix, \\(\\epsilon\\) random noise (maybe non-Gaussian), \\(\\mathbf{W}\\) random vector want model.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"the-first-order-random-walk-rw1","dir":"Articles","previous_headings":"Description","what":"The first-order random walk (RW(1))","title":"Ngme2 random walk model","text":"first-order random walk constructed assuming independent increments given data \\(\\mathbf{x}\\) (use location, sorted) length \\(n\\): \\(\\epsilon\\) follows NIG distribution: \\[ \\begin{align} \\Delta w_i &= -\\mu + \\mu V_i + \\sigma \\sqrt{V_i} Z , \\; n=1, \\dots, n-1 \\\\ V_i &\\sim IG(\\nu, \\nu (\\Delta x_i)^2), \\\\ Z_i &\\sim N(0, 1), \\end{align} \\] \\(\\epsilon\\) follows normal distribution: \\[ \\begin{align} \\Delta w_i &= \\epsilon_i , \\; n=1, \\dots, n-1 \\\\ \\epsilon_i &\\sim N(0, \\sigma^2 \\Delta x_i), \\\\ \\end{align} \\] \\(\\Delta w_i := w_{+1} - w_{}\\), \\(\\Delta x_i := x_{+1} - x_{}\\). operator matrix \\(K\\) dimension \\((n-1 \\times n)\\) \\[ K =   \\begin{bmatrix}     -1 & 1 \\\\       & -1 & 1 \\\\       & & \\ddots & \\ddots \\\\       & & & -1 & 1   \\end{bmatrix}. \\] also provide special case circular random walk, 1st element n-th element connected. circular RW(1) case, operator matrix \\(K\\) dimension \\((n-1 \\times n-1)\\) \\[ K =   \\begin{bmatrix}     -1 & 1 \\\\       & \\ddots & \\ddots \\\\       &  & -1 & 1 \\\\        1 & & & -1   \\end{bmatrix}. \\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"the-second-order-random-walk-rw2","dir":"Articles","previous_headings":"Description","what":"The second-order random walk (RW(2))","title":"Ngme2 random walk model","text":"Similarily, second-order random walk constructed assuming second order difference independent: \\(\\epsilon\\) follows NIG distribution: \\[ \\begin{align} \\Delta^2 w_i &= -\\mu + \\mu V_i + \\sigma \\sqrt{V_i} Z , \\; n=1, \\dots, n-2 \\\\ V_i &\\sim IG(\\nu, \\nu (\\Delta x_i)^2), \\\\ Z_i &\\sim N(0, 1), \\end{align} \\] \\(\\epsilon\\) follows normal distribution: \\[ \\begin{align} \\Delta^2 w_i &= \\epsilon_i , \\; n=1, \\dots, n-2 \\\\ \\epsilon_i &\\sim N(0, \\sigma^2 \\Delta x_i), \\\\ \\end{align} \\] \\(\\Delta^2 w_i := w_{+2} - 2w_{+1} - w_{}\\), \\(\\Delta x_i := x_{+1} - x_{}\\). operator matrix \\(K\\) dimension \\((n-2 \\times n)\\) \\[ K =   \\begin{bmatrix}     1 & -2 & 1 \\\\       & 1 & -2 & 1 \\\\       & & \\ddots & \\ddots & \\ddots \\\\       & & & 1 & -2 & 1   \\end{bmatrix}. \\] circular RW(2) case, operator matrix \\(K\\) dimension \\((n-2 \\times n-2)\\) \\[ K =   \\begin{bmatrix}     1 & -2 & 1 \\\\       & 1 & -2 & 1 \\\\       & & \\ddots & \\ddots & \\ddots \\\\       1 & & & 1 & -2 \\\\       -2 & 1 & & & 1   \\end{bmatrix}. \\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Ngme2 random walk model","text":"Use model_rw f(model = \"rw1\") f(model = \"rw2\") (formula) specify random walk model.","code":"library(ngme2) set.seed(16) m1 <- model_rw(rexp(5), order = 1, noise = noise_normal()) m1$K #> 4 x 5 sparse Matrix of class \"dgCMatrix\" #>                    #> [1,] -1  1  .  . . #> [2,]  . -1  1  . . #> [3,]  .  . -1  1 . #> [4,]  .  .  . -1 1  m2 <- model_rw(rnorm(6), order = 2, circular = TRUE) m2$K #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                        #> [1,]  1 -2  1  .  .  . #> [2,]  .  1 -2  1  .  . #> [3,]  .  .  1 -2  1  . #> [4,]  .  .  .  1 -2  1 #> [5,]  1  .  .  .  1 -2 #> [6,] -2  1  .  .  .  1"},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Ngme2 random walk model","text":"simulation simple, just pass corresponding model simulate function.","code":"simulate(m1) #> [1] 0.00000000 0.50484423 0.57283014 0.03306372 0.91976291 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1 simulate(m2) #> [1]  0.3879526 -0.1088115 -0.3121041 -0.3017892 -0.3581525  0.0712422 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"gaussian-process-in-geostatistics","dir":"Articles","previous_headings":"","what":"Gaussian process in geostatistics","title":"Ngme2 SPDE Matern model","text":"Gaussian process random fields covers different methods representing spatial spatial-temporal dependence structures. Gaussian fields (GF) dominant role spatial statistics especially traditional field geostatistics. common geostatistical model given \\[ Y_i = x(\\mathbf{s}_i) + \\varepsilon_i, \\quad =1,\\ldots,N, \\quad \\varepsilon_i\\sim N(0, \\sigma^2),\\] \\[x(\\mathbf{s}) \\sim GP\\left(\\sum_{k=1}^{n_b} b_k(\\mathbf{s})w_k, c(\\mathbf{s},\\mathbf{s}')\\right),\\] \\(N\\) number spatial observations, \\(GP(m,c)\\) stands Gaussian process mean function \\(m\\) covariance function \\(c\\), \\(n_b\\) number basis functions, \\(\\{b_k(\\cdot)\\}_{k=1}^{n_b}\\) basis functions, \\(w_k\\) weights estimated \\(c(\\cdot,\\cdot)\\) covariance function. popular flexible covariance function random fields \\(\\mathbb{R}^d\\) Matérn covariance function: \\[ c(\\mathbf{s}, \\mathbf{s}') = \\frac{\\sigma^2}{\\Gamma(\\nu)2^{\\nu-1}}(\\kappa \\|\\mathbf{s}-\\mathbf{s}'\\|)^\\nu K_\\nu(\\kappa\\|\\mathbf{s}-\\mathbf{s}'\\|), \\] \\(\\Gamma(\\cdot)\\) Gamma function, \\(K_\\nu(\\cdot)\\) modified Bessel function second kind, \\(\\nu>0\\) controls correlation range \\(\\sigma^2\\) variance. Finally, \\(\\nu>0\\) determines smoothness field. Usually, model parameters estimated via maximum likelihood estimation. main drawback approach computational time needed order perform statistical inference usually scales \\(\\mathcal{O}(N^3)\\).","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"the-spde-approach-with-gaussian-noise","dir":"Articles","previous_headings":"","what":"The SPDE approach with Gaussian noise","title":"Ngme2 SPDE Matern model","text":"well-known (Whittle, 1963) Gaussian process \\(u(\\mathbf{s})\\) Matérn covariance function solves stochastic partial differential equation (SPDE) \\[\\begin{equation}\\label{spde} (\\kappa^2 -\\Delta)^\\beta u = \\mathcal{W}\\quad \\hbox{} \\mathcal{D}, \\end{equation}\\] \\(\\Delta = \\sum_{=1}^d \\frac{\\partial^2}{\\partial_{x_i^2}}\\) Laplacian operator, \\(\\mathcal{W}\\) Gaussian spatial white noise \\(\\mathcal{D}=\\mathbb{R}^d\\), \\(4\\beta = 2\\nu + d\\). Inspired relation Gaussian processes Matérn covariance functions solutions SPDE, Lindgren et al. (2011) constructed computationally efficient Gaussian Markov random field approximations \\(u(\\mathbf{s})\\), domain \\(\\mathcal{D}\\subsetneq \\mathbb{R}^d\\) bounded \\(2\\beta\\\\mathbb{N}\\). approximate solutions SPDE obtained finite element discretization.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"finite-element-approximation","dir":"Articles","previous_headings":"The SPDE approach with Gaussian noise","what":"Finite element approximation","title":"Ngme2 SPDE Matern model","text":"now provide brief description finite element method used. make description simpler consider nonfractional SPDE given \\[(\\kappa^2 - \\Delta) u(\\mathbf{s}) = \\mathcal{W}(\\mathbf{s}),\\] bounded domain \\(\\mathcal{D}\\) \\(\\mathbb{R}^d\\). Laplacian operator augmented boundary conditions. Usually one considers Dirichlet, process zero boundary \\(\\mathcal{D}\\), Neumann, directional derivarives process normal directions zero boundary \\(\\mathcal{D}\\). equation interpreted following weak sense: every function \\(\\psi(\\mathbf{s})\\) suitable space test functions, following identity holds \\[\\langle \\psi, (\\kappa^2-\\Delta)u\\rangle_{\\mathcal{D}} \\stackrel{d}{=} \\langle \\psi, \\mathcal{W}\\rangle_{\\mathcal{D}},\\] \\(\\stackrel{d}{=}\\) means equality distribution \\(\\langle\\cdot,\\cdot\\rangle_{\\mathcal{D}}\\) standard inner product \\(L_2(\\mathcal{D})\\), \\(\\langle f,g\\rangle_{\\mathcal{D}} = \\int_\\mathcal{D} f(\\mathbf{s})g(\\mathbf{s}) d\\mathbf{s}.\\) finite element method (FEM) consists considering finite dimensional space test functions \\(V_n\\). Galerkin method, consider \\(V_n = {\\rm span}\\{\\varphi_1,\\ldots,\\varphi_n\\}\\), \\(\\varphi_i(\\mathbf{s}), =1,\\ldots, n\\) piecewise linear basis functions obtained triangulation \\(\\mathcal{D}\\). , write approximate solution \\(u\\) \\(u_n\\), \\(u_n\\) written terms basis functions \\[u_n(\\mathbf{s}) = \\sum_{=1}^n w_i \\varphi_i(\\mathbf{s}).\\] thus obtain system linear equations \\[\\left\\langle \\varphi_j, (\\kappa^2 - \\Delta)\\left(\\sum_{=1}^n w_i\\varphi_i\\right)\\right\\rangle_{\\mathcal{D}} \\stackrel{d}{=} \\langle \\varphi_j, \\mathcal{W}\\rangle_{\\mathcal{D}},\\quad\\hbox{} j=1,\\ldots,n.\\] right hand side can shown \\[(\\langle \\varphi_1, \\mathcal{W}\\rangle_{\\mathcal{D}}, \\ldots, \\langle \\varphi_n, \\mathcal{W}\\rangle_{\\mathcal{D}}) \\sim N(0, \\mathbf{C}),\\] \\(\\mathbf{C}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{C}_{,j} = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s})\\varphi_j(\\mathbf{s}) d\\mathbf{s}.\\] matrix \\(\\mathbf{C}\\) known mass matrix FEM theory. using Green’s first identity, left hand side \\[ \\begin{array}{ccl} \\left\\langle \\varphi_j, (\\kappa^2 - \\Delta)\\left(\\sum_{=1}^n w_i\\varphi_i\\right)\\right\\rangle_{\\mathcal{D}} &=& \\sum_{=1}^n \\langle \\varphi_j, (\\kappa^2 - \\Delta)w_i\\varphi_i\\rangle_{\\mathcal{D}}\\\\ &=& \\sum_{=1}^n (\\kappa^2 \\langle \\varphi_j, \\varphi_i\\rangle_{\\mathcal{D}} + \\langle \\nabla \\varphi_j, \\nabla \\varphi_i\\rangle_{\\mathcal{D}}) w_i, \\quad j=1,\\ldots, n, \\end{array} \\] boundary terms vanish due boundary conditions (Dirichlet Neumann). can rewrite last term matrix form \\[(\\kappa^2 \\mathbf{C} + \\mathbf{G})\\mathbf{w},\\] \\(\\mathbf{w} = (w_1,\\ldots,w_n)\\) \\(\\mathbf{G}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{G}_{,j} = \\int_{\\mathcal{D}} \\nabla \\varphi_i(\\mathbf{s})\\nabla\\varphi_j(\\mathbf{s})d\\mathbf{s}.\\] matrix \\(\\mathbf{G}\\) known FEM theory stiffness matrix. Putting everything together, \\[(\\kappa^2 \\mathbf{C} + \\mathbf{G}) \\mathbf{w} \\sim N(0,\\mathbf{C}).\\] Therefore, \\(\\mathbf{w}\\) centered Gaussian variable precision matrix given \\[\\mathbf{Q} = (\\kappa^2 \\mathbf{C}+\\mathbf{G})^\\top \\mathbf{C}^{-1}(\\kappa^2 \\mathbf{C}+\\mathbf{G}).\\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"computational-advantages-of-the-spde-approach","dir":"Articles","previous_headings":"The SPDE approach with Gaussian noise","what":"Computational advantages of the SPDE approach","title":"Ngme2 SPDE Matern model","text":"spatial problems, computational cost usually scales \\(\\mathcal{O}(n^{3/2})\\), \\(n\\) number basis functions. compared \\(\\mathcal{O}(N^3)\\) Gaussian random field approach. implies accurate approximations drastically reduces computational cost sampling inference.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"the-spde-approach-with-non-gaussian-noise","dir":"Articles","previous_headings":"","what":"The SPDE approach with non-Gaussian noise","title":"Ngme2 SPDE Matern model","text":"describe generalize approach non-Gaussian noise. goal now describe SPDE approach noise non-Gaussian. motivation handling non-Gaussian noise comes fact many features handled Gaussian noise. reasons : Skewness; Heavier tails; Jumps sample paths; Asymmetries sample paths.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"non-gaussian-matérn-fields","dir":"Articles","previous_headings":"The SPDE approach with non-Gaussian noise","what":"Non-Gaussian Matérn fields","title":"Ngme2 SPDE Matern model","text":"idea replace Gaussian white noise \\(\\mathcal{W}\\) SPDE non-Gaussian white noise \\(\\dot{\\mathcal{M}}\\): \\[(\\kappa^2 - \\Delta)^\\beta u = \\dot{\\mathcal{M}}.\\] solution \\(u\\) Matérn covariance function, marginal distributions non-Gaussian. consider setup. precisely, consider \\(V_n = {\\rm span}\\{\\varphi_1,\\ldots,\\varphi_n\\}\\), \\(\\varphi_i(\\mathbf{s}), =1,\\ldots, n\\) piecewise linear basis functions obtained triangulation \\(\\mathcal{D}\\) approximate solution \\(u\\) \\(u_n\\), \\(u_n\\) written terms basis functions \\[u_n(\\mathbf{s}) = \\sum_{=1}^n w_i \\varphi_i(\\mathbf{s}).\\] right-hand side obtain random vector \\[\\mathbf{f} = (\\dot{\\mathcal{M}}(\\varphi_1),\\ldots, \\dot{\\mathcal{M}}(\\varphi_n)),\\] functional \\(\\dot{\\mathcal{M}}\\) given \\[\\dot{\\mathcal{M}}(\\varphi_j) = \\int_{\\mathcal{D}} \\varphi_j(\\mathbf{s}) d\\mathcal{M}(\\mathbf{s}).\\] considering \\(\\mathcal{M}\\) type-G Lévy process, obtain \\(\\mathbf{f}\\) joint distribution easy handle. say Lévy process type G increments can represented location-scale mixtures: \\[\\gamma + \\mu V + \\sigma \\sqrt{V}Z,\\] \\(\\gamma, \\mu\\) parameters, \\(Z\\sim N(0,1)\\) independent \\(V\\), \\(V\\) positive infinitely divisible random variable. Therefore, given vector \\(\\mathbf{V} = (V_1,\\ldots,V_n)\\) independent stochastic variances (case, positive infinitely divisible random variables), obtain \\[\\mathbf{f}|\\mathbf{V} \\sim N(\\gamma + \\mu\\mathbf{V}, \\sigma^2{\\rm diag}(\\mathbf{V})).\\] , consider, instance, non-fractional non-Gaussian SPDE \\[(\\kappa^2 - \\Delta) u = \\dot{\\mathcal{M}},\\] obtain FEM weights \\(\\mathbf{w} = (w_1,\\ldots,w_n)\\) satisfy \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(\\gamma+\\mu\\mathbf{V}), \\sigma^2\\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1}),\\] \\(\\mathbf{K} = \\kappa^2\\mathbf{C}+\\mathbf{G}\\) discretization differential operator.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"the-nig-model","dir":"Articles","previous_headings":"The SPDE approach with non-Gaussian noise","what":"The NIG model","title":"Ngme2 SPDE Matern model","text":"delve details now considering, example, NIG model. First, say random variable \\(V\\) follows inverse Gaussian distribution parameters \\(\\eta_1\\) \\(\\eta_2\\), denoted \\(V\\sim IG(\\eta_1,\\eta_2)\\) probability density function (pdf) given \\[\\pi(v) = \\frac{\\sqrt{\\eta_2}}{\\sqrt{2\\pi v^3}} \\exp\\left\\{-\\frac{\\eta_1}{2}v - \\frac{\\eta_2}{2v} + \\sqrt{\\eta_1\\eta_2}\\right\\},\\quad \\eta_1,\\eta_2>0.\\] can generate samples inverse Gaussian distributions parameters \\(\\eta_1\\) \\(\\eta_2\\) generating samples generalized inverse Gaussian distribution parameters \\(p=-1/2\\), \\(=\\eta_1\\) \\(b=\\eta_2\\). can use rGIG function generate samples generalized inverse Gaussian distribution. \\(V\\sim IG(\\eta_1,\\eta_2)\\), \\(X = \\gamma +\\mu V + \\sigma \\sqrt{V}Z\\), \\(Z\\sim N(0,1)\\), independent \\(V\\), \\(X\\) follows normal inverse Gaussian (NIG) distribution pdf \\[\\pi(x) = \\frac{e^{\\sqrt{\\eta_1\\eta_2}+\\mu(x-\\gamma)/\\sigma^2}\\sqrt{\\eta_2\\mu^2/\\sigma^2+\\eta_1\\eta_2}}{\\pi\\sqrt{\\eta_2\\sigma^2+(x-\\gamma)^2}} K_1\\left(\\sqrt{(\\eta_2\\sigma^2+(x-\\gamma)^2)(\\mu^2/\\sigma^4+\\eta_1/\\sigma^2)}\\right),\\] \\(K_1\\) modified Bessel function third kind. form, NIG density overparameterized, therefore set \\(\\eta_1=\\eta_2=\\eta\\), results \\(E(V)=1\\). Thus, one parameters, \\(\\mu, \\gamma\\) \\(\\eta\\). NIG model thus assumes stochastic variance \\(V_i\\) follows inverse Gaussian parameters \\(\\eta\\) \\(\\eta h_i^2\\), \\(h_i = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s}) d\\mathbf{s}.\\)","code":"library(INLA) #> Loading required package: Matrix #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_23.03.19 built 2023-03-19 19:11:44 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() library(ngme2) #>  #> Attaching package: 'ngme2' #> The following object is masked from 'package:INLA': #>  #>     f library(ggplot2) library(plyr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:plyr': #>  #>     arrange, count, desc, failwith, id, mutate, rename, summarise, #>     summarize #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(viridis) #> Loading required package: viridisLite"},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"specification","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Specification","title":"Ngme2 SPDE Matern model","text":"Use model_matern specify SPDE Matérn model, see ?model_matern details. Consider following examples (1d 2d cases):  Specifying 2d Matérn model also simple:","code":"# 1d example loc <- c(1.1, 2.2, 3.5, 4.7) mesh_1d <- inla.mesh.1d(1:10) m1 <- model_matern(map = loc, mesh = mesh_1d) # 2d example data(argo_float) head(argo_float) #>       lat     lon           sal       temp #> 1 -64.078 175.821 -0.0699508100  0.4100305 #> 2 -63.760 162.917 -0.0320931260 -0.2588680 #> 3 -63.732 163.294 -0.0008063143 -0.1151362 #> 4 -63.700 162.568 -0.0209534220 -0.2378965 #> 5 -63.269 169.623  0.0409914840  0.3375048 #> 6 -63.113 171.526  0.0269408910  0.2145556 # take longitude and latitude to build the mesh  max.edge    <- 1 bound.outer <- 5 loc_2d <- unique(cbind(argo_float$lon, argo_float$lat)) # nrow(loc) == nrow(dat) no replicate argo_mesh <- inla.mesh.2d(loc = loc_2d,                     # the inner edge and outer edge                     max.edge = c(1,5),                     cutoff = 0.3,                     # offset extension distance inner and outer extenstion                     offset = c(max.edge, bound.outer) ) plot(argo_mesh) argo_spde <- model_matern(   map = loc_2d,   mesh = argo_mesh )"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"simulation","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Simulation","title":"Ngme2 SPDE Matern model","text":"simulation easy, simply provide model, ’s !","code":"simulate(m1) #>  [1] -0.495982764 -0.438953760 -0.940582512 -0.751046563  0.172417530 #>  [6] -0.111404328  0.592070205  0.417702208 -0.005324487 -0.379873020 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1 simulate(argo_spde)[1:20] #>  [1] -0.36236605  0.06950848 -0.58964281 -0.07958500 -0.49119070  0.05329682 #>  [7] -0.10526759  0.13719711 -0.20761969  0.09995411 -0.14168905  0.04403162 #> [13]  0.11758504  0.06306374 -0.11309436 -0.12882337  0.05905417 -0.18415878 #> [19]  0.21087458 -0.22829800"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"estimation","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Estimation","title":"Ngme2 SPDE Matern model","text":"Let’s use previous argo_float spatial (2d) example. First explore data look like:   Next, specfiy model formula, fit model.","code":"# tempearture ggplot(data=argo_float) +   geom_point(aes(     x = loc_2d[, 1], y = loc_2d[, 2],     colour = temp   ), size = 2, alpha = 1) +   scale_color_gradientn(colours = viridis(100)) # salinity ggplot(data=argo_float) +   geom_point(aes(     x = loc_2d[, 1], y = loc_2d[, 2],     colour = sal   ), size = 2, alpha = 1) +   scale_color_gradientn(colours = viridis(100)) formula <- temp ~ sal + f(loc_2d, model = \"matern\", mesh=argo_mesh, noise = noise_normal(), debug = FALSE)  out <- ngme(   formula = formula,   family = \"nig\",   data = argo_float,   control_opt = control_opt(     estimation = TRUE,     n_parallel_chain = 4,     iterations = 100,     seed = 7,     print_check_info = FALSE   ),   debug = FALSE ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -0.041,  6.579 #>  #> Measurement noise:  #>   Noise type - nig #>   Noise parameters:  #>       mu = -0.00916 #>       sigma = 0.86 #>       nu = 0.964 #>  #>  #> Latent models:  #> $field1 #>   Ngme model: matern #>   Model parameters:  #>       theta_kappa = 0.00283 #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.995 #>  #> Number of replicates is  1"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"prediction","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Prediction","title":"Ngme2 SPDE Matern model","text":"prediction ngme simple, simply put value preidcted location NA. ngme function firstly estimate model using known data. estimation, estimaed value samples given gibbs sampler used give linear predictor. See vignette Prediction estimation details.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Comparing Ngme2 with R-INLA","text":"R-INLA (https://www.r-inla.org) package R approximate Bayesian inference Latent Gaussian Models. Ngme2 follows similar structure allow non-Gaussian latent models (Latent non-Gaussian Models). vignette, introduce basic usage Ngme2 package compare R-INLA.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"load-data-and-create-mesh","dir":"Articles","previous_headings":"","what":"Load data and create mesh","title":"Comparing Ngme2 with R-INLA","text":"example, use mcycle data, data set motorcycle acceleration times. data set available MASS package.  Next create mesh, order use SPDE model. mesh created function inla.mesh.1d. first argument location mesh points. second argument maximum edge length.","code":"set.seed(16) library(MASS) library(INLA) library(ngme2) data(mcycle) str(mcycle) #> 'data.frame':    133 obs. of  2 variables: #>  $ times: num  2.4 2.6 3.2 3.6 4 6.2 6.6 6.8 7.8 8.2 ... #>  $ accel: num  0 -1.3 -2.7 0 -2.7 -2.7 -2.7 -1.3 -2.7 -2.7 ... with(mcycle, {plot(times, accel)}) mesh <- inla.mesh.1d(mcycle$times, max.edge=c(1, 10)) mesh$n #> [1] 94"},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"fit-the-model-with-inla","dir":"Articles","previous_headings":"Compare results in INLA and Ngme2","what":"Fit the model with INLA","title":"Comparing Ngme2 with R-INLA","text":"Let’s check estimation SPDE model parameters","code":"# fit use INLA spde <- inla.spde2.matern(mesh, alpha=2) A <- inla.spde.make.A(mesh, loc=mcycle$times) ind <- inla.spde.make.index(\"time\", spde$n.spde) data <- list(accel = mcycle$accel, time = ind$time) result_inla <- inla(   accel ~ -1 + f(time, model=spde),   data = data,   control.predictor = list(A = A),   control.compute = list(config=TRUE) ) spde_res <- inla.spde.result(result_inla, \"time\", spde)  # posterior mode of kappa post_mode_kappa <- with(spde_res$marginals.kappa,   kappa.1[which.max(kappa.1[, 2]), 1])  plot(spde_res$marginals.kappa$kappa.1,   type=\"l\", main=\"kappa\") abline(v=post_mode_kappa, col=2) post_mode_kappa #>         x  #> 0.1994212  # posterior mode of tau post_mode_tau <- with(spde_res$marginals.tau,   tau.1[which.max(tau.1[, 2]), 1]) plot(spde_res$marginals.tau$tau.1, type=\"l\", main=\"tau\") abline(v=post_mode_tau, col=2) 1 / post_mode_tau # for comparison with Ngme2 (same as sigma parameter in Ngme2) #>        x  #> 10.20411"},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"fit-1d-spde-model-with-ngme2","dir":"Articles","previous_headings":"Compare results in INLA and Ngme2","what":"Fit 1d SPDE model with Ngme2","title":"Comparing Ngme2 with R-INLA","text":"Next similar thing Ngme2. , can directly read estimation kappa sigma (1/tau) shown result.","code":"result_ngme <- ngme(   accel ~ -1 + f(times, model=\"matern\", mesh=mesh, name=\"myspde\"),   data = mcycle,   family = \"normal\",   control_opt = control_opt(     iterations = 1000   ) ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! result_ngme #> *** Ngme object *** #>  #> Fixed effects:  #>    No fixed effects #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 22.5 #>  #>  #> Latent models:  #> $myspde #>   Ngme model: matern #>   Model parameters:  #>       theta_kappa = -1.6 #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 6.16 #>  #> Number of replicates is  1"},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"compare-the-results","dir":"Articles","previous_headings":"Compare results in INLA and Ngme2","what":"Compare the results","title":"Comparing Ngme2 with R-INLA","text":"","code":"with(mcycle, {plot(times, accel)}) lines(mesh$loc, result_inla$summary.random$time[, \"mean\"], col=2, lwd=2) pred_W <- predict(result_ngme, loc=list(myspde = mesh$loc)) # by dafult, predict() returns a bunch of statistics at the given location str(pred_W[[1]]) #> List of 6 #>  $ mean      : num [1:94] -1.98 -1.79 -1.42 -1.36 -1.51 ... #>  $ sd        : num [1:94] 10.89 10.53 9.81 9.47 9.14 ... #>  $ 5quantile : num [1:94] -21.6 -21 -18.6 -15.8 -14.1 ... #>  $ 95quantile: num [1:94] 17.6 17 17.1 15.7 14.8 ... #>  $ median    : num [1:94] -1.84 -1.5 -2.1 -3.4 -2.32 ... #>  $ mode      : num [1:94] 3 3 -3 -5 -7 3 7 -7 -9 -1 ... lines(mesh$loc, pred_W[[1]][[\"mean\"]], col=3, lwd=2) title(\"Posterior mean with Ngme2 and INLA\") # One can add some quantile band to the plot using Ngme2 lines(mesh$loc, pred_W[[1]][[\"5quantile\"]], col=4, lwd=2, lty=2) lines(mesh$loc, pred_W[[1]][[\"95quantile\"]], col=5, lwd=2, lty=2) legend(\"bottomright\", legend=c(\"INLA\", \"Ngme2\", \"Ngme2 5% quantile\", \"Ngme2 95% quantile\"),   col=c(2, 3, 4, 5), lty=c(1, 1, 2, 2), lwd=c(2, 2, 2, 2))"},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"extend-model-to-non-gaussian-case","dir":"Articles","previous_headings":"","what":"Extend model to non-Gaussian case","title":"Comparing Ngme2 with R-INLA","text":"Ngme2 package allows us fit non-Gaussian latent models. can easily extend model non-Gaussian case changing noise argument, can start previous result using start argument.","code":"# refit the model using nig noise result_ngme2 <- ngme(   accel ~ -1 + f(times, model=\"matern\", mesh=mesh, name=\"myspde\", noise=noise_nig()),   data = mcycle,   family = \"normal\",   control_opt = control_opt(     iterations = 2000   ) ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! result_ngme2 #> *** Ngme object *** #>  #> Fixed effects:  #>    No fixed effects #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 22.5 #>  #>  #> Latent models:  #> $myspde #>   Ngme model: matern #>   Model parameters:  #>       theta_kappa = -1.46 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = -2.8 #>       sigma = 7.53 #>       nu = 0.609 #>  #> Number of replicates is  1 traceplot(result_ngme2, \"myspde\") plot(result_ngme2[[1]]$latents[[\"myspde\"]]$noise)"},{"path":"https://davidbolin.github.io/ngme2/articles/inla_compare.html","id":"doing-prediction-with-ngme2","dir":"Articles","previous_headings":"","what":"Doing prediction with Ngme2","title":"Comparing Ngme2 with R-INLA","text":"prediction unknown location INLA require much effort, skip (since ’s main focus). Ngme2, can done just one line code. First need create new mesh prediction. Next, call predict function loc argument provided list new locations (latent model).","code":"rg <- range(mcycle$times) rg #> [1]  2.4 57.6 locs <- seq(from=rg[1], to=rg[2], length = 100) # similar to the posterior mean in previous section prd_ngme <- predict(result_ngme2, loc = list(myspde=locs))[[1]][[\"mean\"]]  with(mcycle, {plot(times, accel)}) lines(locs, prd_ngme, col=2) title(\"Prediction at unknown locations\")"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"vignette provide brief introduction ngme2 package. ngme2 updated version R Package ngme (https://github.com/davidbolin/ngme), package estimating latent non-Gaussian models. follows 3-layer structure design (general block model, latent process models, noises) specifying whole statistical model. latent process defines different operator structure, block model collects together fixed effects measurement noise.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"features","dir":"Articles","previous_headings":"Introduction","what":"1 Features","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"Support spatial models like Matern model non-Gaussian noise. Support models temporal data like AR1 random walk order 1 2. Support replicate locations. Support prediction unknown locations. Model corss-validation. Comparing previous version, now supports multiple stochastic processes latent model.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"model-framework","dir":"Articles","previous_headings":"Introduction","what":"2 Model Framework","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"package ngme2 provides methods mixed effect models single response variable case multivariate response case (yet). 1.single response case, following form: \\[ \\begin{aligned} Y = {\\bf X}^{\\top} {\\bf \\beta} + \\sum_j {\\bf }_j W_j({\\bf t}) + \\epsilon. \\end{aligned} \\] , \\(Y\\) response variable, \\({\\bf X}\\) matrix fixed effects explanatory variables, \\({\\bf \\beta}\\) matrix fixed effects coefficients, \\({\\bf }_j\\) observation matrix process, \\(W_j(t_j)\\) specified stochastic process, \\(\\epsilon\\) measurement error. , process \\(W\\) follows \\({\\bf K} W = z\\), \\(z\\) either Gaussian non-Gaussian noise. \\({\\bf K}\\) operator matrix. simple template using core function ngme model single response: , function f modeling stochastic process W Gaussian non-Gaussian noise, discuss later. noise stands measurement noise distribution. case, model Gaussian likelihood. multivariate response case, following form: another template using core function ngme model bivariate response:","code":"ngme(   formula=Y ~ x1 + x2 + f(index, model=\"ar\", noise=\"nig\"),   data=data.frame(Y=Y, x1=x1, x2=x2, index=index),   noise = noise_normal() ) ngme(   formula=Y1 | Y2 ~ x1 + x2 + f(index, model=\"ar\", noise=\"nig\") | f(time, model=\"matern\"),   data=data.frame(Y=Y, x1=x1, x2=x2, index=index, time=time),   family=\"normal\" )"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"non-gaussian-model","dir":"Articles","previous_headings":"Introduction","what":"3 Non-Gaussian Model","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"assume non-Gaussian process type-G Lévy process, whose increments can represented location-scale mixtures: \\[\\gamma + \\mu V + \\sigma \\sqrt{V}Z,\\] \\(\\gamma, \\mu, \\sigma\\) parameters, \\(Z\\sim N(0,1)\\) independent \\(V\\), \\(V\\) positive infinitely divisible random variable. results following form, \\(K\\) operator part: \\[ KW|V \\sim N(\\gamma + \\mu V, \\sigma^2 \\, diag(V)), \\] also, \\(\\mu\\) \\(\\sigma\\) can non-stationary. ngme2, focus mainly normal inverse Gaussian (NIG) model. See ?nig details.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"parameter-estimation","dir":"Articles","previous_headings":"Introduction","what":"4 Parameter Estimation","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"Ngme2 maximum likelihood estimation preconditioned stochastic gradient descent. Multiple chains run parallel better convergence checks.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"specify-noise-with-ngme_noise-object","dir":"Articles","previous_headings":"Ngme Model Structure","what":"Specify noise with ngme_noise object","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"ngme_noise object fundamental structure ngme2. object used specify driving noise stochastic process measurement noise. now support two noises, one normal noise, NIG noise. R class ngme_noise following interface: 3rd example non-stationary NIG noise, \\(\\mu = \\bf B_{\\mu} \\bf \\theta_{\\mu}\\), \\(\\sigma = \\exp(\\bf B_{\\sigma} \\bf \\theta_{\\sigma})\\). construct following noise structure: \\[   - \\mathbf{\\mu} + \\mathbf{\\mu} V + \\mathbf{\\sigma} \\sqrt{V} Z \\] \\(\\mu = \\bf B_{\\mu} \\bf \\theta_{\\mu}\\), \\(\\sigma = \\exp(\\bf B_{\\sigma} \\bf \\theta_{\\sigma})\\). case, can recover gaussian noise setting type=“normal ignoring theta_mu nu. can simply use helper function noise_normal(sd=1)","code":"library(ngme2)  noise_normal(sigma = 1)                 # normal noise #> Noise type - normal #> Noise parameters:  #>     sigma = 1 noise_nig(mu = 1, sigma = 2, nu = 1) # nig noise #> Noise type - nig #> Noise parameters:  #>     mu = 1 #>     sigma = 2 #>     nu = 1 noise_nig(            # non-stationary nig noise   B_mu=matrix(c(1:10), ncol=2),   theta_mu = c(1, 2),   B_sigma=matrix(c(1:10), ncol=2),   theta_sigma = c(1,2),   nu = 1) #> Noise type - nig #> Noise parameters:  #>     theta_mu = 1, 2 #>     theta_sigma = 1, 2 #>     nu = 1 ngme_noise(   type,           # the type of noise   theta_mu,       # mu parameter   theta_sigma,    # sigma parameter   nu,        # nu parameter   B_mu,           # basis matrix for non-stationary mu   B_sigma         # basis matrix for non-stationary sigma )"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"specify-stochastic-process-with-f-function","dir":"Articles","previous_headings":"Ngme Model Structure","what":"Specify stochastic process with f function","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"middle layer stochastic process, R interface, represented f function. process can specified different noise structure. See ?ngme_model_types() details. examples using f function specify ngme_model: One useful model SPDE model Gaussian non-Gaussian noise, see vignette details.","code":"ngme2::f(1:10, model = \"ar1\",   noise = noise_nig(), theta_K = 0.5) #> ngme2::f(model = \"ar1\", map = 1:10, noise = noise_nig(), theta_K = 0.5,  #>     name = \"field\", replicate = c(1, 1, 1, 1, 1, 1, 1, 1, 1,  #>     1))"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"specifying-latent-models-with-formula-in-ngme","dir":"Articles","previous_headings":"Ngme Model Structure","what":"Specifying latent models with formula in ngme","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"latent model can specified additively formula argument ngme function together fixed effects. use R formula specify latent model. can specify model using f within formula. example, following formula corresponds model \\[ Y = \\beta_0 + \\beta_1 x_1 + W_1(x_2) + W_2(x_3) + \\epsilon, \\] \\(W_1\\) AR(1) process, \\(W_2\\) random walk 1 process. \\(x_2\\) random effects.. . default, intercept. distribution measurement error \\(\\epsilon\\) given ngme function. entire model can fitted, along specification distribution measurement error ngme function: gives ngme object, three parts: Fixed effects (intercept x1) Measurement noise (normal noise) Latent models (contains 2 models, ar1 rw1) can turn estimation = TRUE start estimating model.","code":"formula <- Y ~ x1 + f(     x2,     model = \"ar1\",     noise = noise_nig(),     theta_K = 0.5   ) + f(1:5,     model = \"rw\",     order = 1,     circular = T,     noise = noise_normal()   ) ngme(   formula = formula,   family = noise_normal(sigma = 0.5),   data = data.frame(Y = 1:5, x1 = 2:6, x2 = 3:7),   control_opt = control_opt(     estimation = FALSE   ) ) #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -1,  1 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.5 #>  #>  #> Latent models:  #> $field1 #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.5 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0 #>       sigma = 1 #>       nu = 1 #> $field2 #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1 #>  #> Number of replicates is  1"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"a-simple-example---ar1-process-with-nig-noise","dir":"Articles","previous_headings":"","what":"A simple example - AR1 process with nig noise","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"Now let’s see example AR1 process nig noise. process defined \\[ W_i = \\alpha W_{-1} + \\epsilon_i, \\] , \\(\\epsilon_1, ..,\\epsilon_n\\) iid NIG noise. , easy verify \\[ K{\\bf W} = \\boldsymbol\\epsilon,\\] \\[ K =   \\begin{bmatrix}     \\alpha \\\\     -1 &  \\alpha \\\\     & \\ddots & \\ddots \\\\     & & -1 &  \\alpha   \\end{bmatrix} \\] Now let’s fit model using ngme. can use control_opt modify control variables ngme. See ?control_opt optioins. Next can read result directly object. can see, model converges 350 iterations. estimation results close real parameter. can also use traceplot function see estimation traceplot. Parameters AR1 model can also density comparison estimated noise true NIG noise:","code":"n_obs <- 500 sigma_eps <- 0.5 alpha <- 0.5 mu = 2; delta = -mu sigma <- 3 nu <- 1  # First we generate V. V_i follows inverse Gaussian distribution trueV <- ngme2::rig(n_obs, nu, nu, seed = 10)  # Then generate the nig noise mynoise <- delta + mu*trueV + sigma * sqrt(trueV) * rnorm(n_obs) trueW <- Reduce(function(x,y){y + alpha*x}, mynoise, accumulate = T) Y = trueW + rnorm(n_obs, mean=0, sd=sigma_eps)  # Add some fixed effects x1 = runif(n_obs) x2 = rexp(n_obs) beta <- c(-3, -1, 2) X <- (model.matrix(Y ~ x1 + x2))  # design matrix Y = as.numeric(Y + X %*% beta) # # Fit the model with the AR1 model ngme_out <- ngme(   Y ~ x1 + x2 + f(     1:n_obs,     name = \"my_ar\",     model = \"ar1\",     noise = noise_nig(),     theta_K = 0.9  # starting point for the alpha (parameter of K)   ),   data=data.frame(x1=x1, x2=x2, Y=Y),   control_opt = control_opt(     burnin = 100,     iterations = 1000,     std_lim = 0.4,     n_parallel_chain = 4,     stop_points = 10,     print_check_info = FALSE,     seed = 3     # verbose = T   ) ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! ngme_out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -2.77, -1.59,  2.01 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1.83 #>  #>  #> Latent models:  #> $my_ar #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.887 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0.324 #>       sigma = 2.19 #>       nu = 0.878 #>  #> Number of replicates is  1 library(ggplot2) library(grid) library(gridExtra) traceplot(ngme_out) # ngme_out[[1]] means for the 1st replicate plot(   ngme_out[[1]]$latents[[1]]$noise,   noise_nig(mu = mu, sigma = sigma, nu = nu) )"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"paraná-dataset","dir":"Articles","previous_headings":"","what":"Paraná dataset","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"rainfall data Paraná (Brazil) collected National Water Agency Brazil (Agencia Nacional de Águas, ANA, Portuguese). ANA collects data many locations Brazil, data freely available ANA website (http://www3.ana.gov.br/portal/ANA). briefly illustrate command use, result estimation. Plot data: Mean rainfall Octobor 2012 Paraná   Parameter estimation results: Estimations model","code":"library(INLA) #> Loading required package: Matrix #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_23.03.19 built 2023-03-19 19:11:44 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() #>  #> Attaching package: 'INLA' #> The following object is masked from 'package:ngme2': #>  #>     f library(splancs) #>  #> Spatial Point Pattern Analysis Code in S-Plus #>   #>  Version 2 - Spatial and Space-Time analysis library(lattice) library(ggplot2) library(grid) library(gridExtra) library(viridis) #> Loading required package: viridisLite data(PRprec) data(PRborder)  # Create INLA mesh coords <- as.matrix(PRprec[, 1:2]) prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2)  # monthly mean at each location Y <- rowMeans(PRprec[, 12 + 1:31]) # 2 + Octobor  ind <- !is.na(Y) # non-NA index Y <- Y_mean <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) seaDist <- apply(spDists(coords, PRborder[1034:1078, ],   longlat = TRUE ), 1, min) # leave 0.1 Y as prediction area # n <- length(Y) # ind_pred <- sample(1:n, size = 0.1 * n) # Y_pred <- Y[ind_pred] # Y[ind_pred] <- NA  out <- ngme(   formula = Y ~ 1 +     f(inla.group(seaDist), name=\"rw\", model = \"rw\", noise = noise_normal()) +     f(coords, model = \"matern\", mesh = prmesh, name=\"spde\", noise = noise_normal()),   data = data.frame(Y = Y),   family = \"nig\",   control_opt = control_opt(     estimation = T,     iterations = 1000,     n_slope_check = 4,     stop_points = 10,     std_lim = 0.1,     n_parallel_chain = 4,     print_check_info = FALSE,     seed = 16   ) ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = 9.14 #>  #> Measurement noise:  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0.0812 #>       sigma = 2.22 #>       nu = 1.1 #>  #>  #> Latent models:  #> $rw #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1.05 #> $spde #>   Ngme model: matern #>   Model parameters:  #>       theta_kappa = -0.0127 #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1.16 #>  #> Number of replicates is  1  # traceplots ## fixed effects and measurement error traceplot(out) ## spde model traceplot(out, \"spde\")"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"prediction","dir":"Articles","previous_headings":"Paraná dataset","what":"Prediction","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"","code":"nxy <- c(150, 100) projgrid <- rSPDE::rspde.mesh.projector(prmesh,   xlim = range(PRborder[, 1]),   ylim = range(PRborder[, 2]), dims = nxy )  xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2]))  coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") seaDist.prd <- apply(spDists(coord.prd,   PRborder[1034:1078, ],   longlat = TRUE ), 1, min)  # doing prediction by giving the predict location # first list is for 1st replicate (we only have 1 replicate) # second list is for different latent models (we have 2) pds <- predict(out, loc=list(list(seaDist.prd, coord.prd))) # [[1]] means for the 1st replicate (we only have 1), mean stands for the mean estimator lp <- pds[[1]]$mean ggplot() +   geom_point(aes(     x = coord.prd[, 1], y = coord.prd[, 2],     colour = lp   ), size = 2, alpha = 1) +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y_mean   ), size = 2, alpha = 1) +   scale_color_gradientn(colours = viridis(100)) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\")"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"cross-validation","dir":"Articles","previous_headings":"Paraná dataset","what":"Cross-validation","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"can validate model using cross-validation method.","code":"cross_validation(out, type=\"k-fold\", k=10, print=TRUE) #> In group 1 :  #>       MAE      MSE      CRPS     sCRPS #> 1 2.42914 9.600795 -1.302649 -1.387333 #>  #> In group 2 :  #>        MAE      MSE      CRPS     sCRPS #> 1 2.493439 10.53073 -1.304769 -1.428993 #>  #> In group 3 :  #>        MAE      MSE      CRPS     sCRPS #> 1 2.467661 10.01284 -1.325535 -1.365141 #>  #> In group 4 :  #>        MAE      MSE      CRPS     sCRPS #> 1 2.296395 8.895768 -1.205859 -1.410781 #>  #> In group 5 :  #>        MAE      MSE     CRPS     sCRPS #> 1 2.489308 11.61838 -1.38921 -1.324259 #>  #> In group 6 :  #>       MAE      MSE      CRPS     sCRPS #> 1 2.64612 11.37544 -1.520495 -1.333166 #>  #> In group 7 :  #>       MAE      MSE      CRPS     sCRPS #> 1 2.61515 11.10242 -1.420548 -1.348478 #>  #> In group 8 :  #>       MAE      MSE      CRPS     sCRPS #> 1 2.77729 12.82244 -1.554457 -1.444316 #>  #> In group 9 :  #>        MAE      MSE      CRPS     sCRPS #> 1 2.498252 10.27568 -1.291445 -1.468931 #>  #> In group 10 :  #>        MAE      MSE      CRPS     sCRPS #> 1 2.342963 8.717557 -1.244983 -1.389848 #>  #> The average of indices computed:  #>        MAE     MSE      CRPS     sCRPS #> 1 2.505572 10.4952 -1.355995 -1.390125 #>  #> The final result averaged over replicates:  #>        MAE     MSE      CRPS     sCRPS #> 1 2.505572 10.4952 -1.355995 -1.390125"},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Model prediction and estimation","text":"vignette, provide breif introduction estimation methods ngme2. First, give description model. popular flexible covariance function random fields \\(\\mathbb{R}^d\\) Matérn covariance function: \\[c(\\mathbf{s}, \\mathbf{s}') = \\frac{\\sigma^2}{\\Gamma(\\nu)2^{\\nu-1}}(\\kappa \\|\\mathbf{s}-\\mathbf{s}'\\|)^\\nu K_\\nu(\\kappa\\|\\mathbf{s}-\\mathbf{s}'\\|),\\] \\(\\Gamma(\\cdot)\\) Gamma function, \\(K_\\nu(\\cdot)\\) modified Bessel function second kind, \\(\\nu>0\\) controls correlation range \\(\\sigma^2\\) variance. Finally, \\(\\nu>0\\) determines smoothness field. well-known (Whittle, 1963) Gaussian process \\(u(\\mathbf{s})\\) Matérn covariance function solves stochastic partial differential equation (SPDE) \\[\\begin{equation}\\label{spde} (\\kappa^2 -\\Delta)^\\beta u = \\mathcal{W}\\quad \\hbox{} \\mathcal{D}, \\end{equation}\\] \\(\\Delta = \\sum_{=1}^d \\frac{\\partial^2}{\\partial_{x_i^2}}\\) Laplacian operator, \\(\\mathcal{W}\\) Gaussian spatial white noise \\(\\mathcal{D}=\\mathbb{R}^d\\), \\(4\\beta = 2\\nu + d\\). Inspired relation Gaussian processes Matérn covariance functions solutions SPDE, Lindgren et al. (2011) constructed computationally efficient Gaussian Markov random field approximations \\(u(\\mathbf{s})\\), domain \\(\\mathcal{D}\\subsetneq \\mathbb{R}^d\\) bounded \\(2\\beta\\\\mathbb{N}\\). order model departures Gaussian behaviour consider following extension due Bolin (2014): \\[(\\kappa^2 - \\Delta)^\\beta X(\\mathbf{s}) = \\dot{\\mathcal{M}}(\\mathbf{s}),\\quad \\mathbf{s}\\\\mathcal{D},\\] \\(\\dot{\\mathcal{M}}\\) non-Gaussian white-noise. specifically, assume \\(\\mathcal{M}\\) type-G Lévy process. say Lévy process type G increments can represented location-scale mixtures: \\[\\gamma + \\mu V + \\sigma \\sqrt{V}Z,\\] \\(\\gamma, \\mu\\) \\(\\sigma\\) parameters, \\(Z\\sim N(0,1)\\) independent \\(V\\), \\(V\\) positive infinitely divisible random variable. SPDE assume \\(\\gamma = -\\mu E(V)\\) \\(\\sigma = 1\\). Finally, assume observations \\(Y_1,\\ldots,Y_N\\), observed locations \\(\\mathbf{s}_1,\\ldots,\\mathbf{s}_N\\\\mathcal{D}\\), \\(Y_1,\\ldots, Y_N\\) satisfy \\[ Y_i = X(\\mathbf{s}_i) + \\varepsilon_i, \\quad =1,\\ldots,N,\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_N\\) ..d. following \\(\\varepsilon_i\\sim N(0, \\sigma_\\varepsilon^2)\\).","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"finite-element-approximations","dir":"Articles","previous_headings":"","what":"Finite element approximations","title":"Model prediction and estimation","text":"vignette assume basic understanding Galerkin’s finite element method. details refer reader Sampling processes given solutions SPDEs driven non-Gaussian noise vignette. Recall assuming \\(\\beta=1\\), SPDE given \\[(\\kappa^2 - \\Delta) X(\\mathbf{s}) = \\dot{\\mathcal{M}}(\\mathbf{s}),\\quad \\mathbf{s}\\\\mathcal{D}.\\] Let us introduce notation regarding finite element method (FEM). Let \\(V_n = {\\rm span}\\{\\varphi_1,\\ldots,\\varphi_n\\}\\), \\(\\varphi_i(\\mathbf{s}), =1,\\ldots, n\\) piecewise linear basis functions obtained triangulation \\(\\mathcal{D}\\). approximate solution \\(X_n\\) \\(X\\) written terms finite element basis functions \\[X_n(\\mathbf{s}) = \\sum_{=1}^n w_i \\varphi_i(\\mathbf{s}),\\] \\(w_i\\) FEM weights. Let, also, \\[\\mathbf{f} = (\\dot{\\mathcal{M}}(\\varphi_1),\\ldots, \\dot{\\mathcal{M}}(\\varphi_n)),\\] Therefore, given vector \\(\\mathbf{V} = (V_1,\\ldots,V_n)\\) independent stochastic variances (case, positive infinitely divisible random variables), obtain \\[\\mathbf{f}|\\mathbf{V} \\sim N(\\gamma + \\mu\\mathbf{V}, \\sigma^2{\\rm diag}(\\mathbf{V})).\\] Let us now introduce useful notation. Let \\(\\mathbf{C}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{C}_{,j} = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s})\\varphi_j(\\mathbf{s}) d\\mathbf{s}.\\] matrix \\(\\mathbf{C}\\) known mass matrix FEM theory. Let, also, \\(\\mathbf{G}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{G}_{,j} = \\int_{\\mathcal{D}} \\nabla \\varphi_i(\\mathbf{s})\\nabla\\varphi_j(\\mathbf{s})d\\mathbf{s}.\\] matrix \\(\\mathbf{G}\\) known FEM theory stiffness matrix. Finally, let \\[h_i = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s}) d\\mathbf{s}, \\quad =1,\\ldots,n.\\] Recall \\(\\gamma = -\\mu E(V)\\). \\(\\mathbf{V}\\) chosen \\(E[V_i] = h_i\\) ensure parameter identifiability. , FEM weights \\(\\mathbf{w} = (w_1,\\ldots,w_n)\\) satisfy \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}), \\sigma^2\\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1}),\\] \\(\\mathbf{K} = \\kappa^2\\mathbf{C}+\\mathbf{G}\\) discretization differential operator \\(\\mathbf{h} = (h_1,\\ldots,h_n)\\).","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"prediction","dir":"Articles","previous_headings":"","what":"Prediction","title":"Model prediction and estimation","text":"order illustrate predictions assume parameters \\(\\kappa\\), \\(\\sigma\\) \\(\\sigma_\\varepsilon\\) known. case unknown parameters treated next section. goal section perform prediction latent field \\(X\\) locations observations. Usually, predictions, one provides mean variance predictive distribution. now describe one can generate quantities assuming model defined previous sections. Let us assume want obtain predictions locations \\(\\widetilde{\\mathbf{s}}_1, \\ldots, \\widetilde{\\mathbf{s}}_p \\\\mathcal{D}\\), \\(p\\\\mathbb{N}\\). Notice \\(j=1,\\ldots,p\\), \\[X_n(\\widetilde{\\mathbf{s}}_j) = \\sum_{=1}^n w_i \\varphi_i(\\widetilde{\\mathbf{s}}_j).\\] Therefore, let \\(\\mathbf{}_p\\) \\(p\\times n\\) matrix whose \\((,j)\\)th entry given \\(\\mathbf{}_{p,ij} = \\varphi_j(\\widetilde{\\mathbf{s}}_i)\\), \\[(X_n(\\widetilde{\\mathbf{s}}_1),\\ldots, X_n(\\widetilde{\\mathbf{s}}_p)) = \\mathbf{}_p\\mathbf{w}.\\] Thus, perform prediction desired means variances \\[E[\\mathbf{}_p \\mathbf{w}  | \\mathbf{Y}]\\quad\\hbox{}\\quad V[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}],\\] \\(\\mathbf{Y} = (Y_1,\\ldots,Y_N).\\) Now, observe density \\(\\mathbf{w}|\\mathbf{Y}\\) known. , mean variance computed analytically. two ways circumvent situation. based fact even though know density \\(\\mathbf{w}|\\mathbf{Y}\\), know density \\(\\mathbf{V}|\\mathbf{w},\\mathbf{Y}\\) density \\(\\mathbf{w}|\\mathbf{V},\\mathbf{Y}\\). Therefore can use Gibbs sampler sample \\((\\mathbf{w},\\mathbf{V})|\\mathbf{Y}\\). obtain, byproduct, marginal samples \\(\\mathbf{w}|\\mathbf{Y}\\) \\(\\mathbf{V}|\\mathbf{Y}\\). now provide brief presentation Gibbs sampler provide approximations means variances.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"gibbs-sampler","dir":"Articles","previous_headings":"Prediction","what":"Gibbs sampler","title":"Model prediction and estimation","text":"now briefly describe Gibbs sampler algorithm used . Let \\(\\mathbf{}\\) \\(N\\times n\\) matrix, whose \\((,j)\\)th entry given \\(\\mathbf{}_{ij} = \\varphi_j(\\mathbf{s}_i)\\). Therefore, \\[(X_n(\\mathbf{s}_1),\\ldots,X_n(\\mathbf{s}_N)) = \\mathbf{}\\mathbf{w},\\] \\[\\mathbf{Y} \\approx \\mathbf{}\\mathbf{w} + \\boldsymbol{\\varepsilon},\\] \\(\\boldsymbol{\\varepsilon} = (\\varepsilon_1,\\ldots,\\varepsilon_N)\\). consider representation, .e., assume \\[\\mathbf{Y} = \\mathbf{}\\mathbf{w} + \\boldsymbol{\\varepsilon},\\] error approximation \\(X(\\cdot)\\) \\(X_n(\\cdot)\\) captured measurement noise. Therefore, assumption \\[\\mathbf{Y}|\\mathbf{w} \\sim N(\\mathbf{}\\mathbf{w}, \\sigma_\\varepsilon^{2} \\mathbf{}).\\] Also recall \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}), \\sigma^2\\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1}).\\] Let \\[\\mathbf{m} = \\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})\\quad \\hbox{}\\quad \\mathbf{Q} = \\frac{1}{\\sigma^2}\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}\\mathbf{K}.\\] thus follows (see, also, Wallin Bolin (2015) Asar et al. (2020)) \\[\\mathbf{w} | \\mathbf{V}, \\mathbf{Y} \\sim N\\big(\\widetilde{\\mathbf{m}}, \\widetilde{\\mathbf{Q}}^{-1}),\\] \\[\\widetilde{\\mathbf{Q}} = \\mathbf{Q} + \\sigma_\\varepsilon^{-2} \\mathbf{}^\\top\\mathbf{}\\quad\\hbox{}\\quad \\widetilde{\\mathbf{m}} = \\widetilde{\\mathbf{Q}}^{-1}\\big(\\mathbf{Q}\\mathbf{m}+\\sigma_\\varepsilon^{-2}\\mathbf{}^\\top\\mathbf{Y}\\big).\\] compute conditional distribution \\(\\mathbf{V}|\\mathbf{w}, \\mathbf{Y}\\) one can see Wallin Bolin (2015), pp. 879, \\(V_1,\\ldots,V_n\\) conditionally independent given \\(\\mathbf{w}\\). Furthermore, also Proposition 1 Asar et al. (2020)) \\(V\\sim GIG(p,,b)\\), \\(GIG\\) stands generalized inverse Gaussian distribution parameters \\(p, \\) \\(b\\), , every \\(j=1,\\ldots,n\\), \\[V_j|\\mathbf{w},\\mathbf{Y} \\sim GIG\\Bigg(p-0.5, +\\frac{\\mu^2}{\\sigma^2}, b + \\frac{(\\mathbf{K}\\mathbf{w}+\\mathbf{h}\\mu)_j^2}{\\sigma^2}\\Bigg).\\] now position use Gibbs sampling algorithm: Provide initial values \\(\\mathbf{V}^{(0)}\\); Sample \\(\\mathbf{w}^{(1)} | \\mathbf{V}^{(0)},\\mathbf{Y}\\); Sample \\(\\mathbf{V}^{(1)} | \\mathbf{w}^{(1)}, \\mathbf{Y}\\); Continue sequentially sampling \\(\\mathbf{w}^{()}|\\mathbf{V}^{(-1)},\\mathbf{Y}\\), \\(\\mathbf{V}^{()}|\\mathbf{w}^{()}, \\mathbf{Y}\\) \\(=1,\\ldots,k\\). One stop equilibrium reached. obtain evidence equilibrium achieved, best consider one chain, starting different locations, see mixed well. might also useful see autocorrelation plots. Depending starting values, one might consider burn-samples, , one runs chain iterations, saves last position, throw away rest samples, use starting values. important observe samples \\(\\{\\mathbf{w}^{()},\\mathbf{V}^{()}\\}_{=1}^k\\) independent. However, general assumptions, Gibbs sampler provides samples satisfying law large numbers functionals sample. Therefore, one can use samples compute means variances.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"standard-mc-estimates","dir":"Articles","previous_headings":"Prediction","what":"Standard MC estimates","title":"Model prediction and estimation","text":"Suppose sample \\(\\mathbf{w}^{(1)},\\ldots, \\mathbf{w}^{(k)}\\) approximate mean \\[E[\\mathbf{}_p \\mathbf{w}  | \\mathbf{Y}] \\approx \\frac{1}{k} \\sum_{=1}^k \\mathbf{}_p\\mathbf{w}^{()}\\] approximate variance \\[V[\\mathbf{}_p \\mathbf{w}|\\mathbf{Y}] \\approx \\frac{1}{k} \\sum_{=1}^k (\\mathbf{}_p\\mathbf{w}^{()} - E[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}])^2,\\] \\(\\{\\mathbf{w}^{()}\\}_{=1}^k\\) sample generated using Gibbs sampler algorithm.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"rao-blackwellization-for-means-and-variances","dir":"Articles","previous_headings":"Prediction","what":"Rao-Blackwellization for means and variances","title":"Model prediction and estimation","text":"second way consists performing Rao-Blackwellization (Robert Casella, 2004) means variances. following Wallin Bolin (2015) \\[ \\begin{array}{ccl} E[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}] &=& \\int_\\mathbf{w} \\mathbf{}_p \\mathbf{w} \\pi(\\mathbf{w}|\\mathbf{Y})\\,d\\mathbf{w},\\\\ &=& \\int_\\mathbf{w} \\int_{\\mathbf{V}} \\mathbf{}_p \\mathbf{w} \\pi(\\mathbf{w}|\\mathbf{V},\\mathbf{Y})\\pi(\\mathbf{V}|\\mathbf{Y})\\,d\\mathbf{V}\\,d\\mathbf{w}\\\\ &=& \\int_\\mathbf{V} \\mathbf{}_p \\widetilde{\\mathbf{m}} \\pi(\\mathbf{V}|\\mathbf{Y})\\,d\\mathbf{V}, \\end{array} \\] \\(\\widetilde{\\mathbf{m}} = E[\\mathbf{w}|\\mathbf{V},\\mathbf{Y}]\\), expression given description Gibbs sampler. Thus, approximation \\[E[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}] \\approx \\frac{1}{k}\\sum_{=1}^k \\mathbf{}_p \\widetilde{\\mathbf{m}}^{()},\\] \\(\\widetilde{\\mathbf{m}}^{()} = \\widetilde{\\mathbf{m}}(\\mathbf{V}^{()})\\), , \\(\\widetilde{\\mathbf{m}}^{()}\\) computed based \\(\\mathbf{V}^{()}\\). Notice, also, \\(\\widetilde{\\mathbf{m}}\\) computed Gibbs sampling, imply additional cost. similar reasoning \\[V(\\mathbf{}_p \\mathbf{w}|\\mathbf{Y}) \\approx \\frac{1}{k}\\sum_{=1}^k\\mathbf{}_p^\\top (\\widetilde{\\mathbf{Q}}^{()})^{-1}\\mathbf{}_p,\\] \\(\\widetilde{\\mathbf{Q}}^{()}\\) conditional covariance matrix \\(\\mathbf{w}\\), given \\(\\mathbf{V}\\) \\(\\mathbf{Y}\\), evaluated \\(\\mathbf{V}^{()}\\).","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"spde-based-model-driven-by-nig-noise-with-gaussian-measurement-errors-in-1d","dir":"Articles","previous_headings":"Examples in R","what":"SPDE based model driven by NIG noise with Gaussian measurement errors in 1D","title":"Model prediction and estimation","text":"example consider latent process \\(X\\) solving equation \\[(\\kappa^2 - \\partial^2/\\partial t^2)X(t) = \\dot{\\mathcal{M}}(t),\\] \\(\\dot{\\mathcal{M}}\\) NIG-distributed white-noise. details NIG distribution well sample process refer reader Sampling processes given solutions SPDEs driven non-Gaussian noise vignette. also using notation vignette. Notice , , assuming \\(V_i\\) follow inverse Gaussian distribution parameters \\(\\nu\\) \\(\\nu h_i^2\\). take \\(\\kappa=1\\), \\(\\sigma_\\varepsilon=1\\), \\(\\sigma=1\\), \\(\\mu = 1\\), \\(\\mathcal{D}=[0,1]\\) \\(\\nu=0.5\\). also assume 10 observations \\[Y_i = X(t_i) + \\varepsilon_i,\\quad =1,\\ldots,10,\\] \\(t_1,\\ldots,t_{10}\\[0,1]\\). Notice \\(\\varepsilon_i \\sim N(0,1)\\). Let us now build matrix \\(K\\), generate \\(V\\) sample NIG model: consider mesh 10 equally spaced nodes. code sample process given .   now generate 9 uniformly distributed random locations determine locations observations. determine locations need build \\(\\) matrix obtain values process \\(X\\) locations. can build \\(\\) matrix using function inla.spde.make..  Now, let us assume want obtain prediction \\(X\\) point \\(t^\\ast = 5\\). end obtain predictions using methods, namely, standard MC Rao-Blackwellization. methods need Gibbs samples, let us build Gibbs samples. build 2 chains different starting values burn-samples. Recall \\(V_j \\sim IG(\\nu, h_j^2 \\cdot \\nu), j=1,\\ldots,10\\), \\(\\mu=1\\) \\(\\sigma=1\\), \\[V_j|\\mathbf{w},\\mathbf{Y} \\sim GIG(-1,\\nu + 1, \\nu\\cdot h_j^2 + (\\mathbf{K}\\mathbf{w}+\\mathbf{h})_j^2)\\] \\[\\mathbf{w} | \\mathbf{V}, \\mathbf{Y} \\sim N\\big( (\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}\\mathbf{K} + \\mathbf{}^\\top\\mathbf{})^{-1}(\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}(\\mathbf{V}-\\mathbf{h})+\\mathbf{}^\\top \\mathbf{Y}), (\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}\\mathbf{K} + \\mathbf{}^\\top\\mathbf{})^{-1}\\big).\\] Let us sample 1000 times chain. Let us also record values \\(E[\\mathbf{w} | \\mathbf{V}, \\mathbf{Y}]\\) sampling. Let us organize data build traceplots. Let us compare posterior means: Let us begin building traceplots \\(V\\): \\(W\\):  traceplots appear healthy, stuck anywhere chain apparently mixed well. can also build autocorrelation plots. end let us prepare data frames. Now, let us plot autocorrelation plots \\(V\\):  Now, autocorrelation plots \\(W\\):  can see correlation low. now move forward obtain predictions \\(t^\\ast = 5/9\\). compute MC Rao-Blackwellization predictions.  notice Rao-Blackwellization approach converges much faster standard MC approach.","code":"library(INLA) library(ngme2) library(ggplot2) library(tidyr) set.seed(123)  loc_1d <- 0:9/9 mesh_1d <- inla.mesh.1d(loc_1d)  # inla.mesh.fem # inla.mesh.1d.fem(mesh_1d)$c1 + inla.mesh.1d.fem(mesh_1d)$g1 # attr(simulate(noise_nig(n=10, 1,1,0.5), seed=10), \"noise\")$h  # specify the model we use mu <- 1; sigma <- 1; nu <- 0.5 spde_1d <- model_matern(   loc_1d,   kappa = 1,   mesh = mesh_1d,   noise = noise_nig(mu=mu, sigma=sigma, nu=nu) ) spde_1d$noise$h #>  [1] 0.05555556 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 #>  [7] 0.11111111 0.11111111 0.11111111 0.05555556 K <- spde_1d$C + spde_1d$G   W <- simulate(spde_1d, seed = 10) plot(loc_1d, W, type = \"l\") str(W) #>  num [1:10] -0.719 -0.716 -0.709 -0.708 -0.705 ... #>  - attr(*, \"noise\")=List of 20 #>   ..$ n_noise             : int 10 #>   ..$ h                   : num [1:10] 0.0556 0.1111 0.1111 0.1111 0.1111 ... #>   ..$ noise_type          : chr \"nig\" #>   ..$ nu                  : num 0.5 #>   ..$ V                   : num [1:10] 0.000475 0.005676 0.003751 0.001964 0.014118 ... #>   ..$ theta_mu            : num 1 #>   ..$ theta_sigma         : num 0 #>   ..$ theta_sigma_normal  : NULL #>   ..$ B_mu                : num [1:10, 1] 1 1 1 1 1 1 1 1 1 1 #>   ..$ B_sigma             : num [1:10, 1] 1 1 1 1 1 1 1 1 1 1 #>   ..$ B_sigma_normal      : NULL #>   ..$ n_theta_mu          : int 1 #>   ..$ n_theta_sigma       : int 1 #>   ..$ n_theta_sigma_normal: int 0 #>   ..$ fix_theta_mu        : logi FALSE #>   ..$ fix_theta_sigma     : logi FALSE #>   ..$ fix_nu              : logi FALSE #>   ..$ fix_V               : logi FALSE #>   ..$ n_params            : int 3 #>   ..$ init_V              : logi TRUE #>   ..- attr(*, \"class\")= chr \"ngme_noise\"  V <- attr(W, \"noise\")$V plot(loc_1d, V, type = \"l\") new_loc_1d <- sort(runif(9))  A_matrix <- inla.spde.make.A(   mesh = inla.mesh.1d(loc_1d),   loc = new_loc_1d ) A_matrix #> 9 x 10 sparse Matrix of class \"dgCMatrix\" #>                                                                        #>  [1,] . . 0.3975624 0.6024376 .         .          .         .         #>  [2,] . . .         .         0.1034058 0.89659422 .         .         #>  [3,] . . .         .         .         0.65272182 0.3472782 .         #>  [4,] . . .         .         .         0.23543868 0.7645613 .         #>  [5,] . . .         .         .         0.09864781 0.9013522 .         #>  [6,] . . .         .         .         .          0.7647693 0.2352307 #>  [7,] . . .         .         .         .          0.6232258 0.3767742 #>  [8,] . . .         .         .         .          .         .         #>  [9,] . . .         .         .         .          .         .         #>                              #>  [1,] .          .           #>  [2,] .          .           #>  [3,] .          .           #>  [4,] .          .           #>  [5,] .          .           #>  [6,] .          .           #>  [7,] .          .           #>  [8,] 0.99414616 0.005853845 #>  [9,] 0.05157201 0.948427990 sigma_eps = 1  Y <- A_matrix %*% W + sigma_eps * rnorm(9)  plot(new_loc_1d, Y, type=\"h\") abline(0,0) # First step - Starting values for V # Considering a sample of inv-Gaussian as starting values for both chains h_nig_1d <- spde_1d$h V_1 <- matrix(ngme2::rig(10, nu, nu*h_nig_1d^2, seed = 1), nrow = 1) V_2 <- matrix(ngme2::rig(10, nu, nu*h_nig_1d^2, seed = 2), nrow = 1) W_1 <- matrix(0, nrow=1, ncol=10) W_2 <- matrix(0, nrow=1, ncol=10) N_sim = 1000  # Vector of conditional means E[w|V,Y] m_W_1 <- matrix(0, nrow=1, ncol=10) m_W_2 <- matrix(0, nrow=1, ncol=10)  # Recall that sigma_eps = 1  Asq <- t(A_matrix)%*%A_matrix / sigma_eps^2  # Recall that mu = 1 and sigma = 1 # Gibbs sampling for(i in 1:N_sim){   Q_1 <- K%*%diag(1/V_1[i,])%*%K/sigma^2   Q_2 <- K%*%diag(1/V_2[i,])%*%K/sigma^2    resp_1 <- Q_1%*%solve(K,(-h_nig_1d + V_1[i,])*mu) + t(A_matrix)%*%Y/sigma_eps^2   resp_2 <- Q_2%*%solve(K,(-h_nig_1d + V_2[i,])*mu) + t(A_matrix)%*%Y/sigma_eps^2    m_W_1 <- rbind(m_W_1, t(solve(Q_1 + Asq, resp_1)))   m_W_2 <- rbind(m_W_2, t(solve(Q_2 + Asq, resp_2)))    Chol_1 <- chol(Q_1 + Asq)   Chol_2 <- chol(Q_2 + Asq)    W_1 <- rbind(W_1, m_W_1[i+1,] + t(solve(Chol_1, rnorm(10))))   W_2 <- rbind(W_2, m_W_2[i+1,] + t(solve(Chol_2, rnorm(10))))   V_1 <- rbind(V_1, ngme2::rgig(10,                            -1,                            nu + (mu/sigma)^2,                            nu*h_nig_1d^2 + as.vector((K%*%W_1[i+1,] +h_nig_1d)^2)/sigma^2))   V_2 <- rbind(V_2, ngme2::rgig(10,                                 -1,                                 nu + (mu/sigma)^2,                                 nu*h_nig_1d^2 + as.vector((K%*%W_2[i+1,] +h_nig_1d)^2)/sigma^2)) } df_V <- data.frame(V = V_1[,1], chain = \"1\", coord = 1, idx = 1:(N_sim+1)) temp <- data.frame(V = V_2[,1], chain = \"2\", coord = 1, idx = 1:(N_sim+1)) df_V <- rbind(df_V, temp) for(i in 2:10){   temp_1 <- data.frame(V = V_1[,i], chain = \"1\", coord = i, idx = 1:(N_sim+1))   temp_2 <- data.frame(V = V_2[,i], chain = \"2\", coord = i, idx = 1:(N_sim+1))   df_V <- rbind(df_V, temp_1, temp_2) }  df_W <- data.frame(W = W_1[,1], chain = \"1\", coord = 1, idx = 1:(N_sim+1)) temp <- data.frame(W = W_2[,1], chain = \"2\", coord = 1, idx = 1:(N_sim+1)) df_W <- rbind(df_W, temp) for(i in 2:10){   temp_1 <- data.frame(W = W_1[,i], chain = \"1\", coord = i, idx = 1:(N_sim+1))   temp_2 <- data.frame(W = W_2[,i], chain = \"2\", coord = i, idx = 1:(N_sim+1))   df_W <- rbind(df_W, temp_1, temp_2) } V #>  [1] 0.0004749677 0.0056760013 0.0037506555 0.0019636490 0.0141178141 #>  [6] 0.0017224736 0.1070925727 0.0021844525 0.2940192918 0.0031267615 colMeans(V_1) #>  [1] 0.01968536 0.04965233 0.05668224 0.04677383 0.06198416 0.05058231 #>  [7] 0.05041397 0.05222572 0.04711178 0.01817159 colMeans(V_2) #>  [1] 0.02504482 0.04922318 0.03976870 0.04927722 0.04930477 0.04203808 #>  [7] 0.04797514 0.05061746 0.04849463 0.01957168  as.vector(W) #>  [1] -0.7194627 -0.7164203 -0.7085709 -0.7081622 -0.7047097 -0.7008863 #>  [7] -0.7014796 -0.7270974 -0.7429993 -0.7469908 colMeans(W_1) #>  [1] -0.8807693 -0.8806499 -0.8805828 -0.8807612 -0.8813596 -0.8831970 #>  [7] -0.8849121 -0.8866045 -0.8870817 -0.8874786 colMeans(W_2) #>  [1] -0.8858928 -0.8860544 -0.8864064 -0.8865960 -0.8863266 -0.8873130 #>  [7] -0.8887598 -0.8904176 -0.8914405 -0.8927893 ggplot(df_V, aes(x = idx, y = V, col = chain)) +   geom_line() + facet_wrap(~ coord, ncol=2) ggplot(df_W, aes(x = idx, y = W, col = chain)) +   geom_line() + facet_wrap(~ coord, ncol=2) acf_V <- as.vector(acf(V_1[,1], plot=FALSE)$acf) df_V_acf <- data.frame(acf = acf_V,                        chain = \"1\", coord = 1, lag = 0:(length(acf_V)-1)) acf_V <- as.vector(acf(V_2[,1], plot=FALSE)$acf) temp <- data.frame(acf = as.vector(acf(V_2[,1], plot=FALSE)$acf),                    chain = \"2\", coord = 1, lag = 0:(length(acf_V)-1)) df_V_acf <- rbind(df_V_acf, temp) for(i in 2:10){   acf_V <- as.vector(acf(V_1[,i], plot=FALSE)$acf)   temp_1 <- data.frame(acf = acf_V,                        chain = \"1\", coord = i, lag = 0:(length(acf_V)-1))   acf_V <- as.vector(acf(V_2[,i], plot=FALSE)$acf)   temp_2 <- data.frame(acf = acf_V,                        chain = \"2\", coord = i, lag = 0:(length(acf_V)-1))   df_V_acf <- rbind(df_V_acf, temp_1, temp_2) }  acf_W <- as.vector(acf(W_1[,1], plot=FALSE)$acf) df_W_acf <- data.frame(acf = acf_W,                        chain = \"1\", coord = 1, lag = 0:(length(acf_W)-1)) acf_W <- as.vector(acf(W_2[,1], plot=FALSE)$acf) temp <- data.frame(acf = acf_W, chain = \"2\",                    coord = 1, lag = 0:(length(acf_W)-1)) df_W_acf <- rbind(df_W_acf, temp) for(i in 2:10){   acf_W <- as.vector(acf(W_1[,i], plot=FALSE)$acf)   temp_1 <- data.frame(acf = acf_W,                        chain = \"1\", coord = i, lag = 0:(length(acf_W)-1))   acf_W <- as.vector(acf(W_2[,i], plot=FALSE)$acf)   temp_2 <- data.frame(acf = acf_W,                        chain = \"2\",                    coord = i, lag = 0:(length(acf_W)-1))   df_W_acf <- rbind(df_W_acf, temp_1, temp_2) } ggplot(df_V_acf, aes(x=lag,y=acf, col=chain)) +           geom_bar(stat = \"identity\", position = \"identity\") +   xlab('Lag') + ylab('ACF') + facet_wrap(~coord, ncol=2) ggplot(df_W_acf, aes(x=lag,y=acf, col=chain)) +           geom_bar(stat = \"identity\", position = \"identity\") +   xlab('Lag') + ylab('ACF') + facet_wrap(~coord, ncol=2) # Computing A matrix at t^\\ast  A_pred <- inla.spde.make.A(mesh_1d, loc = 5/9)  # MC_estimate:  AW_1 <- A_pred%*%t(W_1) MC_pred_1 <- cumsum(AW_1)/(1:length(AW_1))  RB_1 <- A_pred%*%t(m_W_1) RB_pred_1 <- cumsum(RB_1)/(1:length(AW_1))  df_pred <- data.frame(idx = 1:length(AW_1), MC = MC_pred_1,                       RB = RB_pred_1, chain = \"1\")  AW_2 <- A_pred%*%t(W_2) MC_pred_2 <- cumsum(AW_2)/(1:length(AW_2))  RB_2 <- A_pred%*%t(m_W_2) RB_pred_2 <- cumsum(RB_2)/(1:length(AW_2))  temp <- data.frame(idx = 1:length(AW_2), MC = MC_pred_2,                       RB = RB_pred_2, chain = \"2\")  df_pred <- rbind(df_pred, temp)  df_pred <- tidyr::pivot_longer(df_pred,      cols = c(\"MC\", \"RB\"),      names_to = \"Method\",      values_to = \"Prediction\")  ggplot(df_pred, aes(x = idx, y = Prediction, col=Method)) +   facet_wrap(~chain) + geom_line()"},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"model-estimation","dir":"Articles","previous_headings":"","what":"Model estimation","title":"Model prediction and estimation","text":"ngme2, employ maximum likelihood estimation stochastic gradient descent method estimate parameters.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"stochastic-gradient-descent-and-maximum-likelihood","dir":"Articles","previous_headings":"Model estimation","what":"Stochastic gradient descent and maximum likelihood","title":"Model prediction and estimation","text":"maximum likelihood estimation goal minimize \\(f({\\boldsymbol{\\theta}}) = -L({\\boldsymbol{\\theta}}; \\mathbf{Y})\\), \\(L\\) log-likelihood function \\(\\mathbf{Y}\\). non-Gaussian models additional complication log-likelihood function \\(L\\) known explicit form. way solve problem use Fisher’s identity (Fisher, 1925). See also Douc et al. (2014) details. Let \\(\\mathbf{U} = (U_1,\\ldots, U_n)\\) sequence observed random variables latent variables \\(\\mathbf{Z} = (Z_1,\\ldots,Z_n)\\), \\(Z_i\\) random variable \\(\\mathbb{R}^p\\). Assume joint distribution \\(\\mathbf{U}\\) \\(\\mathbf{Z}\\) parameterized \\({\\boldsymbol{\\theta}}\\), \\(\\mathbf{{\\boldsymbol{\\theta}}} \\\\Theta\\) \\(\\Theta\\subset\\mathbb{R}^p\\). Assume complete log-likelihood \\(L({\\boldsymbol{\\theta}}; \\mathbf{U},\\mathbf{Z})\\) (respect reference \\(\\sigma\\)-finite measure) differentiable respect \\({\\boldsymbol{\\theta}}\\) regular, sense one may differentiate integral sign. , marginal log-likelihood respect \\(\\mathbf{U}\\) satisfies \\[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{U}) = E_{\\mathbf{Z}}[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{U}, \\mathbf{Z})|\\mathbf{U}].\\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"standard-mc-approximation-of-the-gradient","dir":"Articles","previous_headings":"Model estimation","what":"Standard MC approximation of the gradient","title":"Model prediction and estimation","text":"context, assume \\(\\mathbf{w}\\) \\(\\mathbf{V}\\) hidden. Therefore, may use Fisher’s identity latent variable \\((\\mathbf{V},\\mathbf{w})\\) obtain \\[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}) = E_{\\mathbf{V},\\mathbf{w}}[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V}, \\mathbf{w})|\\mathbf{Y}].\\] Thus, idea use samples \\(\\mathbf{V}\\) \\(\\mathbf{w}\\) obtained Gibbs sampler approximate gradient \\[\\nabla_{{\\boldsymbol{\\theta}}}L({\\boldsymbol{\\theta}};\\mathbf{Y}) \\approx \\frac{1}{k} \\sum_{j=1}^k \\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V}^{(j)}, \\mathbf{w}^{(j)}).\\] end, compute gradients \\(\\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V}, \\mathbf{w})\\). \\[\\mathbf{Y}|\\mathbf{w} \\sim N(\\mathbf{}\\mathbf{w}, \\sigma_\\varepsilon^{-2} \\mathbf{}),\\] \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}), \\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1})\\] \\(\\mathbf{V}\\) follows GIG distribution every \\(\\), \\(E[V_i]=h_i\\). Therefore, \\[\\begin{array}{ccl} L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y}) &=& -n\\log(\\sigma_\\varepsilon)-0.5\\sigma_\\varepsilon^{-2} (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}))\\\\ &-&0.5\\sigma_\\varepsilon^{-2}(\\mathbf{}(\\mathbf{w}-\\mathbf{m})^\\top{\\rm diag} (1/V_i) (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\mathbf{w}-\\mathbf{m})) + const, \\end{array}\\] \\(const\\) depend \\((\\mu,\\sigma)\\). Thus, \\[\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y}) =  \\sigma_\\varepsilon^{-2}\\mathbf{}\\mathbf{K}^{-1}(-\\mathbf{h}+\\mathbf{V}) {\\rm diag} (1/V_i)(\\mathbf{Y}  - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}) - \\mathbf{}(\\mathbf{w}-\\mathbf{m})).\\] Now, respect \\(\\sigma_\\varepsilon\\) \\[\\nabla_{\\sigma_\\varepsilon} L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y}) = -\\frac{n}{\\sigma_\\varepsilon} + \\frac{1}{\\sigma_\\varepsilon^3} (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\mathbf{w}-\\mathbf{m}))^\\top{\\rm diag} (1/V_i) (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\mathbf{w}-\\mathbf{m}))\\] proceeding analogously, obtain gradient respect \\(\\kappa^2\\) given \\[\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{w}, \\mathbf{V}) = tr(\\mathbf{C}\\mathbf{K}^{-1})- \\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)(\\mathbf{K}\\mathbf{w}+(\\mathbf{h}-\\mathbf{V})\\mu).\\] Finally, gradient parameter distribution \\(\\mathbf{V}\\), use Rao-Blackwellized version, see next subsection.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"rao-blackwellized-approximation-of-the-gradient","dir":"Articles","previous_headings":"Model estimation","what":"Rao-Blackwellized approximation of the gradient","title":"Model prediction and estimation","text":"Now, observe can compute log-likelihood \\(L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V})\\). Indeed, apply Fisher’s identity find \\[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V}) = E_\\mathbf{w}[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V}, \\mathbf{w})|\\mathbf{Y},\\mathbf{V}].\\] , gradients, can approximate gradient \\(\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y})\\) taking mean samples \\(\\mathbf{V}\\) obtained Gibbs sampling: \\[\\nabla_{{\\boldsymbol{\\theta}}}L({\\boldsymbol{\\theta}};\\mathbf{Y}) \\approx \\frac{1}{k} \\sum_{j=1}^k \\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V}^{(j)}).\\] Let us now compute gradients \\(\\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V})\\). begin computing \\(\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{V},\\mathbf{Y})\\). end, use expression \\(\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y})\\) given previous subsection together \\(E[\\mathbf{w}|\\mathbf{V},\\mathbf{Y}] = \\widetilde{\\mathbf{m}}\\), conclude \\[\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{V},\\mathbf{Y}) =  \\sigma_\\varepsilon^{-2}\\mathbf{}\\mathbf{K}^{-1}(-\\mathbf{h}+\\mathbf{V}) {\\rm diag} (1/V_i)(\\mathbf{Y}  - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}) - \\mathbf{}(\\widetilde{\\mathbf{m}}-\\mathbf{m}))\\] Analogously, also obtain \\[\\nabla_{\\sigma_\\varepsilon} L((\\mu,\\sigma_\\varepsilon); \\mathbf{V},\\mathbf{Y}) = -\\frac{n}{\\sigma_\\varepsilon} + \\frac{1}{\\sigma_\\varepsilon^3} (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\widetilde{\\mathbf{m}}-\\mathbf{m}))^\\top{\\rm diag} (1/V_i) (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\widetilde{\\mathbf{m}}-\\mathbf{m})).\\] Now, notice \\[\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{w}, \\mathbf{V}) = tr(\\mathbf{C}\\mathbf{K}^{-1})- \\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\mathbf{w}-\\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)(\\mathbf{h}-\\mathbf{V})\\mu,\\] \\[E[\\mathbf{w}|\\mathbf{V},\\mathbf{Y}] = \\widetilde{\\mathbf{m}}\\] \\[E[\\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\mathbf{w}|\\mathbf{V},\\mathbf{Y}] =  tr(\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{Q}}^{-1}) +   \\widetilde{\\mathbf{m}}^\\top\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{m}}\\] conclude \\[\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{V}) = tr(\\mathbf{C}\\mathbf{K}^{-1})- tr(\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{Q}}^{-1}) -   \\widetilde{\\mathbf{m}}^\\top\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{m}}-\\widetilde{\\mathbf{m}}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)(\\mathbf{h}-\\mathbf{V})\\mu.\\] Finally, gradient parameter distribution \\(\\mathbf{V}\\) depends distribution \\(\\mathbf{V}\\). illustrate present gradient respect parameter \\(\\nu\\) \\(\\mathbf{V}\\) follows inverse-Gaussian distribution, situation NIG noise. case \\[\\nabla_\\nu L(\\nu; \\mathbf{Y},\\mathbf{V}) = -\\sum_{j=1}^n \\frac{1}{2}\\Bigg(\\nu^{-1} -\\frac{h_{j}^2}{V_j} +V_j -h_j\\Bigg).\\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"a-remark-on-traces","dir":"Articles","previous_headings":"Model estimation > Rao-Blackwellized approximation of the gradient","what":"A remark on traces","title":"Model prediction and estimation","text":"gradients \\(\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{V})\\) \\(\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{w}, \\mathbf{V})\\), can see traces \\(tr(\\mathbf{C}\\mathbf{K}^{-1})\\) \\(tr(\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{Q}}^{-1})\\). traces contain inverses \\(\\mathbf{K}^{-1}\\) \\(\\widetilde{\\mathbf{Q}}^{-1}\\). efficient alternatives handling traces. instance, want compute \\(tr(AB^{-1})\\), \\(B\\) symmetric, sparsity \\(B\\) sparsity \\(\\), need compute elements \\(B^{-1}\\) coordinates non-zero entries. happens, instance, \\(tr(\\mathbf{C}\\mathbf{K}^{-1})\\). , compute trace efficient alternative. implemented ngme package.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Model prediction and estimation","text":"Lindgren, F., Rue, H., Lindstrom, J. (2011). explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach. Journal Royal Statistical Society: Series B (Statistical Methodology), 73(4):423–498. Robert, C., G. Casella (2004). Monte Carlo statistical methods, Springer Texts Statistics, Springer, New York, USA. Wallin, J., Bollin, D. (2015). Geostatistical Modelling Using Non-Gaussian Matérn Fields. Scandinavian Journal Statistics. 42(3):872-890. Whittle, P. (1963). Stochastic-processes several dimensions. Bulletin International Statistical Institute, 40(2):974–994.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/replicate.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Ngme2 replicates feature","text":"Consider stochastic process \\(\\mathbf{W}\\) indexed index set \\(\\mathbf{}\\), idea allow inclusion replicates process model. example, one wants include k realizations autoregressive process order 1 \\(n\\) observations model one can following way \\[\\begin{align} X^{(j)}_1 &= \\epsilon^{(j)}_1\\\\ X^{(j)}_i &= \\alpha X^{(j)}_{-1} + \\epsilon^{(j)}_i, = 2, \\ \\cdots,\\ n \\end{align}\\] \\(X^{(j)}_i\\) denotes \\(\\text{-}th\\) observation \\(j \\text{-}th\\) realization process \\(= 1, \\ \\cdots,\\ n\\) \\(j = 1, \\ \\cdots,\\ k\\), \\(|\\alpha| < 1\\) \\(\\epsilon^{(j)}_1, \\ \\cdots \\ , \\epsilon^{(j)}_{n}\\) either ..d. NIG Gaussian noise.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/replicate.html","id":"ar1-model","dir":"Articles","previous_headings":"Usage","what":"AR(1) model","title":"Ngme2 replicates feature","text":"following example show use replicates feature AR(1) model, see detail AR(1) model (include cross-reference). Suppose one response variable \\(2n\\) observations  Note processes considered single one instead two realizations process, first observation second realization assumed dependent last one first process, might desirable cases.  can seen \\(\\mathbf{K}\\) matrix model (models form \\(K \\mathbf{W} = \\mathbf{\\ epsilon}\\)), instance, consider following little example illustrate last statement. clear link last observation first process dissapears looking \\(\\mathbf{K}_{4, 3}\\) entry matrix \\(\\mathbf{K}\\). said, one can fit model using ngme function shown .","code":"library(ngme2) library(ggplot2)  # creating ar1 process n <- 500 myar <- model_ar1(1:n, alpha = .75, noise = noise_nig())  W1 <- simulate(myar, seed = 314) # simulating one realization of the process W2 <- simulate(myar, seed = 159) # simulating another realization of the process  # Creating the response variable from the process and adding measurement noise Y <- -3 + c(W1, W2) + rnorm(2 * n, sd = .2) no.replicates <- model_ar1(1:6, alpha = .5, noise = noise_normal())  replicates <- model_ar1(rep(1:3, 2),   alpha = .5,   noise = noise_normal(), replicate = rep(1:2, each = 3) )  # K matrix from the model without replicates replicates$K #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>                  #> [1,]  1.0  .   . #> [2,] -0.5  1.0 . #> [3,]  .   -0.5 1 # K matrix from the model with replicates no.replicates$K #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                                 #> [1,]  1.0  .    .    .    .   . #> [2,] -0.5  1.0  .    .    .   . #> [3,]  .   -0.5  1.0  .    .   . #> [4,]  .    .   -0.5  1.0  .   . #> [5,]  .    .    .   -0.5  1.0 . #> [6,]  .    .    .    .   -0.5 1 # fitting the model mod.replicates <- ngme(   formula = Y ~ f(     c(1:n, 1:n),     model = \"ar1\",     replicate = group,     noise = noise_nig()   ),   data = df ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done!  mod.replicates #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -3.15 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.789 #>  #>  #> Latent models:  #> $field1 #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.545 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0.00635 #>       sigma = 0.963 #>       nu = 0.995 #>  #> Number of replicates is  2"},{"path":"https://davidbolin.github.io/ngme2/articles/replicate.html","id":"spde-matern-model","dir":"Articles","previous_headings":"Usage","what":"SPDE Matern model","title":"Ngme2 replicates feature","text":"following data taken swamp Cienaga Grande Santa Marta, Colombia. total 114 locations properties swamp measured. measurements taken twice, however information available chronological order data treated spatiotemporal, despite , multiple measurements can treated replicates. particular case temperature feature modeled.  Now briefly show fit model predict locations feature unknown.   fitted model, one can predictions follows.","code":"# library(ngme2) library(ggplot2)  # reading the data and the boundary of Cienaga Grande data(cienaga) data(cienaga.border) # scale the coords cienaga.border[, 1] <- (cienaga.border[, 1] - mean(cienaga$East)) / sd(cienaga$East) cienaga.border[, 2] <- (cienaga.border[, 2] - mean(cienaga$North)) / sd(cienaga$North) cienaga <- within(cienaga, {   East_scale <- (East - mean(East)) / sd(East)   North_scale <- (North - mean(North)) / sd(North) })  # creating label for the measurement group cienaga$measurement <- rep(1:2, each = (n <- nrow(cienaga) / 2)) # creating the mesh mesh <- INLA::inla.mesh.2d(   loc.domain = cienaga.border,   max.edge = c(0.4, 1),   max.n = 500 ) mesh$n #> [1] 460 # fitting the model fit <- ngme(   formula = temp ~ 1 +     f(as.matrix(cienaga[, 1:2]),model = \"matern\", mesh=mesh,       name = \"spde\", noise = noise_nig(), replicate=measurement),   data = cienaga,   control_opt = control_opt(     estimation = T,     iterations = 500,     n_slope_check = 10,     n_parallel_chain = 4,     print_check_info = F   ),   debug = F, ) #> Starting estimation...  #>  #> Starting posterior sampling...  #> Note: Use ngme$latents[[model_name]]$W  to access the posterior mean of process  #> Posterior sampling done! fit #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = 0.000197 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.997 #>  #>  #> Latent models:  #> $spde #>   Ngme model: matern #>   Model parameters:  #>       theta_kappa = -0.00633 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = -0.00107 #>       sigma = 1 #>       nu = 1 #>  #> Number of replicates is  2 traceplot(fit, \"spde\") nxy <- c(300, 200) projgrid <- rSPDE::rspde.mesh.projector(   mesh = mesh,   xlim = range(cienaga.border[, 1]), ylim = range(cienaga.border[, 2]),   dims = nxy )  xy.in <- splancs::inout(projgrid$lattice$loc, as.matrix(cienaga.border[, 1:2])) coord.prd <- projgrid$lattice$loc[xy.in, ] locs_rep <- list(list(coord.prd), list(coord.prd)) lp <- predict(fit, loc = locs_rep) # making the predictions  # getting the mean of the predictions for each replicate preds1 <- lp[[1]][[\"mean\"]] preds2 <- lp[[2]][[\"mean\"]] preds_mean <- 0.5 * (preds1 + preds2)"},{"path":"https://davidbolin.github.io/ngme2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Author, maintainer. Xiaotian Jin. Author. Alexandre Simas. Author. Jonas Wallin. Author.","code":""},{"path":"https://davidbolin.github.io/ngme2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Jin X, Simas , Wallin J (2023). ngme2: Latent Mixed Effects Models Flexible Distributions. R package version 0.3.0, https://davidbolin.github.io/ngme2/.","code":"@Manual{,   title = {ngme2: Latent Mixed Effects Models With Flexible Distributions},   author = {David Bolin and Xiaotian Jin and Alexandre Simas and Jonas Wallin},   year = {2023},   note = {R package version 0.3.0},   url = {https://davidbolin.github.io/ngme2/}, }"},{"path":"https://davidbolin.github.io/ngme2/index.html","id":"the-ngme2-package","dir":"","previous_headings":"","what":"Latent Mixed Effects Models With Flexible Distributions","title":"Latent Mixed Effects Models With Flexible Distributions","text":"ngme2 R package used fitting non-gaussian mixed effects models. models fitted using maximum likelihood estimation preconditioned stochastic gradient descent. Basic statistical operations likelihood evaluations kriging predictions also implemented.","code":""},{"path":"https://davidbolin.github.io/ngme2/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Latent Mixed Effects Models With Flexible Distributions","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form Lβ(τu) = 𝒲. 𝒲 Gaussian white noise, L second-order differential operator, fractional power β > 0 determines smoothness u. See explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. package aims address non-Gaussian extension SPDE approach model replacing driven noise 𝒲 non-Gaussian noise ℳ. specificly, type-G Lévy process. increment type-G Lévy process can represented $$ \\gamma + \\mu V + \\sigma \\sqrt{V}Z, $$ γ, μ parameters, Z ∼ N(0,1) independent V, V positive infinitely divisible random variable. One example normal inverse Gaussian (NIG) noise. (See vignette(\"SPDE-approach\", package = \"ngme2\") details)","code":""},{"path":"https://davidbolin.github.io/ngme2/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Latent Mixed Effects Models With Flexible Distributions","text":"development version can installed using command See also Installation Configuration vignette.","code":"remotes::install_github(\"davidbolin/ngme2\", ref = \"devel\")"},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":null,"dir":"Reference","previous_headings":"","what":"Argo float dataset — argo_float","title":"Argo float dataset — argo_float","text":"Argo floats measurements.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Argo float dataset — argo_float","text":"","code":"data(\"argo_float\")"},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Argo float dataset — argo_float","text":"Data frame containing 274 observations 4 variables. lat Latitude. lon Longitude. sal Salinity. temp Temperature.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Argo float dataset — argo_float","text":"Data can obtained Argo float website.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Argo float dataset — argo_float","text":"floats pressure case made aluminium 1.3m long 20cm diameter. weigh 40kg. top antenna communicate satellites fix float's position receive data. Also top temperature, salinity pressure sensors.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/cienaga.html","id":null,"dir":"Reference","previous_headings":"","what":"The swamp of Cienaga Grande in Santa Marta, Colombia — cienaga","title":"The swamp of Cienaga Grande in Santa Marta, Colombia — cienaga","text":"total 114 locations properties swamp measured. measurements taken twice, however information available chronological order data treated spatiotemporal, despite , multiple measurements can treated replicates.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/cienaga.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The swamp of Cienaga Grande in Santa Marta, Colombia — cienaga","text":"","code":"cienaga"},{"path":"https://davidbolin.github.io/ngme2/reference/cienaga.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"The swamp of Cienaga Grande in Santa Marta, Colombia — cienaga","text":"data frame 218 rows 6 columns. East, North location depth depth swamp temp temperature oxyg oxygen measurement 1 means first measurement, 2 second","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/cienaga.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"The swamp of Cienaga Grande in Santa Marta, Colombia — cienaga","text":"..","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate control specifications for f function — control_f","title":"Generate control specifications for f function — control_f","text":"Generate control specifications f function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate control specifications for f function — control_f","text":"","code":"control_f(   numer_grad = FALSE,   use_precond = FALSE,   use_num_hess = TRUE,   eps = 0.005 )"},{"path":"https://davidbolin.github.io/ngme2/reference/control_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate control specifications for f function — control_f","text":"numer_grad whether use numerical gradient use_precond whether use preconditioner use_num_hess whether use numerical hessian eps eps computing numerical gradient","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate control specifications for f function — control_f","text":"list control variables","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_ngme.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate control specifications for the ngme general model — control_ngme","title":"Generate control specifications for the ngme general model — control_ngme","text":"Generate control specifications ngme general model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_ngme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate control specifications for the ngme general model — control_ngme","text":"","code":"control_ngme(   init_sample_W = TRUE,   n_gibbs_samples = 5,   fix_beta = FALSE,   post_samples_size = 100,   beta = NULL,   debug = FALSE )"},{"path":"https://davidbolin.github.io/ngme2/reference/control_ngme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate control specifications for the ngme general model — control_ngme","text":"init_sample_W sample W|V beginning chain n_gibbs_samples number gibbs sampels fix_beta logical, fix fixed effect post_samples_size number posterior samples beta fixed effect value debug debug mode","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_ngme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate control specifications for the ngme general model — control_ngme","text":"list control variables block model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate control specifications for ngme() function. — control_opt","title":"Generate control specifications for ngme() function. — control_opt","text":"configurations ngme estimation optimization process.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate control specifications for ngme() function. — control_opt","text":"","code":"control_opt(   seed = Sys.time(),   burnin = 100,   iterations = 500,   stepsize = 1,   estimation = TRUE,   n_parallel_chain = 2,   stop_points = 10,   exchange_VW = TRUE,   n_slope_check = 3,   std_lim = 0.1,   trend_lim = 0.05,   print_check_info = TRUE,   max_relative_step = 0.2,   max_absolute_step = 1,   reduce_var = FALSE,   reduce_power = 0.75,   threshold = 1e-05,   window_size = 1,   verbose = FALSE )"},{"path":"https://davidbolin.github.io/ngme2/reference/control_opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate control specifications for ngme() function. — control_opt","text":"seed set seed pesudo random number generator burnin burn-periods iterations optimizing terations stepsize stepsize estimation estimating parameters n_parallel_chain number parallel chains stop_points number stop points convergence check exchange_VW exchange last V W chian n_slope_check number stop points regression std_lim maximum allowed standard deviation trend_lim maximum allowed slope print_check_info print convergence information max_relative_step max relative step allowed 1 iteration max_absolute_step max absolute step allowed 1 iteration reduce_var logical, reduce variace reduce_power numerical power reduce level threshold till start reduce variance window_size numerical, length window final estimates verbose print estimation","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate control specifications for ngme() function. — control_opt","text":"list control variables","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/control_opt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate control specifications for ngme() function. — control_opt","text":"enable convergence check, need multiple chains running.  compare trend estimated parameter length  n_slope_check (linear regression) trend_lim.  compare standard devation estimated parameters (different chains)  std_lim.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ngme noise with a list — create_noise","title":"Create ngme noise with a list — create_noise","text":"Create ngme noise list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ngme noise with a list — create_noise","text":"","code":"create_noise(x)"},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ngme noise with a list — create_noise","text":"x list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ngme noise with a list — create_noise","text":"list specification ngme","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/cross_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the cross-validation for the ngme model — cross_validation","title":"Compute the cross-validation for the ngme model — cross_validation","text":"Compute cross-validation ngme model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/cross_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the cross-validation for the ngme model — cross_validation","text":"","code":"cross_validation(   ngme,   type = \"k-fold\",   k = 5,   N = 100,   percent = 50,   times = 10,   group = NULL,   print = FALSE,   seed = Sys.time() )"},{"path":"https://davidbolin.github.io/ngme2/reference/cross_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the cross-validation for the ngme model — cross_validation","text":"ngme ngme object type character, cv type, c(\"k-fold\", \"loo\", \"lpo\") loo leave-one-, lpo leave-percent-k integer, using \"k-fold\" cv N integer, number samplings (higher, better) percent 1 100, using leave percent cv (\"lpo\") times run many times (lpo type) group group indices test set Can result last CV function, list indices print print information along process seed random seed","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/cross_validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the cross-validation for the ngme model — cross_validation","text":"list MSE, MAE, CRPS, sCRPS","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":null,"dir":"Reference","previous_headings":"","what":"Specifying a latent process model (wrapper function for each model) — f","title":"Specifying a latent process model (wrapper function for each model) — f","text":"Function used defining smooth spatial terms within ngme model formulae. function wrapper function specific submodels. (see ngme_models_types() available models).","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specifying a latent process model (wrapper function for each model) — f","text":"","code":"f(   model,   map = NULL,   replicate = NULL,   noise = noise_normal(),   control = control_f(),   name = NULL,   data = NULL,   group = NULL,   A = NULL,   A_pred = NULL,   theta_K = NULL,   W = NULL,   fix_W = NULL,   fix_theta_K = NULL,   index_pred = NULL,   debug = NULL,   index_NA = NULL,   eval = FALSE,   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specifying a latent process model (wrapper function for each model) — f","text":"model 1. string: type model, 2. ngme.spde object map symbol numerical value: index covariates build index replicate Representing replicate noise 1. string: type model, 2. ngme.noise object (can also specified ngme model) control control variables f model name name field, later use data specifed inherit ngme formula group model group (see vignette space-temporal model) Matrix connecting observation mesh A_pred Matrix connecting NA location mesh theta_K Unbounded parameter K W starting value process fix_W stop sampling W fix_theta_K fix estimation theta_K. index_pred index prediction debug Debug mode index_NA Logical vector, .na(response var.) eval evaluate model ... additional arguments inherit data ngme function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specifying a latent process model (wrapper function for each model) — f","text":"list latent_in constructing latent model, e.g. , h, C, G, also 1. Information K matrix 2. Information noise 3. Control variables","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":null,"dir":"Reference","previous_headings":"","what":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"Density, distribution function, quantile function random generation generalized asymmetric Laplace distribution  parameters mu, sigma nu, delta.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"","code":"dgal(x, delta, mu, nu, sigma, log = FALSE)  rgal(n, delta, mu, nu, sigma, seed = 0)  pgal(q, delta, mu, nu, sigma, lower.tail = TRUE, log.p = FALSE)  qgal(p, delta, mu, nu, sigma, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"x, q vector quantiles. delta numeric value location parameter. mu numeric value shift parameter. nu numeric value shape parameter. sigma numeric value scaling parameter. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"dgal gives density, pgal gives distribution function, qgal gives quantile function, rgal generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rgal.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"generalized asymmetric Laplace distribution density given  $$f(x; p, , b) =  \\frac{e^{\\nu+\\mu(x-\\delta)/\\sigma^2}\\sqrt{\\nu\\mu^2/\\sigma^2+\\nu^2}}{\\pi\\sqrt{\\nu\\sigma^2+(x-\\delta)^2}}  K_1(\\sqrt{(\\nu\\sigma^2+(x-\\delta)^2)(\\mu^2/\\sigma^4+\\nu/\\sigma^2)}),$$  \\(K_p\\) modified Bessel function second kind order \\(p\\),  \\(x>0\\), \\(\\nu>0\\) \\(\\mu,\\delta, \\sigma\\\\mathbb{R}\\).  See Barndorff-Nielsen (1977, 1978 1997) details. mixing variable $V$ follows Gamma distribution (parameterization R): $$V \\sim \\Gamma(h \\nu, \\nu),$$ poserior follows GAL distribution (special case GIG distribution): $$ -\\mu +\\mu V + \\sigma \\sqrt{V} Z \\sim GIG(h \\nu - 0.5, 2 \\nu + (\\frac{\\mu}{\\sigma})^{2}, 0) $$","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"Barndorff-Nielsen, O. (1977) Exponentially decreasing distributions logarithm particle size. Proceedings Royal Society London. Series , Mathematical Physical Sciences. Royal Society. 353, 401–409. doi:10.1098/rspa.1977.0041 Barndorff-Nielsen, O. (1978) Hyperbolic Distributions Distributions Hyperbolae, Scandinavian Journal Statistics. 5, 151–157.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/gal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Generalized Asymmetric Laplace (GAL) Distribution — gal","text":"","code":"rgal(100, delta = 0, mu = 5, sigma = 1, nu = 1) #>   [1]  0.24027904  1.24923958  1.45562159  0.92382406 11.60866115  1.07499302 #>   [7] 12.37006975  1.84177185 14.96922606  4.85780823 14.60863525  2.16217862 #>  [13]  2.47108036  1.82780120  6.67436089  0.28436911 16.06849111  6.29349624 #>  [19]  7.95732524 13.41311920  0.08685800  2.69832398  5.22434355  0.37141813 #>  [25]  9.55832103 -0.19114440  2.95379792  0.41382505  4.99274221  0.58222985 #>  [31]  1.30540911  2.50106827  1.14738071  0.36924751 21.38261962  7.15493118 #>  [37]  5.97659523  6.57053129  0.11170244  3.26443513  1.81260204  0.08702789 #>  [43] 10.50870495  4.71016917  4.69091362  0.68192790  2.71229473  6.17677998 #>  [49]  0.35619343  4.66649924  5.41066420  1.78726810  2.85266358  0.97351527 #>  [55]  1.37564606  2.95014352  4.15352439  5.00726135  3.56687580 12.41525572 #>  [61]  2.52206062  4.04031532  2.89565143  7.07002092  0.91211232  5.27572252 #>  [67]  1.09245417  2.24843863  3.53155070  7.16536684  5.22561959 25.96486687 #>  [73] 14.28122003  0.63830719  0.82782744  0.96483434  1.34613406  2.52125894 #>  [79]  3.92140434  0.33913741  3.97792238  4.86387235 17.69881181  7.43492365 #>  [85] 13.36659800  1.16190955  1.52203321  0.07312945  1.53480767  0.39258641 #>  [91]  4.22138156  5.80081576 10.18875672  2.44163084  0.40642181 11.11276030 #>  [97] 10.42625362 14.98787071 15.93672847  0.22731274 pgal(0.4, delta = 0, mu = 5, sigma = 1, nu = 1) #> [1] 0.9989855 qgal(0.8, delta = 0, mu = 5, sigma = 1, nu = 1) #> [1] 0.06083445 plot(function(x){dgal(x, delta = 0, mu = 5, sigma = 1, nu = 1)}, main = \"generalized asymmetric Laplace density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":null,"dir":"Reference","previous_headings":"","what":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"Density, distribution function, quantile function random generation generalised inverse-Gaussian distribution  parameters p, b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"","code":"dgig(x, p, a, b, log = FALSE)  rgig(n, p, a, b, seed = 0)  pgig(q, p, a, b, lower.tail = TRUE, log.p = FALSE)  qgig(prob, p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"x, q vector quantiles. p parameter p. , b parameters b. Must positive. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). prob vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"dgig gives density, pgig gives distribution function, qgig gives quantile function, rgig generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rgig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"generalised inverse-Gaussian distribution density given  $$f(x; p, , b) = ((/b)^{p/2})/(2K_p(\\sqrt{ab})) x^{p-1} \\exp\\{-(/2)x - (b/2)/x\\},$$  \\(K_p\\) modified Bessel function second kind order \\(p\\),  \\(x>0\\), \\(,b>0\\) \\(p\\\\mathbb{R}\\).  See Jørgensen (1982) details.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"Jørgensen, Bent (1982). Statistical Properties Generalized Inverse Gaussian Distribution. Lecture Notes Statistics. 9. New York–Berlin: Springer-Verlag. doi:10.1007/978-1-4612-5698-4","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"","code":"rgig(20, p = 1, a = 1, b = 1) #>  [1] 2.0653242 0.5143146 0.8647431 2.3164755 4.5958504 1.7660663 5.5402745 #>  [8] 4.1079504 3.2952847 6.1863842 1.1514763 1.0544436 1.3006170 1.2483613 #> [15] 3.2574544 5.5243075 3.4461257 2.5365111 2.7667700 1.2836168 pgig(0.4, p = 1, a = 1, b = 1) #> [1] 0.02956016 qgig(0.8, p = 1, a = 1, b = 1) #> [1] 4.055929 plot(function(x){dgig(x, p = 1, a = 1, b = 1)}, main = \"Generalised inverse-Gaussian density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":null,"dir":"Reference","previous_headings":"","what":"The Inverse-Gaussian (IG) Distribution — ig","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"Density, distribution function, quantile function random generation inverse-Gaussian distribution  parameters b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"","code":"dig(x, a, b, log = FALSE)  rig(n, a, b, seed = 0)  pig(q, a, b, lower.tail = TRUE, log.p = FALSE)  qig(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"x, q vector quantiles. , b parameters b. Must positive. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"dig gives density, pig gives distribution function, qig gives quantile function, rig generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"inverse-Gaussian distribution density given  $$f(x; , b) = \\frac{\\sqrt{b}}{\\sqrt{2\\pi x^3}}\\exp(  -\\frac{}{2}x -\\frac{b}{2x} + \\sqrt{ab}),$$  \\(x>0\\) \\(,b>0\\). parameterization,  \\(E(X) = \\sqrt{b}/\\sqrt{}\\). See Tweedie (1957a, 1957b)  details.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"Tweedie, M. C. K. (1957a). \"Statistical Properties Inverse Gaussian Distributions \". Annals Mathematical Statistics. 28 (2): 362–377. doi:10.1214/aoms/1177706964 Tweedie, M. C. K. (1957b). \"Statistical Properties Inverse Gaussian Distributions II\". Annals Mathematical Statistics. 28 (3): 696–705. doi:10.1214/aoms/1177706881","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"","code":"rig(100, a = 1, b = 1) #>   [1] 0.3426345 0.3505871 0.6296387 0.8635107 0.3621456 2.3243423 2.0607386 #>   [8] 0.6455915 3.6900756 0.2344615 0.1334820 1.7013757 0.5450169 0.3069616 #>  [15] 0.3880369 0.6928018 0.7251006 0.4644643 2.5787878 0.5898743 1.4510010 #>  [22] 1.2461388 4.9150483 1.0797067 0.3911389 0.5033584 1.3599747 2.4166308 #>  [29] 1.0112578 3.5437163 1.1691308 0.1818960 0.3704449 1.0770279 0.4349793 #>  [36] 2.1481865 0.2153102 0.4552116 0.3204858 0.9320871 0.2452545 0.6935981 #>  [43] 0.4307272 0.7934257 0.1955750 2.0203601 0.3242457 2.7533733 3.2360358 #>  [50] 1.1000263 0.3266249 3.6360385 1.0989157 0.9585330 0.3400098 0.3516045 #>  [57] 0.8699209 0.3189754 0.5305781 1.0904244 0.2887520 0.8116836 1.7078939 #>  [64] 2.0084163 1.3246715 0.4305549 0.2451912 0.5472845 0.8482784 0.9782072 #>  [71] 0.3150246 0.2068868 0.1291537 0.5241286 0.2780150 4.4275827 0.9739420 #>  [78] 0.1611175 0.2986922 0.3558652 0.7697291 0.5273665 1.4351925 0.3097891 #>  [85] 0.6091629 0.6217393 0.2752738 0.2994589 0.4353016 1.6326047 0.2203213 #>  [92] 0.3440972 1.1196840 0.4952636 0.2774535 1.0438681 0.3607554 0.1948998 #>  [99] 0.6109114 0.6065573 pig(0.4, a = 1, b = 1) #> [1] 0.2706137 qig(0.8, a = 1, b = 1) #> [1] 1.447891 plot(function(x){dig(x, a = 1, b = 1)}, main = \"Inverse-Gaussian density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":null,"dir":"Reference","previous_headings":"","what":"The Inverse-Gamma (IGam) Distribution — igam","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"Density, distribution function, quantile function random generation inverse-Gamma distribution  parameters b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"","code":"digam(x, a, b, log = FALSE)  rigam(n, a, b)  pigam(q, a, b, lower.tail = TRUE, log.p = FALSE)  qigam(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"x, q vector quantiles. , b parameters b. Must positive. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"digam gives density, pigam gives distribution function, qigam gives quantile function, rigam generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"inverse-Gamma distribution density given  $$f(x; , b) = \\frac{b^}{\\Gamma()}x^{-1}\\exp(  -\\frac{b}{x}),$$  \\(x>0\\) \\(,b>0\\).","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"","code":"rigam(100, a = 1, b = 1) #>   [1]  121.4272329    1.0039774    0.3041605    1.4727617    0.5551975 #>   [6]    1.2346869    2.4350868   13.2875738    2.7553123   53.7640576 #>  [11]    0.6048424    0.7858194    0.4504354    0.3979001    0.4603610 #>  [16]    0.3587234    0.8524874    1.1098469    1.3921284   16.4009787 #>  [21]    1.0680908    0.3155514    2.3499525    0.5391078    2.7687235 #>  [26]    6.0945592    1.0943342    1.2579519    0.6735748 2586.8445372 #>  [31]    2.6505553   48.5370361    1.5112373    5.1656503    9.1461748 #>  [36]   11.1743441    0.9992299    0.5138410    0.2080619    0.5491060 #>  [41]    2.3428477    1.7958944   23.8573648    2.4913504    0.5255949 #>  [46]    4.4190729    0.7497297    1.7013554    0.5943102    0.6515929 #>  [51]    1.0859665    1.2689509    0.4248295    4.3388014    0.5086046 #>  [56]    0.8639609    0.6248956    5.3890896    0.3377337    4.0043717 #>  [61]    1.3725586    4.9463744    0.2196784    4.3458258    2.0122371 #>  [66]    3.3973065    1.6073125    4.6988452    1.8442839    1.6929292 #>  [71]    0.6134867    2.0768915    0.6599462    0.6441853    2.4227960 #>  [76]    7.3135367    0.7616164    0.5581257    6.1228203    0.6894109 #>  [81]    0.1510728   59.7700162    0.7596358    1.8973087    1.2914319 #>  [86]    5.4227324    8.2754611    0.6545054    0.5049276    0.4429534 #>  [91]    1.8583207    0.4192033    3.9418705    2.6568914    0.2437178 #>  [96]    2.2410217    0.5780494    0.7357437  217.4584357    0.8217792 pigam(0.4, a = 1, b = 1) #> [1] 0.082085 qigam(0.8, a = 1, b = 1) #> [1] 4.48142 plot(function(x){digam(x, a = 1, b = 1)}, main = \"Inverse-Gamma density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":null,"dir":"Reference","previous_headings":"","what":"taking mean over a list of nested lists — mean_list","title":"taking mean over a list of nested lists — mean_list","text":"taking mean list nested lists","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"taking mean over a list of nested lists — mean_list","text":"","code":"mean_list(lls, weights = NULL)"},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"taking mean over a list of nested lists — mean_list","text":"lls list weights weights list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"taking mean over a list of nested lists — mean_list","text":"list nested lists","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"taking mean over a list of nested lists — mean_list","text":"","code":"ls <- list(   list(a=1, b=2, t=\"nig\", ll=list(a=1,b=2, w=\"ab\")),   list(a=3, b=5, t=\"nig\", ll=list(a=1,b=6, w=\"ab\")),   list(a=5, b=5, t=\"nig\", ll=list(a=4,b=2, w=\"ab\")) ) mean_list(ls) #> $a #> [1] 3 #>  #> $b #> [1] 4 #>  #> $t #> [1] \"nig\" #>  #> $ll #> $ll$a #> [1] 2 #>  #> $ll$b #> [1] 3.333333 #>  #> $ll$w #> [1] \"ab\" #>  #>"},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme AR(1) model specification — model_ar1","title":"ngme AR(1) model specification — model_ar1","text":"Generating C, G given index replicate","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme AR(1) model specification — model_ar1","text":"","code":"model_ar1(   map,   replicate = NULL,   index_NA = NULL,   data = NULL,   noise = noise_normal(),   alpha = 0.5,   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme AR(1) model specification — model_ar1","text":"map integer vector, time index AR(1) process replicate replicate process index_NA Logical vector, .na(response var.) data data, can specified f(), ngme() noise noise, can specified f() alpha initial value alpha ... extra arguments f()","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme AR(1) model specification — model_ar1","text":"list specification model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme AR(1) model specification — model_ar1","text":"","code":"model_ar1(c(1:3, 1:3), replicate = c(1,1,1,2,2,2)) #> Ngme model: ar1 #> Model parameters:  #>     alpha = 0.5 #>  #> Noise type - normal #> Noise parameters:  #>     sigma = 1 f(xx, model = \"ar1\", data=list(xx = c(2,4,5)), noise=noise_nig()) #> f(model = \"ar1\", map = c(2, 4, 5), noise = noise_nig(), data = list(xx = c(2,  #>     4, 5)), name = \"field\", replicate = c(1, 1, 1))"},{"path":"https://davidbolin.github.io/ngme2/reference/model_iid.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme iid model specification — model_iid","title":"ngme iid model specification — model_iid","text":"ngme iid model specification","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_iid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme iid model specification — model_iid","text":"","code":"model_iid(   map = NULL,   replicate = NULL,   data = NULL,   index_NA = NULL,   noise = noise_normal(),   control = control_f(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_iid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme iid model specification — model_iid","text":"map integer vector, time index AR(1) process replicate replicate process data data, can specified f(), ngme() index_NA Logical vector, .na(response var.) noise noise, can specified f() control controls using control_f(), ... extra arguments f()","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_iid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme iid model specification — model_iid","text":"list specification model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Matern SPDE model — model_matern","title":"Create a Matern SPDE model — model_matern","text":"Create Matern SPDE model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Matern SPDE model — model_matern","text":"","code":"model_matern(   map,   replicate = NULL,   alpha = 2,   kappa = 1,   theta_kappa = NULL,   B_kappa = NULL,   mesh = NULL,   d = NULL,   index_NA = NULL,   noise = noise_normal(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Matern SPDE model — model_matern","text":"map numeric vector (1d) matrix column 2 (2d), location make index keep aligned Y make prediction index_NA!!! replicate replicate process alpha 2 4, SPDE smoothness parameter kappa parameterization kappa^2 C + G, stationary theta_kappa parameterization non-stationary B_kappa bases kappa mesh mesh argument d indicating dimension mesh (together fem.mesh.matrices) index_NA Logical vector, .na(response var.) noise 1. string: type model, 2. ngme.noise object ... extra arguments f()","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Matern SPDE model — model_matern","text":"list (n, C (diagonal), G, B.kappa) constructing operator","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ou.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme model - Ornstein–Uhlenbeck process — model_ou","title":"ngme model - Ornstein–Uhlenbeck process — model_ou","text":"ngme model - Ornstein–Uhlenbeck process","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ou.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme model - Ornstein–Uhlenbeck process — model_ou","text":"","code":"model_ou(   map,   B_theta_K = NULL,   theta_K = 0,   replicate = NULL,   data = NULL,   index_NA = NULL,   noise = noise_normal(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_ou.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme model - Ornstein–Uhlenbeck process — model_ou","text":"map numerical vector, covariates build index process B_theta_K Basis matrix theta, default matrix 1 theta_K theta parameter, exp(B_theta * theta) replicate replicate process data specifed inherit ngme formula circular, treat 1st location last location . index_NA Logical vector, .na(response variable) noise 1. string: type model, 2. ngme.noise object (can also specified ngme model) ... additional arguments","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ou.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme model - Ornstein–Uhlenbeck process — model_ou","text":"list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ou.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme model - Ornstein–Uhlenbeck process — model_ou","text":"","code":"r2 <- model_ou(1:7, theta_K = 2); r2$K #> 7 x 7 sparse Matrix of class \"dgCMatrix\" #>                                                                     #> [1,] 4.694528 .        .        .        .        .        .        #> [2,] 2.694528 4.694528 .        .        .        .        .        #> [3,] .        2.694528 4.694528 .        .        .        .        #> [4,] .        .        2.694528 4.694528 .        .        .        #> [5,] .        .        .        2.694528 4.694528 .        .        #> [6,] .        .        .        .        2.694528 4.694528 .        #> [7,] .        .        .        .        .        2.694528 4.694528"},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme model - random walk of order 1 — model_rw","title":"ngme model - random walk of order 1 — model_rw","text":"Generating C, G given index replicate size C G (n-1) * n, size V n-1","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme model - random walk of order 1 — model_rw","text":"","code":"model_rw(   map,   order = 1,   replicate = NULL,   data = NULL,   circular = FALSE,   index_NA = NULL,   noise = noise_normal(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme model - random walk of order 1 — model_rw","text":"map numerical vector, covariates build index process order 1 2, order random walk model replicate replicate process data specifed inherit ngme formula circular whether mesh circular, .e. first one connected last circular, treat 1st location last location . index_NA Logical vector, .na(response variable) noise 1. string: type model, 2. ngme.noise object (can also specified ngme model) ... additional arguments","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme model - random walk of order 1 — model_rw","text":"list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme model - random walk of order 1 — model_rw","text":"","code":"r1 <- model_rw(1:7, order = 1, circular = TRUE); r1$C + r1$G #> 7 x 7 sparse Matrix of class \"dgCMatrix\" #>                           #> [1,]  1 -1  .  .  .  .  . #> [2,]  .  1 -1  .  .  .  . #> [3,]  .  .  1 -1  .  .  . #> [4,]  .  .  .  1 -1  .  . #> [5,]  .  .  .  .  1 -1  . #> [6,]  .  .  .  .  .  1 -1 #> [7,] -1  .  .  .  .  .  1 r2 <- model_rw(1:7, order = 1); r2$C + r2$G #> 6 x 7 sparse Matrix of class \"dgCMatrix\" #>                          #> [1,] -1  1  .  .  .  . . #> [2,]  . -1  1  .  .  . . #> [3,]  .  . -1  1  .  . . #> [4,]  .  .  . -1  1  . . #> [5,]  .  .  .  . -1  1 . #> [6,]  .  .  .  .  . -1 1"},{"path":"https://davidbolin.github.io/ngme2/reference/model_tp.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme tensor-product model specification — model_tp","title":"ngme tensor-product model specification — model_tp","text":"Given 2 models (left right), build tensor-product model based K = K_left x K_right (x Kronecker product)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_tp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme tensor-product model specification — model_tp","text":"","code":"model_tp(   left = NULL,   right = NULL,   map = NULL,   replicate = NULL,   data = NULL,   index_NA = NULL,   noise = noise_normal(),   control = control_f(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_tp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme tensor-product model specification — model_tp","text":"left ngme_model right ngme_model map can ignored, pass left right replicate replicate process data data, can specified f(), ngme() index_NA Logical vector, .na(response var.) noise noise, can specified f() control control model ... extra arguments f()","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_tp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme tensor-product model specification — model_tp","text":"list specification model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an additice linear mixed effect model — ngme","title":"Fit an additice linear mixed effect model — ngme","text":"ngme function performs analysis non-gaussian additive models.  maximum likelihood estimation via stochastic gradient descent.  prediction unknown location can performed leaving response  variable NA. likelihood specified family. model estimation control can setted control using  control_opt() function, see ?control_opt details. See ngme_model_types() available models.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an additice linear mixed effect model — ngme","text":"","code":"ngme(   formula,   data,   family = \"normal\",   control_opt = NULL,   control_ngme = NULL,   start = NULL,   debug = FALSE )"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an additice linear mixed effect model — ngme","text":"formula formula data dataframe list providing data (response variable can contain NA value,  NA value columns cause problem) family likelihood type, measurement noise specification, 1. string 2. ngme noise obejct control_opt control optimizer. default control_opt(). See ?control_opt details. control_ngme control ngme model. default control_ngme(). See ?control_ngme details. start starting ngme object (usually object last fitting) debug toggle debug mode","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an additice linear mixed effect model — ngme","text":"list outputs contains estimation operator paramters, noise parameters","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an additice linear mixed effect model — ngme","text":"","code":"ngme(  formula = Y ~ x1 + f(    x2,    model = \"ar1\",    noise = noise_nig(),    theta_K = 0.5  ) + f(x1,    model = \"rw\",    order = 1,    circular = TRUE,    noise = noise_normal(),  ),  family = noise_normal(sd = 0.5),  data = data.frame(Y = 1:5, x1 = 2:6, x2 = 3:7),  control_opt = control_opt(    estimation = FALSE  ) ) #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -1,  1 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1 #>  #>  #> Latent models:  #> $field1 #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.5 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0 #>       sigma = 1 #>       nu = 1 #> $field2 #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1 #>  #> Number of replicates is  1"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme2.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme2 — ngme2","title":"ngme2 — ngme2","text":"Inference prediction mixed effects models flexible non-Gaussian Gaussian distributions.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ngme2 — ngme2","text":"David Bolin <davidbolin@gmail.com>","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"Convert sparse matrix sparse dgCMatrix","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"","code":"ngme_as_sparse(G)"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"G matrix","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"sparse dgCMatrix","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_model_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Show ngme mdoel types — ngme_model_types","title":"Show ngme mdoel types — ngme_model_types","text":"Show ngme mdoel types","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_model_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show ngme mdoel types — ngme_model_types","text":"","code":"ngme_model_types()"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_model_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show ngme mdoel types — ngme_model_types","text":"available types models","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme noise specification — ngme_noise","title":"ngme noise specification — ngme_noise","text":"Function specifying ngme noise. Please use noise_nig noise_normal simpler usage. Use ngme_noise_types() check available types.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme noise specification — ngme_noise","text":"","code":"ngme_noise(   noise_type,   mu = 0,   sigma = 1,   nu = 1,   n = 1,   theta_mu = NULL,   B_mu = NULL,   theta_sigma = NULL,   B_sigma = NULL,   B_sigma_normal = NULL,   fix_theta_mu = FALSE,   fix_theta_sigma = FALSE,   fix_nu = FALSE,   V = NULL,   h = NULL,   fix_V = FALSE,   theta_sigma_normal = NULL,   ... )  noise_normal(   sigma = NULL,   theta_sigma = NULL,   B_sigma = matrix(1, 1, 1),   n = nrow(B_sigma),   ... )  noise_nig(   mu = NULL,   sigma = NULL,   nu = NULL,   n = 1,   V = NULL,   theta_mu = NULL,   theta_sigma = NULL,   B_mu = matrix(1),   B_sigma = matrix(1),   ... )  noise_gal(   mu = NULL,   sigma = NULL,   nu = NULL,   n = 1,   V = NULL,   theta_mu = NULL,   theta_sigma = NULL,   B_mu = matrix(1),   B_sigma = matrix(1),   ... )  noise_normal_nig(   sigma_normal = NULL,   mu = NULL,   sigma_nig = NULL,   nu = NULL,   n = 1,   V = NULL,   theta_mu = NULL,   theta_sigma_nig = NULL,   theta_sigma_normal = NULL,   B_mu = matrix(1),   B_sigma_nig = matrix(1),   B_sigma_normal = matrix(1),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme noise specification — ngme_noise","text":"noise_type type noise, \"nig\", \"normal\" mu specify NIG noise parameter mu, see ?nig sigma specify noise parameter sigma, see ?nig nu specify NIG noise parameter nu (nu>0), see ?nig n number noise (= nrow(B_mu) = nrow(B_sigma)) theta_mu specify non-stationary noise using theta_mu B_mu Basis matrix mu (non-stationary) theta_sigma specify non-stationary noise using theta_sigma B_sigma Basis matrix sigma (non-stationary) B_sigma_normal normal nosie nig noise sharing parameter fix_theta_mu fix parameter theta_mu fix_theta_sigma fix parameter theta_sigma fix_nu fix parameter nu V start value V h numerical vector (> 0), mesh width fix_V fix sampling V theta_sigma_normal normal nosie nig noise sharing parameter ... additional arguments sigma_normal normal nosie nig noise sharing parameter sigma_nig similar sigma_normal theta_sigma_nig similar theta_sigma_normal B_sigma_nig similar B_sigma_nig","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme noise specification — ngme_noise","text":"list specification noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ngme noise specification — ngme_noise","text":"parameterization given ?nig. Moreover, specifying non-stationary mu sigma, $$\\mu = B_{\\mu} \\theta_{\\mu},$$ $$\\sigma = \\exp (B_{\\sigma} \\theta_{\\sigma}),$$","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme noise specification — ngme_noise","text":"","code":"noise_normal(n = 10, sigma = 2) #> Noise type - normal #> Noise parameters:  #>     sigma = 2 noise_nig(mu = 1, sigma = 2, nu = 1, n=10) #> Noise type - nig #> Noise parameters:  #>     mu = 1 #>     sigma = 2 #>     nu = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise_types.html","id":null,"dir":"Reference","previous_headings":"","what":"show ngme noise types — ngme_noise_types","title":"show ngme noise types — ngme_noise_types","text":"show ngme noise types","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"show ngme noise types — ngme_noise_types","text":"","code":"ngme_noise_types()"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"show ngme noise types — ngme_noise_types","text":"available types noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse the formula for ngme function — ngme_parse_formula","title":"Parse the formula for ngme function — ngme_parse_formula","text":"Parse formula ngme function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse the formula for ngme function — ngme_parse_formula","text":"","code":"ngme_parse_formula(fm, data, control_ngme, noise)"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse the formula for ngme function — ngme_parse_formula","text":"fm Formula data data.frame control_ngme control_ngme noise noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse the formula for ngme function — ngme_parse_formula","text":"list (replicate) ngme_block models","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":null,"dir":"Reference","previous_headings":"","what":"Make observation matrix for time series — ngme_ts_make_A","title":"Make observation matrix for time series — ngme_ts_make_A","text":"Make observation matrix time series","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make observation matrix for time series — ngme_ts_make_A","text":"","code":"ngme_ts_make_A(loc, replicate = NULL, range = c(min(loc), max(loc)))"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make observation matrix for time series — ngme_ts_make_A","text":"loc integers (sorting, gaps > 1) replicate indicating replicate measure location range range mesh default range=(min(loc), max(loc))","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make observation matrix for time series — ngme_ts_make_A","text":"matrix (length(loc) * length(unique(loc)))","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make observation matrix for time series — ngme_ts_make_A","text":"","code":"ngme_ts_make_A(c(1, 2, 2), replicate = c(1, 1, 2)) #> 3 x 4 sparse Matrix of class \"dgCMatrix\" #>              #> [1,] 1 . . . #> [2,] . 1 . . #> [3,] . . . 1 ngme_ts_make_A(c(1, 2, 2), range = c(1, 5)) #> 3 x 5 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] 1 . . . . #> [2,] . 1 . . . #> [3,] . 1 . . ."},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":null,"dir":"Reference","previous_headings":"","what":"The Normal Inverse-Gaussian (NIG) Distribution — nig","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"Density, distribution function, quantile function random generation normal inverse-Gaussian distribution  parameters p, b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"","code":"dnig(x, delta, mu, nu, sigma, h = NULL, log = FALSE)  rnig(n, delta, mu, nu, sigma, h = NULL, seed = 0)  pnig(q, delta, mu, nu, sigma, h = NULL, lower.tail = TRUE, log.p = FALSE)  qnig(p, delta, mu, nu, sigma, h = NULL, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"x, q vector quantiles. delta numeric value location parameter. mu numeric value shift parameter. nu numeric value shape parameter. sigma numeric value scaling parameter. h numeric value additional parameter, see details. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"dnig gives density, pnig gives distribution function, qnig gives quantile function, rnig generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rnig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"normal inverse-Gaussian distribution density given  $$f(x; \\delta, \\mu, \\sigma, \\nu) =  \\frac{e^{\\nu+\\mu(x-\\delta)/\\sigma^2}\\sqrt{\\nu\\mu^2/\\sigma^2+\\nu^2}}{\\pi\\sqrt{\\nu\\sigma^2+(x-\\delta)^2}}  K_1(\\sqrt{(\\nu\\sigma^2+(x-\\delta)^2)(\\mu^2/\\sigma^4+\\nu/\\sigma^2)}),$$  \\(K_p\\) modified Bessel function second kind order \\(p\\),  \\(x>0\\), \\(\\nu>0\\) \\(\\mu,\\delta, \\sigma\\\\mathbb{R}\\).  See Barndorff-Nielsen (1977, 1978 1997) details. additional parameter h used $$V\\sim IG(\\nu,\\nu h^{2})$$. infinite divisibility, $$\\frac{1}{h} V \\sim IG(\\nu h, \\nu h)$$. $$\\delta+\\mu V + \\sigma \\sqrt{V} Z$$ distribution $$NIG(\\delta=-\\mu h,\\mu= \\mu h, \\sigma=\\sigma \\sqrt{h}, \\nu=\\nu h).$$","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"Barndorff-Nielsen, O. (1977) Exponentially decreasing distributions logarithm particle size. Proceedings Royal Society London. Series , Mathematical Physical Sciences. Royal Society. 353, 401–409. doi:10.1098/rspa.1977.0041 Barndorff-Nielsen, O. (1978) Hyperbolic Distributions Distributions Hyperbolae, Scandinavian Journal Statistics. 5, 151–157. Barndorff-Nielsen, O. (1997) Normal Inverse Gaussian Distributions Stochastic Volatility Modelling, Scandinavian Journal Statistics. 24, 1-13. doi:10.1111/1467-9469.00045","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Normal Inverse-Gaussian (NIG) Distribution — nig","text":"","code":"rnig(100, delta = 0, mu = 5, sigma = 1, nu = 1) #>   [1]  0.1270913  1.4656925  6.6171638 15.1928585  2.4939753  1.1335087 #>   [7]  2.8280508  1.6825073  7.3612887  0.9068780  1.5638977  1.7493948 #>  [13]  0.7275122  2.8288338  9.1228529  3.0654131 27.2074800  1.0903220 #>  [19]  1.2845504  2.5787501 14.6182853  6.1667380  7.6269799  0.8017174 #>  [25]  3.5631220  0.9531420  0.2377437  9.4581159  4.1970798  5.4377457 #>  [31]  5.5377894  1.5793022  2.8969151  4.3322684  3.9244859  7.8558820 #>  [37]  3.4599970  1.5246606  6.0350005  1.8276959  1.9878179  2.8045594 #>  [43]  1.3712727  2.6881162  3.1179654  5.1603159 13.2198822  7.8296410 #>  [49] 28.4396871 13.7834561  0.4973799  2.3102499  3.8424694  3.7345881 #>  [55]  5.9383534  0.6534134  1.7979329  1.1205463  4.9082411  1.9693042 #>  [61]  6.7673597  0.8556340  0.6359376  9.9707585  1.8641061  4.1469278 #>  [67]  3.1448771  1.2236990  2.3097655  8.6139399  3.7910485  4.2453485 #>  [73]  4.2671000  1.8039631  2.0559741  0.7330293  6.6586316  6.7470519 #>  [79]  2.0617640  1.4676315  3.9090400 12.0947134 16.8644241  4.2025632 #>  [85] 14.4659227 15.7087981  1.6441854  4.2029487  9.9279267  6.1463269 #>  [91]  8.6964238  5.6165971  1.7971166  1.9532957  1.4190903  1.1159223 #>  [97]  4.3507899  3.7552163  0.9488302  6.4673222 pnig(0.4, delta = 0, mu = 5, sigma = 1, nu = 1) #> [1] 0.01597497 qnig(0.8, delta = 0, mu = 5, sigma = 1, nu = 1) #> [1] 7.390234 plot(function(x){dnig(x, delta = 0, mu = 5, sigma = 1, nu = 1)}, main = \"Normal inverse-Gaussian density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"plot the density of noise (for stationary) — plot.ngme_noise","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"plot density noise (stationary)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"","code":"# S3 method for ngme_noise plot(x, y = NULL, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"x ngme_noise y another ngme_noise ... ...","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"plot","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"","code":"plot(noise_nig(mu=1, sigma=2, nu=1))"},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict function of ngme2\npredict using ngme after estimation — predict.ngme","title":"Predict function of ngme2\npredict using ngme after estimation — predict.ngme","text":"Predict function ngme2 predict using ngme estimation","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict function of ngme2\npredict using ngme after estimation — predict.ngme","text":"","code":"# S3 method for ngme predict(   object,   data = NULL,   loc = NULL,   type = \"lp\",   estimator = c(\"mean\", \"sd\", \"5quantile\", \"95quantile\", \"median\", \"mode\"),   sampling_size = 100,   q = NULL,   seed = Sys.time(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict function of ngme2\npredict using ngme after estimation — predict.ngme","text":"object ngme object data data.frame matrix covariates (used fixed effects) loc named list (dataframe) locations make prediction names(loc) corresponding name latent model vector matrix (n * 2) spatial coords type type prediction, c(\"fe\", \"lp\", \"field1\") estimator type estimator, c(\"mean\", \"median\", \"mode\", \"quantile\") sampling_size size posterior sampling q quantile using \"quantile\" seed random seed ... extra argument 0 1 using \"quantile\"","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict function of ngme2\npredict using ngme after estimation — predict.ngme","text":"list outputs contains estimation operator paramters, noise parameters","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict function of ngme2\npredict using ngme after estimation\nsame as predict.ngme(ngme[[i]], data[[i]], loc[[i]]) i in which.rep — predict.ngme_fit","title":"Predict function of ngme2\npredict using ngme after estimation\nsame as predict.ngme(ngme[[i]], data[[i]], loc[[i]]) i in which.rep — predict.ngme_fit","text":"Predict function ngme2 predict using ngme estimation predict.ngme(ngme[[]], data[[]], loc[[]]) .rep","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict function of ngme2\npredict using ngme after estimation\nsame as predict.ngme(ngme[[i]], data[[i]], loc[[i]]) i in which.rep — predict.ngme_fit","text":"","code":"# S3 method for ngme_fit predict(   object,   which.rep = seq_along(object),   data = NULL,   loc = list(NULL),   type = \"lp\",   estimator = c(\"mean\", \"sd\", \"5quantile\", \"95quantile\", \"median\", \"mode\"),   sampling_size = 100,   q = NULL,   seed = Sys.time(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict function of ngme2\npredict using ngme after estimation\nsame as predict.ngme(ngme[[i]], data[[i]], loc[[i]]) i in which.rep — predict.ngme_fit","text":"object ngme_fit object .rep replicate use prediction, can vector like c(1,2) data data.frame covariates (used fixed effects) loc named list (dataframe) locations make prediction names(loc) corresponding name latent model vector matrix (n * 2) spatial coords type type prediction, c(\"fe\", \"lp\", \"field1\") estimator type estimator, c(\"mean\", \"median\", \"mode\", \"quantile\") sampling_size size posterior sampling q quantile using \"quantile\" seed random seed ... extra argument 0 1 using \"quantile\"","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/predict.ngme_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict function of ngme2\npredict using ngme after estimation\nsame as predict.ngme(ngme[[i]], data[[i]], loc[[i]]) i in which.rep — predict.ngme_fit","text":"list outputs contains estimation operator paramters, noise parameters","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ngme object — print.ngme","title":"Print ngme object — print.ngme","text":"Print ngme object","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ngme object — print.ngme","text":"","code":"# S3 method for ngme print(x, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ngme object — print.ngme","text":"x ngme object ... ignored","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ngme object — print.ngme","text":"list (noise specifications)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ngme model — print.ngme_model","title":"Print ngme model — print.ngme_model","text":"Print ngme model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ngme model — print.ngme_model","text":"","code":"# S3 method for ngme_model print(x, padding = 0, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ngme model — print.ngme_model","text":"x ngme model object padding number white space padding front ... ...","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ngme model — print.ngme_model","text":"list (model specifications)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ngme noise — print.ngme_noise","title":"Print ngme noise — print.ngme_noise","text":"Print ngme noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ngme noise — print.ngme_noise","text":"","code":"# S3 method for ngme_noise print(x, padding = 0, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ngme noise — print.ngme_noise","text":"x noise object padding number white space padding front ... ...","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ngme noise — print.ngme_noise","text":"list (noise specifications)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate latent process with noise — simulate.ngme_model","title":"Simulate latent process with noise — simulate.ngme_model","text":"Simulate latent process noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate latent process with noise — simulate.ngme_model","text":"","code":"# S3 method for ngme_model simulate(object, nsim = 1, seed = NULL, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate latent process with noise — simulate.ngme_model","text":"object ngme model specified f() function nsim ignored seed seed ... ignored","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate latent process with noise — simulate.ngme_model","text":"realization latent model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate latent process with noise — simulate.ngme_model","text":"","code":"B_sigma <- matrix(1:10 / 10, nrow=10) simulate(noise_nig(n = 10, B_sigma = B_sigma)) #>  [1] -0.06073883 -0.62974732  1.09977105 -0.33515618  0.79990933 -0.04654890 #>  [7]  0.52503004  1.76017501 -0.46101617 -3.63859652 #> attr(,\"noise\") #> Noise type - nig #> Noise parameters:  #>     mu = 0 #>     sigma = 1 #>     nu = 1 simulate(noise_normal(theta_sigma = 1.5, B_sigma = B_sigma)) #>  [1] -1.3958992 -2.7118344  1.3480968 -2.4335415 -2.1775443 -2.3336252 #>  [7] -0.7462013 -0.5470553 -3.6476613  4.1533083 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 4.48 simulate(model_ar1(1:10, theta_K = 0.4, noise = noise_nig())) #>  [1] -0.29671742  1.33306017  2.03357357  2.12658396  1.22949058  0.75536640 #>  [7]  0.06217112  0.82248668 -0.69001354 -1.30729887 #> attr(,\"noise\") #> Noise type - nig #> Noise parameters:  #>     mu = 0 #>     sigma = 1 #>     nu = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate ngme noise — simulate.ngme_noise","title":"Simulate ngme noise — simulate.ngme_noise","text":"Simulate ngme noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate ngme noise — simulate.ngme_noise","text":"","code":"# S3 method for ngme_noise simulate(object, nsim = 1, seed = NULL, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate ngme noise — simulate.ngme_noise","text":"object ngme noise object nsim ignored seed seed ... can take n_noise = 3 (measurement noise)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate ngme noise — simulate.ngme_noise","text":"realization ngme noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate ngme noise — simulate.ngme_noise","text":"","code":"simulate(noise_normal(sd = 5, n = 10)) #>  [1] -0.411067105  0.336386059 -1.542612231 -1.918260663 -0.120069292 #>  [6]  0.905237299 -0.001569842  0.953048051 -0.666563095  1.922664213 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":null,"dir":"Reference","previous_headings":"","what":"c(","title":"c(","text":"c(\"fe\", \"beta\") fixed effects,   c(\"mn\", \"noise\") measurement nosie Trace plot ngme fitting","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"c(","text":"","code":"traceplot(ngme, name = \"general\")"},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"c(","text":"ngme ngme object name name latent models, otherwise plot fixed effects measurement noise names(ngme$latents) ","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"c(","text":"traceplot","code":""},{"path":"https://davidbolin.github.io/ngme2/news/index.html","id":"ngme2-development-version","dir":"Changelog","previous_headings":"","what":"ngme2 (development version)","title":"ngme2 (development version)","text":"First version package","code":""},{"path":"https://davidbolin.github.io/ngme2/news/index.html","id":"version-020","dir":"Changelog","previous_headings":"","what":"version 0.2.0","title":"version 0.2.0","text":"Finish main functions","code":""},{"path":"https://davidbolin.github.io/ngme2/news/index.html","id":"version-030","dir":"Changelog","previous_headings":"","what":"version 0.3.0","title":"version 0.3.0","text":"Add replicate feature Add OU process Add tensor-product model","code":""}]
