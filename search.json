[{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Ngme2 AR(1) model","text":"autoregressive model order 1 (AR(1)) specifies output variable depends linearly previous values stochastic term. simplest AR model AR(1) model, given : \\[\\begin{align} X_1 &= \\epsilon_1, \\\\ X_i &= \\alpha X_{-1} + \\epsilon_i, \\; = 2, \\dots , n, \\end{align}\\] \\(|\\alpha| < 1\\), \\(\\epsilon_1, ..,\\epsilon_n\\) either ..d. NIG Gaussian noise. easy verify \\[ K{\\bf X} = \\boldsymbol\\epsilon,\\] \\({\\bf X} = (X_1, \\dots, X_n)\\), \\({\\boldsymbol \\epsilon} = (\\epsilon_1, \\dots, \\epsilon_n)\\), \\[ K =   \\begin{bmatrix}     1 \\\\     -\\alpha &  1 \\\\     & \\ddots & \\ddots \\\\     & & -\\alpha &  1   \\end{bmatrix}. \\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Ngme2 AR(1) model","text":"Use model_ar1 f(model=\"ar1\") (formula) specify AR(1) model. Notice AR(1) process well defined integer mesh (can gaps), see following examples:","code":"library(ngme2) set.seed(16)  m1 <- model_ar1(3:5, noise = noise_normal()) #> as(<dgTMatrix>, \"dgCMatrix\") is deprecated since Matrix 1.5-0; do as(., \"CsparseMatrix\") instead # check the operator matrix m1$K #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>                  #> [1,]  1.0  .   . #> [2,] -0.5  1.0 . #> [3,]  .   -0.5 1 # length is 5 - 3 + 1  m2 <- model_ar1(c(2011, 2012, 2015, 2016), noise = noise_nig(mu=5, sigma=1.5)) m2$K #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                                 #> [1,]  1.0  .    .    .    .   . #> [2,] -0.5  1.0  .    .    .   . #> [3,]  .   -0.5  1.0  .    .   . #> [4,]  .    .   -0.5  1.0  .   . #> [5,]  .    .    .   -0.5  1.0 . #> [6,]  .    .    .    .   -0.5 1 # length is 2016 - 2011 + 1 = 6  # specify mesh with replicates m3 <- model_ar1(c(1:5, 1:5), replicates = c(rep(1, 5), rep(2, 5))) m3$K #> 10 x 10 sparse Matrix of class \"dgCMatrix\" #>                                                   #>  [1,]  1.0  .    .    .   .  .    .    .    .   . #>  [2,] -0.5  1.0  .    .   .  .    .    .    .   . #>  [3,]  .   -0.5  1.0  .   .  .    .    .    .   . #>  [4,]  .    .   -0.5  1.0 .  .    .    .    .   . #>  [5,]  .    .    .   -0.5 1  .    .    .    .   . #>  [6,]  .    .    .    .   .  1.0  .    .    .   . #>  [7,]  .    .    .    .   . -0.5  1.0  .    .   . #>  [8,]  .    .    .    .   .  .   -0.5  1.0  .   . #>  [9,]  .    .    .    .   .  .    .   -0.5  1.0 . #> [10,]  .    .    .    .   .  .    .    .   -0.5 1 # index with double is not supported # not run: # model_ar1(rnorm(10))"},{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Ngme2 AR(1) model","text":"Simulating AR(1) model ngme2 simple. Just pass corresponding model simulate function.","code":"n_obs <- 500 day <- 1:n_obs Y <- simulate(   model_ar1(day, alpha = 0.5, noise = noise_nig(mu = 2, sigma = 2)),   seed = 16 )  # check the acf to see the correlation acf(Y)"},{"path":"https://davidbolin.github.io/ngme2/articles/AR1-model.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Ngme2 AR(1) model","text":"part show estiamte AR model using ngme function. can use ngme_control modify control variables ngme. See ?ngme_control optioins.","code":"x1 = runif(n_obs) x2 = rexp(n_obs) beta <- c(-3, -1, 2) X <- (model.matrix(Y ~ x1 + x2))  # design matrix Y <- as.numeric(Y + X %*% beta) # add some fixed effects Y <- Y + rnorm(n_obs, sd = 1) # add measurement noise  # Fit the model with the AR1 model ngme_out <- ngme(   Y ~ x1 + x2 + f(     1:n_obs,     model = \"ar1\",     noise = noise_nig(),     theta_K = 0.9  # starting point for the alpha (parameter of K)   ),   data = data.frame(x1=x1, x2=x2, Y=Y),   control = ngme_control(     burnin = 100,     iterations = 2000,     std_lim = 0.6,     gibbs_sample = 5,     n_parallel_chain = 4,     stop_points = 10,     print_check_info = FALSE   ),   seed = 3 ) #> Starting estimation...  #> Estimation done!  ngme_out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -2.70, -1.12,  1.88 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1.08 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.531 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 3.29 #>       sigma = 0.868 #>       nu = 2.05  # traceplot of the measurement noise sigma traceplot(ngme_out, param = \"sigma\", f_index = 0) # traceplots of the AR(1) model traceplot(ngme_out, param = \"alpha\", f_index = 1) traceplot(ngme_out, param = \"mu\", f_index = 1) traceplot(ngme_out, param = \"sigma\", f_index = 1) # comparing the density of the noise estimated and the noise simulated plot(ngme_out$latents[[1]]$noise,   noise_nig(mu = 2, sigma = 1.5))"},{"path":"https://davidbolin.github.io/ngme2/articles/Installation_and_configuration.html","id":"mac-os-x","dir":"Articles","previous_headings":"","what":"Mac OS X","title":"Installation and configuration","text":"Mac OS X system, default C++ compiler OS X support OpenMP. order make use OpenMP enable multi-threading OS X, need use compilers supports OpneMP.","code":"➜ clang -fopenmp hello.cpp clang: error: unsupported option '-fopenmp'"},{"path":"https://davidbolin.github.io/ngme2/articles/Installation_and_configuration.html","id":"install-a-openmp-supported-clang-as-default-cc-compiler-","dir":"Articles","previous_headings":"Mac OS X","what":"1. Install a OpenMP supported clang as default C/C++ compiler.","title":"Installation and configuration","text":"’s need install another compiler supports OpenMP. use homebrew installing llvm clang compiler using following scripts. (Check homebrew can just run following command install homebrew.) successful, able see following prompt. make llvm clang default compiler, need update PATH variable, reopen terminal make work: Now able use llvm clang OpenMP support. Let’s test : case, llvm lib include folder already added default clang search path. (can check search path run commands like clang hello.cpp -v, otherwise may need include mannually -L -, can also export system variable suggested, use makefile compile).","code":"/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ➜ brew install llvm  ... To use the bundled libc++ please add the following LDFLAGS:   LDFLAGS=\"-L/usr/local/opt/llvm/lib/c++ -Wl,-rpath,/usr/local/opt/llvm/lib/c++\"  llvm is keg-only, which means it was not symlinked into /usr/local, because macOS already provides this software and installing another version in parallel can cause all kinds of trouble.  If you need to have llvm first in your PATH, run:   echo 'export PATH=\"/usr/local/opt/llvm/bin:$PATH\"' >> ~/.zshrc  For compilers to find llvm you may need to set:   export LDFLAGS=\"-L/usr/local/opt/llvm/lib\"   export CPPFLAGS=\"-I/usr/local/opt/llvm/include\" ➜ echo 'export PATH=\"/usr/local/opt/llvm/bin:$PATH\"' >> ~/.zshrc ➜ clang -fopenmp hello.cpp"},{"path":"https://davidbolin.github.io/ngme2/articles/Installation_and_configuration.html","id":"configure-the-r-environment-to-make-use-of-the-new-compiler-","dir":"Articles","previous_headings":"Mac OS X","what":"2. Configure the R environment to make use of the new compiler.","title":"Installation and configuration","text":"Next want use OpenMP R code (maybe exported R function using Rcpp package), make sure R call new compiler, original one. , can mannually set Makeconf file (makefile configuration R) $R_HOME/etc/Makeconf. can check R_HOME address using R.home() R termnial. case, R called compiler still default clang, explicitly replace . Replace configuration lines following (llvm clang installed): Now able use OpenMP facility (multiple chain estimation) ngme2.","code":"R.home() ## [1] \"/Library/Frameworks/R.framework/Resources\" CC = /usr/local/opt/llvm/bin/clang CXX = /usr/local/opt/llvm/bin/clang++ CXX11 = $(CXX) CXX14 = $(CXX) CXX17 = $(CXX) CXX20 = $(CXX) SHLIB_OPENMP_CFLAGS = -fopenmp SHLIB_OPENMP_CXXFLAGS = -fopenmp"},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"description","dir":"Articles","previous_headings":"","what":"Description","title":"Ngme2 random walk model","text":"ngme2, currently support random walk model first-order second order. Remeber ngme2, models form: \\[K \\mathbf{W} = \\boldsymbol{\\epsilon},\\] \\(K\\) operator matrix, \\(\\epsilon\\) random noise (maybe non-Gaussian), \\(\\mathbf{W}\\) random vector want model.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"the-first-order-random-walk-rw1","dir":"Articles","previous_headings":"Description","what":"The first-order random walk (RW(1))","title":"Ngme2 random walk model","text":"first-order random walk constructed assuming independent increments given data \\(\\mathbf{x}\\) (use location, sorted) length \\(n\\): \\(\\epsilon\\) follows NIG distribution: \\[ \\begin{align} \\Delta w_i &= -\\mu + \\mu V_i + \\sigma \\sqrt{V_i} Z , \\; n=1, \\dots, n-1 \\\\ V_i &\\sim IG(\\nu, \\nu (\\Delta x_i)^2), \\\\ Z_i &\\sim N(0, 1), \\end{align} \\] \\(\\epsilon\\) follows normal distribution: \\[ \\begin{align} \\Delta w_i &= \\epsilon_i , \\; n=1, \\dots, n-1 \\\\ \\epsilon_i &\\sim N(0, \\sigma^2 \\Delta x_i), \\\\ \\end{align} \\] \\(\\Delta w_i := w_{+1} - w_{}\\), \\(\\Delta x_i := x_{+1} - x_{}\\). operator matrix \\(K\\) dimension \\((n-1 \\times n)\\) \\[ K =   \\begin{bmatrix}     1 & -1 \\\\       & 1 & -1 \\\\       & & \\ddots & \\ddots \\\\       & & & 1 & -1   \\end{bmatrix}. \\] also provide special case circular random walk, 1st element n-th element connected. circular RW(1) case, operator matrix \\(K\\) dimension \\((n-1 \\times n-1)\\) \\[ K =   \\begin{bmatrix}     1 & -1 \\\\       & \\ddots & \\ddots \\\\       &  & 1 & -1 \\\\        -1 & & & 1   \\end{bmatrix}. \\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"the-second-order-random-walk-rw2","dir":"Articles","previous_headings":"Description","what":"The second-order random walk (RW(2))","title":"Ngme2 random walk model","text":"Similarily, second-order random walk constructed assuming second order difference independent: \\(\\epsilon\\) follows NIG distribution: \\[ \\begin{align} \\Delta^2 w_i &= -\\mu + \\mu V_i + \\sigma \\sqrt{V_i} Z , \\; n=1, \\dots, n-2 \\\\ V_i &\\sim IG(\\nu, \\nu (\\Delta x_i)^2), \\\\ Z_i &\\sim N(0, 1), \\end{align} \\] \\(\\epsilon\\) follows normal distribution: \\[ \\begin{align} \\Delta^2 w_i &= \\epsilon_i , \\; n=1, \\dots, n-2 \\\\ \\epsilon_i &\\sim N(0, \\sigma^2 \\Delta x_i), \\\\ \\end{align} \\] \\(\\Delta^2 w_i := w_{+2} - 2w_{+1} - w_{}\\), \\(\\Delta x_i := x_{+1} - x_{}\\). operator matrix \\(K\\) dimension \\((n-2 \\times n)\\) \\[ K =   \\begin{bmatrix}     1 & -2 & 1 \\\\       & 1 & -2 & 1 \\\\       & & \\ddots & \\ddots & \\ddots \\\\       & & & 1 & -2 & 1   \\end{bmatrix}. \\] circular RW(2) case, operator matrix \\(K\\) dimension \\((n-2 \\times n-2)\\) \\[ K =   \\begin{bmatrix}     1 & -2 & 1 \\\\       & 1 & -2 & 1 \\\\       & & \\ddots & \\ddots & \\ddots \\\\       1 & & & 1 & -2 \\\\       -2 & 1 & & & 1   \\end{bmatrix}. \\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Ngme2 random walk model","text":"Use model_rw f(model = \"rw1\") f(model = \"rw2\") (formula) specify random walk model.","code":"library(ngme2) set.seed(16)  m1 <- model_rw(rexp(5), order = 1, noise = noise_normal()) #> as(<dgTMatrix>, \"dgCMatrix\") is deprecated since Matrix 1.5-0; do as(., \"CsparseMatrix\") instead # check the operator matrix m1$K #> 4 x 5 sparse Matrix of class \"dgCMatrix\" #>                    #> [1,] 1 -1  .  .  . #> [2,] .  1 -1  .  . #> [3,] .  .  1 -1  . #> [4,] .  .  .  1 -1  m2 <- model_rw(rnorm(10), order = 2, circular = TRUE) m2$K #> 8 x 8 sparse Matrix of class \"dgCMatrix\" #>                              #> [1,]  1 -2  1  .  .  .  .  . #> [2,]  .  1 -2  1  .  .  .  . #> [3,]  .  .  1 -2  1  .  .  . #> [4,]  .  .  .  1 -2  1  .  . #> [5,]  .  .  .  .  1 -2  1  . #> [6,]  .  .  .  .  .  1 -2  1 #> [7,]  1  .  .  .  .  .  1 -2 #> [8,] -2  1  .  .  .  .  .  1"},{"path":"https://davidbolin.github.io/ngme2/articles/RW-model.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Ngme2 random walk model","text":"simulation simple, just pass corresponding model simulate function.","code":"simulate(m1) #> [1]  0.2153781 -0.2391502  0.1106447  0.4526920 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1 simulate(m2) #> [1] -0.1506760  0.2985490  0.6680688  0.8926890  1.0347680  1.3575051  1.2383011 #> [8]  1.4077401 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"gaussian-process-in-geostatistics","dir":"Articles","previous_headings":"","what":"Gaussian process in geostatistics","title":"Ngme2 SPDE Matern model","text":"Gaussian process random fields covers different methods representing spatial spatial-temporal dependence structures. Gaussian fields (GF) dominant role spatial statistics especially traditional field geostatistics. common geostatistical model given \\[ Y_i = x(\\mathbf{s}_i) + \\varepsilon_i, \\quad =1,\\ldots,N, \\quad \\varepsilon_i\\sim N(0, \\sigma^2),\\] \\[x(\\mathbf{s}) \\sim GP\\left(\\sum_{k=1}^{n_b} b_k(\\mathbf{s})w_k, c(\\mathbf{s},\\mathbf{s}')\\right),\\] \\(N\\) number spatial observations, \\(GP(m,c)\\) stands Gaussian process mean function \\(m\\) covariance function \\(c\\), \\(n_b\\) number basis functions, \\(\\{b_k(\\cdot)\\}_{k=1}^{n_b}\\) basis functions, \\(w_k\\) weights estimated \\(c(\\cdot,\\cdot)\\) covariance function. popular flexible covariance function random fields \\(\\mathbb{R}^d\\) Matérn covariance function: \\[ c(\\mathbf{s}, \\mathbf{s}') = \\frac{\\sigma^2}{\\Gamma(\\nu)2^{\\nu-1}}(\\kappa \\|\\mathbf{s}-\\mathbf{s}'\\|)^\\nu K_\\nu(\\kappa\\|\\mathbf{s}-\\mathbf{s}'\\|), \\] \\(\\Gamma(\\cdot)\\) Gamma function, \\(K_\\nu(\\cdot)\\) modified Bessel function second kind, \\(\\nu>0\\) controls correlation range \\(\\sigma^2\\) variance. Finally, \\(\\nu>0\\) determines smoothness field. Usually, model parameters estimated via maximum likelihood estimation. main drawback approach computational time needed order perform statistical inference usually scales \\(\\mathcal{O}(N^3)\\).","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"the-spde-approach-with-gaussian-noise","dir":"Articles","previous_headings":"","what":"The SPDE approach with Gaussian noise","title":"Ngme2 SPDE Matern model","text":"well-known (Whittle, 1963) Gaussian process \\(u(\\mathbf{s})\\) Matérn covariance function solves stochastic partial differential equation (SPDE) \\[\\begin{equation}\\label{spde} (\\kappa^2 -\\Delta)^\\beta u = \\mathcal{W}\\quad \\hbox{} \\mathcal{D}, \\end{equation}\\] \\(\\Delta = \\sum_{=1}^d \\frac{\\partial^2}{\\partial_{x_i^2}}\\) Laplacian operator, \\(\\mathcal{W}\\) Gaussian spatial white noise \\(\\mathcal{D}=\\mathbb{R}^d\\), \\(4\\beta = 2\\nu + d\\). Inspired relation Gaussian processes Matérn covariance functions solutions SPDE, Lindgren et al. (2011) constructed computationally efficient Gaussian Markov random field approximations \\(u(\\mathbf{s})\\), domain \\(\\mathcal{D}\\subsetneq \\mathbb{R}^d\\) bounded \\(2\\beta\\\\mathbb{N}\\). approximate solutions SPDE obtained finite element discretization.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"finite-element-approximation","dir":"Articles","previous_headings":"The SPDE approach with Gaussian noise","what":"Finite element approximation","title":"Ngme2 SPDE Matern model","text":"now provide brief description finite element method used. make description simpler consider nonfractional SPDE given \\[(\\kappa^2 - \\Delta) u(\\mathbf{s}) = \\mathcal{W}(\\mathbf{s}),\\] bounded domain \\(\\mathcal{D}\\) \\(\\mathbb{R}^d\\). Laplacian operator augmented boundary conditions. Usually one considers Dirichlet, process zero boundary \\(\\mathcal{D}\\), Neumann, directional derivarives process normal directions zero boundary \\(\\mathcal{D}\\). equation interpreted following weak sense: every function \\(\\psi(\\mathbf{s})\\) suitable space test functions, following identity holds \\[\\langle \\psi, (\\kappa^2-\\Delta)u\\rangle_{\\mathcal{D}} \\stackrel{d}{=} \\langle \\psi, \\mathcal{W}\\rangle_{\\mathcal{D}},\\] \\(\\stackrel{d}{=}\\) means equality distribution \\(\\langle\\cdot,\\cdot\\rangle_{\\mathcal{D}}\\) standard inner product \\(L_2(\\mathcal{D})\\), \\(\\langle f,g\\rangle_{\\mathcal{D}} = \\int_\\mathcal{D} f(\\mathbf{s})g(\\mathbf{s}) d\\mathbf{s}.\\) finite element method (FEM) consists considering finite dimensional space test functions \\(V_n\\). Galerkin method, consider \\(V_n = {\\rm span}\\{\\varphi_1,\\ldots,\\varphi_n\\}\\), \\(\\varphi_i(\\mathbf{s}), =1,\\ldots, n\\) piecewise linear basis functions obtained triangulation \\(\\mathcal{D}\\). , write approximate solution \\(u\\) \\(u_n\\), \\(u_n\\) written terms basis functions \\[u_n(\\mathbf{s}) = \\sum_{=1}^n w_i \\varphi_i(\\mathbf{s}).\\] thus obtain system linear equations \\[\\left\\langle \\varphi_j, (\\kappa^2 - \\Delta)\\left(\\sum_{=1}^n w_i\\varphi_i\\right)\\right\\rangle_{\\mathcal{D}} \\stackrel{d}{=} \\langle \\varphi_j, \\mathcal{W}\\rangle_{\\mathcal{D}},\\quad\\hbox{} j=1,\\ldots,n.\\] right hand side can shown \\[(\\langle \\varphi_1, \\mathcal{W}\\rangle_{\\mathcal{D}}, \\ldots, \\langle \\varphi_n, \\mathcal{W}\\rangle_{\\mathcal{D}}) \\sim N(0, \\mathbf{C}),\\] \\(\\mathbf{C}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{C}_{,j} = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s})\\varphi_j(\\mathbf{s}) d\\mathbf{s}.\\] matrix \\(\\mathbf{C}\\) known mass matrix FEM theory. using Green’s first identity, left hand side \\[ \\begin{array}{ccl} \\left\\langle \\varphi_j, (\\kappa^2 - \\Delta)\\left(\\sum_{=1}^n w_i\\varphi_i\\right)\\right\\rangle_{\\mathcal{D}} &=& \\sum_{=1}^n \\langle \\varphi_j, (\\kappa^2 - \\Delta)w_i\\varphi_i\\rangle_{\\mathcal{D}}\\\\ &=& \\sum_{=1}^n (\\kappa^2 \\langle \\varphi_j, \\varphi_i\\rangle_{\\mathcal{D}} + \\langle \\nabla \\varphi_j, \\nabla \\varphi_i\\rangle_{\\mathcal{D}}) w_i, \\quad j=1,\\ldots, n, \\end{array} \\] boundary terms vanish due boundary conditions (Dirichlet Neumann). can rewrite last term matrix form \\[(\\kappa^2 \\mathbf{C} + \\mathbf{G})\\mathbf{w},\\] \\(\\mathbf{w} = (w_1,\\ldots,w_n)\\) \\(\\mathbf{G}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{G}_{,j} = \\int_{\\mathcal{D}} \\nabla \\varphi_i(\\mathbf{s})\\nabla\\varphi_j(\\mathbf{s})d\\mathbf{s}.\\] matrix \\(\\mathbf{G}\\) known FEM theory stiffness matrix. Putting everything together, \\[(\\kappa^2 \\mathbf{C} + \\mathbf{G}) \\mathbf{w} \\sim N(0,\\mathbf{C}).\\] Therefore, \\(\\mathbf{w}\\) centered Gaussian variable precision matrix given \\[\\mathbf{Q} = (\\kappa^2 \\mathbf{C}+\\mathbf{G})^\\top \\mathbf{C}^{-1}(\\kappa^2 \\mathbf{C}+\\mathbf{G}).\\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"computational-advantages-of-the-spde-approach","dir":"Articles","previous_headings":"The SPDE approach with Gaussian noise","what":"Computational advantages of the SPDE approach","title":"Ngme2 SPDE Matern model","text":"spatial problems, computational cost usually scales \\(\\mathcal{O}(n^{3/2})\\), \\(n\\) number basis functions. compared \\(\\mathcal{O}(N^3)\\) Gaussian random field approach. implies accurate approximations drastically reduces computational cost sampling inference.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"the-spde-approach-with-non-gaussian-noise","dir":"Articles","previous_headings":"","what":"The SPDE approach with non-Gaussian noise","title":"Ngme2 SPDE Matern model","text":"describe generalize approach non-Gaussian noise. goal now describe SPDE approach noise non-Gaussian. motivation handling non-Gaussian noise comes fact many features handled Gaussian noise. reasons : Skewness; Heavier tails; Jumps sample paths; Asymmetries sample paths.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"non-gaussian-matérn-fields","dir":"Articles","previous_headings":"The SPDE approach with non-Gaussian noise","what":"Non-Gaussian Matérn fields","title":"Ngme2 SPDE Matern model","text":"idea replace Gaussian white noise \\(\\mathcal{W}\\) SPDE non-Gaussian white noise \\(\\dot{\\mathcal{M}}\\): \\[(\\kappa^2 - \\Delta)^\\beta u = \\dot{\\mathcal{M}}.\\] solution \\(u\\) Matérn covariance function, marginal distributions non-Gaussian. consider setup. precisely, consider \\(V_n = {\\rm span}\\{\\varphi_1,\\ldots,\\varphi_n\\}\\), \\(\\varphi_i(\\mathbf{s}), =1,\\ldots, n\\) piecewise linear basis functions obtained triangulation \\(\\mathcal{D}\\) approximate solution \\(u\\) \\(u_n\\), \\(u_n\\) written terms basis functions \\[u_n(\\mathbf{s}) = \\sum_{=1}^n w_i \\varphi_i(\\mathbf{s}).\\] right-hand side obtain random vector \\[\\mathbf{f} = (\\dot{\\mathcal{M}}(\\varphi_1),\\ldots, \\dot{\\mathcal{M}}(\\varphi_n)),\\] functional \\(\\dot{\\mathcal{M}}\\) given \\[\\dot{\\mathcal{M}}(\\varphi_j) = \\int_{\\mathcal{D}} \\varphi_j(\\mathbf{s}) d\\mathcal{M}(\\mathbf{s}).\\] considering \\(\\mathcal{M}\\) type-G Lévy process, obtain \\(\\mathbf{f}\\) joint distribution easy handle. say Lévy process type G increments can represented location-scale mixtures: \\[\\gamma + \\mu V + \\sigma \\sqrt{V}Z,\\] \\(\\gamma, \\mu\\) parameters, \\(Z\\sim N(0,1)\\) independent \\(V\\), \\(V\\) positive infinitely divisible random variable. Therefore, given vector \\(\\mathbf{V} = (V_1,\\ldots,V_n)\\) independent stochastic variances (case, positive infinitely divisible random variables), obtain \\[\\mathbf{f}|\\mathbf{V} \\sim N(\\gamma + \\mu\\mathbf{V}, \\sigma^2{\\rm diag}(\\mathbf{V})).\\] , consider, instance, non-fractional non-Gaussian SPDE \\[(\\kappa^2 - \\Delta) u = \\dot{\\mathcal{M}},\\] obtain FEM weights \\(\\mathbf{w} = (w_1,\\ldots,w_n)\\) satisfy \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(\\gamma+\\mu\\mathbf{V}), \\sigma^2\\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1}),\\] \\(\\mathbf{K} = \\kappa^2\\mathbf{C}+\\mathbf{G}\\) discretization differential operator.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"the-nig-model","dir":"Articles","previous_headings":"The SPDE approach with non-Gaussian noise","what":"The NIG model","title":"Ngme2 SPDE Matern model","text":"delve details now considering, example, NIG model. First, say random variable \\(V\\) follows inverse Gaussian distribution parameters \\(\\eta_1\\) \\(\\eta_2\\), denoted \\(V\\sim IG(\\eta_1,\\eta_2)\\) probability density function (pdf) given \\[\\pi(v) = \\frac{\\sqrt{\\eta_2}}{\\sqrt{2\\pi v^3}} \\exp\\left\\{-\\frac{\\eta_1}{2}v - \\frac{\\eta_2}{2v} + \\sqrt{\\eta_1\\eta_2}\\right\\},\\quad \\eta_1,\\eta_2>0.\\] can generate samples inverse Gaussian distributions parameters \\(\\eta_1\\) \\(\\eta_2\\) generating samples generalized inverse Gaussian distribution parameters \\(p=-1/2\\), \\(=\\eta_1\\) \\(b=\\eta_2\\). can use rGIG function generate samples generalized inverse Gaussian distribution. \\(V\\sim IG(\\eta_1,\\eta_2)\\), \\(X = \\gamma +\\mu V + \\sigma \\sqrt{V}Z\\), \\(Z\\sim N(0,1)\\), independent \\(V\\), \\(X\\) follows normal inverse Gaussian (NIG) distribution pdf \\[\\pi(x) = \\frac{e^{\\sqrt{\\eta_1\\eta_2}+\\mu(x-\\gamma)/\\sigma^2}\\sqrt{\\eta_2\\mu^2/\\sigma^2+\\eta_1\\eta_2}}{\\pi\\sqrt{\\eta_2\\sigma^2+(x-\\gamma)^2}} K_1\\left(\\sqrt{(\\eta_2\\sigma^2+(x-\\gamma)^2)(\\mu^2/\\sigma^4+\\eta_1/\\sigma^2)}\\right),\\] \\(K_1\\) modified Bessel function third kind. form, NIG density overparameterized, therefore set \\(\\eta_1=\\eta_2=\\eta\\), results \\(E(V)=1\\). Thus, one parameters, \\(\\mu, \\gamma\\) \\(\\eta\\). NIG model thus assumes stochastic variance \\(V_i\\) follows inverse Gaussian parameters \\(\\eta\\) \\(\\eta h_i^2\\), \\(h_i = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s}) d\\mathbf{s}.\\)","code":"library(INLA) #> Loading required package: Matrix #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_22.12.14 built 2022-12-13 20:50:21 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() library(ngme2) #>  #> Attaching package: 'ngme2' #> The following object is masked from 'package:INLA': #>  #>     f library(ggplot2) library(plyr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:plyr': #>  #>     arrange, count, desc, failwith, id, mutate, rename, summarise, #>     summarize #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(viridis) #> Loading required package: viridisLite"},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"specification","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Specification","title":"Ngme2 SPDE Matern model","text":"Use model_matern specify SPDE Matérn model, see ?model_matern details. Consider following examples (1d 2d cases):  Specifying 2d Matérn model also simple:","code":"# 1d example loc <- c(1.1, 2.2, 3.5, 4.7) mesh_1d <- inla.mesh.1d(1:10) m1 <- model_matern(loc = loc, mesh = mesh_1d) #> as(<dgTMatrix>, \"dgCMatrix\") is deprecated since Matrix 1.5-0; do as(., \"CsparseMatrix\") instead # 2d example data(argo_float) head(argo_float) #>       lat     lon           sal       temp #> 1 -64.078 175.821 -0.0699508100  0.4100305 #> 2 -63.760 162.917 -0.0320931260 -0.2588680 #> 3 -63.732 163.294 -0.0008063143 -0.1151362 #> 4 -63.700 162.568 -0.0209534220 -0.2378965 #> 5 -63.269 169.623  0.0409914840  0.3375048 #> 6 -63.113 171.526  0.0269408910  0.2145556 # take longitude and latitude to build the mesh  max.edge    <- 1 bound.outer <- 5 loc_2d <- unique(cbind(argo_float$lon, argo_float$lat)) # nrow(loc) == nrow(dat) no replicates argo_mesh <- inla.mesh.2d(loc = loc_2d,                     # the inner edge and outer edge                     max.edge = c(1,5),                     cutoff = 0.3,                     # offset extension distance inner and outer extenstion                     offset = c(max.edge, bound.outer) ) plot(argo_mesh) argo_spde <- model_matern(   loc = loc_2d,   mesh = argo_mesh )"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"simulation","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Simulation","title":"Ngme2 SPDE Matern model","text":"simulation easy, simply provide model, ’s !","code":"simulate(m1) #>  [1] -0.495982764 -0.438953760 -0.940582512 -0.751046563  0.172417530 #>  [6] -0.111404328  0.592070205  0.417702208 -0.005324487 -0.379873020 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1 simulate(argo_spde)[1:20] #>  [1] -0.36236605  0.06950848 -0.58964281 -0.07958500 -0.49119070  0.05329682 #>  [7] -0.10526759  0.13719711 -0.20761969  0.09995411 -0.14168905  0.04403162 #> [13]  0.11758504  0.06306374 -0.11309436 -0.12882337  0.05905417 -0.18415878 #> [19]  0.21087458 -0.22829800"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"estimation","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Estimation","title":"Ngme2 SPDE Matern model","text":"Let’s use previous argo_float spatial (2d) example. First explore data look like:   Next, specfiy model formula, fit model.","code":"# tempearture ggplot(data=argo_float) +   geom_point(aes(     x = loc_2d[, 1], y = loc_2d[, 2],     colour = temp   ), size = 2, alpha = 1) +   scale_color_gradientn(colours = viridis(100)) # salinity ggplot(data=argo_float) +   geom_point(aes(     x = loc_2d[, 1], y = loc_2d[, 2],     colour = sal   ), size = 2, alpha = 1) +   scale_color_gradientn(colours = viridis(100)) formula <- temp ~ sal + f(model = argo_spde, noise = noise_normal(), debug = TRUE)  out <- ngme(   formula = formula,   family = \"nig\",   data = argo_float,   seed = 7,   control = ngme_control(     estimation = TRUE,     n_parallel_chain = 4,     iterations = 100,     print_check_info = TRUE   ),   debug = FALSE ) #> Starting estimation...  #> Estimation done! out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -0.0132,  7.1249 #>  #> Measurement noise:  #>   Noise type - nig #>   Noise parameters:  #>       mu = -0.363 #>       sigma = 1.16 #>       nu = 0.102 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: matern #>   Model parameters:  #>       kappa = 0.825 #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.825"},{"path":"https://davidbolin.github.io/ngme2/articles/SPDE-model.html","id":"prediction","dir":"Articles","previous_headings":"Using SPDE Matérn model in ngme2","what":"Prediction","title":"Ngme2 SPDE Matern model","text":"prediction ngme simple, simply put value preidcted location NA. ngme function firstly estimate model using known data. estimation, estimaed value samples given gibbs sampler used give linear predictor. See vignette Prediction estimation details.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"vignette provide brief introduction ngme2 package. ngme2 updated version ngme (https://github.com/davidbolin/ngme), package estimating latent non-Gaussian models. follows 3-layer structure design (general block model, latent process models, noises) specifying whole statistical model. latent process defines different operator structure, block model collects together fixed effects measurement noise.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"features","dir":"Articles","previous_headings":"Introduction","what":"1 Features","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"Support spatial models like Matern model non-Gaussian noise. Support models temporal data like AR1 random walk order 1 2. Support replicates locations. Support prediction unknown locations. Comparing previous version, now supports multiple stochastic processes latent model.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"model-framework","dir":"Articles","previous_headings":"Introduction","what":"2 Model Framework","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"package ngme2 provides methods mixed effect models single response variable case multivariate response case (yet). 1.single response case, following form: \\[ \\begin{aligned} Y = {\\bf X}^{\\top} {\\bf \\beta} + \\sum_j {\\bf }_j W_j({\\bf t}) + \\epsilon. \\end{aligned} \\] , \\(Y\\) response variable, \\({\\bf X}\\) matrix fixed effects explanatory variables, \\({\\bf \\beta}\\) matrix fixed effects coefficients, \\({\\bf }_j\\) observation matrix process, \\(W_j(t_j)\\) specified stochastic process, \\(\\epsilon\\) measurement error. , process \\(W\\) follows \\({\\bf K} W = z\\), \\(z\\) either Gaussian non-Gaussian noise. \\({\\bf K}\\) operator matrix. simple template using core function ngme model single response: , function f modeling stochastic process W Gaussian non-Gaussian noise, discuss later. noise stands measurement noise distribution. case, model Gaussian likelihood. multivariate response case, following form: another template using core function ngme model bivariate response:","code":"ngme(   formula=Y ~ x1 + x2 + f(index, model=\"ar\", noise=\"nig\"),   data=data.frame(Y=Y, x1=x1, x2=x2, index=index),   noise = noise_normal() ) ngme(   formula=Y1 | Y2 ~ x1 + x2 + f(index, model=\"ar\", noise=\"nig\") | f(time, model=\"matern\"),   data=data.frame(Y=Y, x1=x1, x2=x2, index=index, time=time),   family=\"normal\" )"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"non-gaussian-model","dir":"Articles","previous_headings":"Introduction","what":"3 Non-Gaussian Model","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"assume non-Gaussian process type-G Lévy process, whose increments can represented location-scale mixtures: \\[\\gamma + \\mu V + \\sigma \\sqrt{V}Z,\\] \\(\\gamma, \\mu, \\sigma\\) parameters, \\(Z\\sim N(0,1)\\) independent \\(V\\), \\(V\\) positive infinitely divisible random variable. results following form, \\(K\\) operator part: \\[ KW|V \\sim N(\\gamma + \\mu V, \\sigma^2 \\, diag(V)), \\] also, \\(\\mu\\) \\(\\sigma\\) can non-stationary. ngme2, focus mainly normal inverse Gaussian (NIG) model. See ?nig details.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"parameter-estimation","dir":"Articles","previous_headings":"Introduction","what":"4 Parameter Estimation","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"Ngme2 maximum likelihood estimation preconditioned stochastic gradient descent. Multiple chains run parallel better convergence checks.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"specify-noise-with-ngme_noise-object","dir":"Articles","previous_headings":"Ngme Model Structure","what":"Specify noise with ngme_noise object","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"ngme_noise object fundamental structure ngme2. object used specify driving noise stochastic process measurement noise. now support two noises, one normal noise, NIG noise. R class ngme_noise following interface: 3rd example non-stationary NIG noise, \\(\\mu = \\bf B_{\\mu} \\bf \\theta_{\\mu}\\), \\(\\sigma = \\exp(\\bf B_{\\sigma} \\bf \\theta_{\\sigma})\\). construct following noise structure: \\[   - \\mathbf{\\mu} + \\mathbf{\\mu} V + \\mathbf{\\sigma} \\sqrt{V} Z \\] \\(\\mu = \\bf B_{\\mu} \\bf \\theta_{\\mu}\\), \\(\\sigma = \\exp(\\bf B_{\\sigma} \\bf \\theta_{\\sigma})\\). case, can recover gaussian noise setting type=“normal ignoring theta_mu theta_V. can simply use helper function noise_normal(sd=1)","code":"library(ngme2)  noise_normal(sigma = 1)                 # normal noise #> Noise type - normal #> Noise parameters:  #>     sigma = 1 noise_nig(mu = 1, sigma = 2, nu = 1) # nig noise #> Noise type - nig #> Noise parameters:  #>     mu = 1 #>     sigma = 2 #>     nu = 1 noise_nig(            # non-stationary nig noise   B_mu=matrix(c(1:10), ncol=2),   theta_mu = c(1, 2),   B_sigma=matrix(c(1:10), ncol=2),   theta_sigma = c(1,2),   nu = 1) #> Noise type - nig #> Noise parameters:  #>     theta_mu = 1, 2 #>     theta_sigma = 1, 2 #>     nu = 1 ngme_noise(   type,           # the type of noise   theta_mu,       # mu parameter   theta_sigma,    # sigma parameter   theta_V,        # nu parameter   B_mu,           # basis matrix for non-stationary mu   B_sigma         # basis matrix for non-stationary sigma )"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"specify-stochastic-process-with-f-function","dir":"Articles","previous_headings":"Ngme Model Structure","what":"Specify stochastic process with f function","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"middle layer stochastic process, R interface, represented f function. process can specified different noise structure. See ?ngme_model_types() details. examples using f function specify ngme_model: One useful model SPDE model Gaussian non-Gaussian noise, see vignette details.","code":"ngme2::f(1:10, model = \"ar1\",   noise = noise_nig(), theta_K = 0.5) #> as(<dgTMatrix>, \"dgCMatrix\") is deprecated since Matrix 1.5-0; do as(., \"CsparseMatrix\") instead #> Ngme model: ar1 #> Model parameters:  #>     alpha = 0.5 #>  #> Noise type - nig #> Noise parameters:  #>     mu = 0 #>     sigma = 1 #>     nu = 1"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"specifying-latent-models-with-formula-in-ngme","dir":"Articles","previous_headings":"Ngme Model Structure","what":"Specifying latent models with formula in ngme","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"latent model can specified additively formula argument ngme function together fixed effects. use R formula specify latent model. can specify model using f within formula. example, following formula corresponds model \\[ Y = \\beta_0 + \\beta_1 x_1 + W_1(x_2) + W_2(x_3) + \\epsilon, \\] \\(W_1\\) AR(1) process, \\(W_2\\) random walk 1 process. \\(x_2\\) random effects.. . default, intercept. distribution measurement error \\(\\epsilon\\) given ngme function. entire model can fitted, along specification distribution measurement error ngme function: gives ngme object, three parts: Fixed effects (intercept x1) Measurement noise (normal noise) Latent models (contains 2 models, ar1 rw1) can turn estimation = TRUE start estimating model.","code":"formula <- Y ~ x1 + f(     x2,     model = \"ar1\",     noise = noise_nig(),     theta_K = 0.5   ) + f(     model = model_rw(1:5, order=1, circular = TRUE),     noise = noise_normal()   ) ngme(   formula = formula,   family = noise_normal(sigma = 0.5),   data = data.frame(Y = 1:5, x1 = 2:6, x2 = 3:7),   control = ngme_control(     estimation = FALSE   ) ) #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -1,  1 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.5 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.5 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0 #>       sigma = 1 #>       nu = 1 #> [[2]] #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter needed. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"a-simple-example---ar1-process-with-nig-noise","dir":"Articles","previous_headings":"","what":"A simple example - AR1 process with nig noise","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"Now let’s see example AR1 process nig noise. process defined \\[ W_i = \\alpha W_{-1} + \\epsilon_i, \\] , \\(\\epsilon_1, ..,\\epsilon_n\\) iid NIG noise. , easy verify \\[ K{\\bf W} = \\boldsymbol\\epsilon,\\] \\[ K =   \\begin{bmatrix}     \\alpha \\\\     -1 &  \\alpha \\\\     & \\ddots & \\ddots \\\\     & & -1 &  \\alpha   \\end{bmatrix} \\] Now let’s fit model using ngme. can use ngme_control modify control variables ngme. See ?ngme_control optioins. Next can read result directly object. can see, model converges 350 iterations. estimation results close real parameter. can also use traceplot function see estimation traceplot. Parameters AR1 model can also density comparison estimated noise true NIG noise:","code":"n_obs <- 500 sigma_eps <- 0.5 alpha <- 0.5 mu = 2; delta = -mu sigma <- 3 nu <- 1  # First we generate V. V_i follows inverse Gaussian distribution trueV <- ngme2::rig(n_obs, nu, nu, seed = 10)  # Then generate the nig noise noise <- delta + mu*trueV + sigma * sqrt(trueV) * rnorm(n_obs) trueW <- Reduce(function(x,y){y + alpha*x}, noise, accumulate = T) Y = trueW + rnorm(n_obs, mean=0, sd=sigma_eps)  # Add some fixed effects x1 = runif(n_obs) x2 = rexp(n_obs) beta <- c(-3, -1, 2) X <- (model.matrix(Y ~ x1 + x2))  # design matrix Y = as.numeric(Y + X %*% beta) # # Fit the model with the AR1 model ngme_out <- ngme(   Y ~ x1 + x2 + f(     1:n_obs,     model = \"ar1\",     noise = noise_nig(),     theta_K = 0.9  # starting point for the alpha (parameter of K)   ),   data=data.frame(x1=x1, x2=x2, Y=Y),   control = ngme_control(     burnin = 100,     iterations = 1000,     std_lim = 0.4,     gibbs_sample = 5,     n_parallel_chain = 4,     stop_points = 10,     print_check_info = FALSE   ),   seed = 3 ) #> Starting estimation...  #> Estimation done! ngme_out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -2.92, -1.43,  1.99 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.789 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.564 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 1.86 #>       sigma = 2.82 #>       nu = 0.829 library(ggplot2) library(grid) library(gridExtra) pl <- lapply(c(\"alpha\", \"mu\", \"sigma\", \"nu\"), function(.x)   traceplot(ngme_out, param = .x, f_index = 1)); marrangeGrob(pl, nrow=2, ncol=2) plot(   ngme_out$latents[[1]]$noise,   noise_nig(mu = mu, sigma = sigma, nu = nu) )"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"paraná-dataset","dir":"Articles","previous_headings":"","what":"Paraná dataset","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"rainfall data Paraná (Brazil) collected National Water Agency Brazil (Agencia Nacional de Águas, ANA, Portuguese). ANA collects data many locations Brazil, data freely available ANA website (http://www3.ana.gov.br/portal/ANA). briefly illustrate command use, result estimation. Plot data: Mean rainfall Octobor 2012 Paraná        Parameter estimation results: Estimations model","code":"library(INLA) #> Loading required package: Matrix #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_22.12.14 built 2022-12-13 20:50:21 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() #>  #> Attaching package: 'INLA' #> The following object is masked from 'package:ngme2': #>  #>     f library(splancs) #>  #> Spatial Point Pattern Analysis Code in S-Plus #>   #>  Version 2 - Spatial and Space-Time analysis library(lattice) library(ggplot2) library(grid) library(gridExtra) library(viridis) #> Loading required package: viridisLite data(PRprec) data(PRborder)  # Create INLA mesh coords <- as.matrix(PRprec[, 1:2]) prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2)  # monthly mean at each location Y <- rowMeans(PRprec[, 12 + 1:31]) # 2 + Octobor  ind <- !is.na(Y) # non-NA index Y <- Y_mean <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) seaDist <- apply(spDists(coords, PRborder[1034:1078, ],   longlat = TRUE ), 1, min) # leave 0.1 Y as prediction area # n <- length(Y) # ind_pred <- sample(1:n, size = 0.1 * n) # Y_pred <- Y[ind_pred] # Y[ind_pred] <- NA  matern_spde <- model_matern(   loc = coords,   mesh = prmesh )  out <- ngme(   formula = Y ~ 1 +     f(inla.group(seaDist), model = \"rw1\", circular=T, noise = noise_normal()) +     f(model = matern_spde, noise = noise_normal()),   data = list(     Y = Y   ),   family = noise_nig(),   control = ngme_control(     estimation = T,     iterations = 1000,     n_slope_check = 4,     stop_points = 10,     std_lim = 0.1,     n_parallel_chain = 4,     print_check_info = FALSE   ),   seed = 16 ) #> Starting estimation...  #> Estimation done! out #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = 8.81 #>  #> Measurement noise:  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0.369 #>       sigma = 2.04 #>       nu = 1.64 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter needed. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.23 #> [[2]] #>   Ngme model: matern #>   Model parameters:  #>       kappa = 4.17 #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 9.56  # traceplots  ## fixed effects traceplot(out, f_index = 0, param = \"beta\") ## measurement noise traceplot(out, f_index = 0, param = \"mu\") traceplot(out, f_index = 0, param = \"sigma\") traceplot(out, f_index = 0, param = \"nu\") ## rw traceplot(out, f_index = 1, param = \"sigma\") ## spde model traceplot(out, f_index = 2, param = \"kappa\") traceplot(out, f_index = 2, param = \"sigma\")"},{"path":"https://davidbolin.github.io/ngme2/articles/ngme2.html","id":"prediction","dir":"Articles","previous_headings":"Paraná dataset","what":"Prediction","title":"Ngme2 - A new Flexible R Package for Latent non-Gaussian Models","text":"","code":"nxy <- c(150, 100) projgrid <- rSPDE::rspde.mesh.projector(prmesh,   xlim = range(PRborder[, 1]),   ylim = range(PRborder[, 2]), dims = nxy )  xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2]))  coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") seaDist.prd <- apply(spDists(coord.prd,   PRborder[1034:1078, ],   longlat = TRUE ), 1, min)  # construct data n_prd <- nrow(coord.prd) Y2 <- c(Y, rep(NA, n_prd)) seaDist2 <- c(seaDist, seaDist.prd)  matern_spde <- model_matern(   loc = rbind(coords, coord.prd),   mesh = prmesh,   index_NA = is.na(Y2) )  # use previous estimation results by setting start=out out2 <- ngme(   formula = Y ~ 1 +     f(inla.group(seaDist), model = \"rw1\", noise = noise_normal()) +     # f(model = matern_spde, noise = noise_nig()) +     f(model = matern_spde, noise = noise_normal()),   data = list(     Y = Y2,     seaDist = seaDist2   ),   family = noise_nig(),   control = ngme_control(     estimation = F,     iterations = 1000,     n_slope_check = 4,     stop_points = 10,     std_lim = 0.1,     n_parallel_chain = 8,     print_check_info = TRUE   ),   seed = 416,   start = out ) out2 #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = 8.81 #>  #> Measurement noise:  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0.369 #>       sigma = 2.04 #>       nu = 1.64 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter needed. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 0.23 #> [[2]] #>   Ngme model: matern #>   Model parameters:  #>       kappa = 4.17 #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 9.56  # Now we plot prediction lp <- attr(out2, \"prediction\")$lp ggplot() +   geom_point(aes(     x = coord.prd[, 1], y = coord.prd[, 2],     colour = lp[is.na(Y2)]   ), size = 2, alpha = 1) +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y_mean   ), size = 2, alpha = 1) +   scale_color_gradientn(colours = viridis(100)) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\")"},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Model prediction and estimation","text":"vignette, provide breif introduction estimation methods ngme2. First, give description model. popular flexible covariance function random fields \\(\\mathbb{R}^d\\) Matérn covariance function: \\[c(\\mathbf{s}, \\mathbf{s}') = \\frac{\\sigma^2}{\\Gamma(\\nu)2^{\\nu-1}}(\\kappa \\|\\mathbf{s}-\\mathbf{s}'\\|)^\\nu K_\\nu(\\kappa\\|\\mathbf{s}-\\mathbf{s}'\\|),\\] \\(\\Gamma(\\cdot)\\) Gamma function, \\(K_\\nu(\\cdot)\\) modified Bessel function second kind, \\(\\nu>0\\) controls correlation range \\(\\sigma^2\\) variance. Finally, \\(\\nu>0\\) determines smoothness field. well-known (Whittle, 1963) Gaussian process \\(u(\\mathbf{s})\\) Matérn covariance function solves stochastic partial differential equation (SPDE) \\[\\begin{equation}\\label{spde} (\\kappa^2 -\\Delta)^\\beta u = \\mathcal{W}\\quad \\hbox{} \\mathcal{D}, \\end{equation}\\] \\(\\Delta = \\sum_{=1}^d \\frac{\\partial^2}{\\partial_{x_i^2}}\\) Laplacian operator, \\(\\mathcal{W}\\) Gaussian spatial white noise \\(\\mathcal{D}=\\mathbb{R}^d\\), \\(4\\beta = 2\\nu + d\\). Inspired relation Gaussian processes Matérn covariance functions solutions SPDE, Lindgren et al. (2011) constructed computationally efficient Gaussian Markov random field approximations \\(u(\\mathbf{s})\\), domain \\(\\mathcal{D}\\subsetneq \\mathbb{R}^d\\) bounded \\(2\\beta\\\\mathbb{N}\\). order model departures Gaussian behaviour consider following extension due Bolin (2014): \\[(\\kappa^2 - \\Delta)^\\beta X(\\mathbf{s}) = \\dot{\\mathcal{M}}(\\mathbf{s}),\\quad \\mathbf{s}\\\\mathcal{D},\\] \\(\\dot{\\mathcal{M}}\\) non-Gaussian white-noise. specifically, assume \\(\\mathcal{M}\\) type-G Lévy process. say Lévy process type G increments can represented location-scale mixtures: \\[\\gamma + \\mu V + \\sigma \\sqrt{V}Z,\\] \\(\\gamma, \\mu\\) \\(\\sigma\\) parameters, \\(Z\\sim N(0,1)\\) independent \\(V\\), \\(V\\) positive infinitely divisible random variable. SPDE assume \\(\\gamma = -\\mu E(V)\\) \\(\\sigma = 1\\). Finally, assume observations \\(Y_1,\\ldots,Y_N\\), observed locations \\(\\mathbf{s}_1,\\ldots,\\mathbf{s}_N\\\\mathcal{D}\\), \\(Y_1,\\ldots, Y_N\\) satisfy \\[ Y_i = X(\\mathbf{s}_i) + \\varepsilon_i, \\quad =1,\\ldots,N,\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_N\\) ..d. following \\(\\varepsilon_i\\sim N(0, \\sigma_\\varepsilon^2)\\).","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"finite-element-approximations","dir":"Articles","previous_headings":"","what":"Finite element approximations","title":"Model prediction and estimation","text":"vignette assume basic understanding Galerkin’s finite element method. details refer reader Sampling processes given solutions SPDEs driven non-Gaussian noise vignette. Recall assuming \\(\\beta=1\\), SPDE given \\[(\\kappa^2 - \\Delta) X(\\mathbf{s}) = \\dot{\\mathcal{M}}(\\mathbf{s}),\\quad \\mathbf{s}\\\\mathcal{D}.\\] Let us introduce notation regarding finite element method (FEM). Let \\(V_n = {\\rm span}\\{\\varphi_1,\\ldots,\\varphi_n\\}\\), \\(\\varphi_i(\\mathbf{s}), =1,\\ldots, n\\) piecewise linear basis functions obtained triangulation \\(\\mathcal{D}\\). approximate solution \\(X_n\\) \\(X\\) written terms finite element basis functions \\[X_n(\\mathbf{s}) = \\sum_{=1}^n w_i \\varphi_i(\\mathbf{s}),\\] \\(w_i\\) FEM weights. Let, also, \\[\\mathbf{f} = (\\dot{\\mathcal{M}}(\\varphi_1),\\ldots, \\dot{\\mathcal{M}}(\\varphi_n)),\\] Therefore, given vector \\(\\mathbf{V} = (V_1,\\ldots,V_n)\\) independent stochastic variances (case, positive infinitely divisible random variables), obtain \\[\\mathbf{f}|\\mathbf{V} \\sim N(\\gamma + \\mu\\mathbf{V}, \\sigma^2{\\rm diag}(\\mathbf{V})).\\] Let us now introduce useful notation. Let \\(\\mathbf{C}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{C}_{,j} = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s})\\varphi_j(\\mathbf{s}) d\\mathbf{s}.\\] matrix \\(\\mathbf{C}\\) known mass matrix FEM theory. Let, also, \\(\\mathbf{G}\\) \\(n\\times n\\) matrix \\((,j)\\)th entry given \\[\\mathbf{G}_{,j} = \\int_{\\mathcal{D}} \\nabla \\varphi_i(\\mathbf{s})\\nabla\\varphi_j(\\mathbf{s})d\\mathbf{s}.\\] matrix \\(\\mathbf{G}\\) known FEM theory stiffness matrix. Finally, let \\[h_i = \\int_{\\mathcal{D}} \\varphi_i(\\mathbf{s}) d\\mathbf{s}, \\quad =1,\\ldots,n.\\] Recall \\(\\gamma = -\\mu E(V)\\). \\(\\mathbf{V}\\) chosen \\(E[V_i] = h_i\\) ensure parameter identifiability. , FEM weights \\(\\mathbf{w} = (w_1,\\ldots,w_n)\\) satisfy \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}), \\sigma^2\\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1}),\\] \\(\\mathbf{K} = \\kappa^2\\mathbf{C}+\\mathbf{G}\\) discretization differential operator \\(\\mathbf{h} = (h_1,\\ldots,h_n)\\).","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"prediction","dir":"Articles","previous_headings":"","what":"Prediction","title":"Model prediction and estimation","text":"order illustrate predictions assume parameters \\(\\kappa\\), \\(\\sigma\\) \\(\\sigma_\\varepsilon\\) known. case unknown parameters treated next section. goal section perform prediction latent field \\(X\\) locations observations. Usually, predictions, one provides mean variance predictive distribution. now describe one can generate quantities assuming model defined previous sections. Let us assume want obtain predictions locations \\(\\widetilde{\\mathbf{s}}_1, \\ldots, \\widetilde{\\mathbf{s}}_p \\\\mathcal{D}\\), \\(p\\\\mathbb{N}\\). Notice \\(j=1,\\ldots,p\\), \\[X_n(\\widetilde{\\mathbf{s}}_j) = \\sum_{=1}^n w_i \\varphi_i(\\widetilde{\\mathbf{s}}_j).\\] Therefore, let \\(\\mathbf{}_p\\) \\(p\\times n\\) matrix whose \\((,j)\\)th entry given \\(\\mathbf{}_{p,ij} = \\varphi_j(\\widetilde{\\mathbf{s}}_i)\\), \\[(X_n(\\widetilde{\\mathbf{s}}_1),\\ldots, X_n(\\widetilde{\\mathbf{s}}_p)) = \\mathbf{}_p\\mathbf{w}.\\] Thus, perform prediction desired means variances \\[E[\\mathbf{}_p \\mathbf{w}  | \\mathbf{Y}]\\quad\\hbox{}\\quad V[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}],\\] \\(\\mathbf{Y} = (Y_1,\\ldots,Y_N).\\) Now, observe density \\(\\mathbf{w}|\\mathbf{Y}\\) known. , mean variance computed analytically. two ways circumvent situation. based fact even though know density \\(\\mathbf{w}|\\mathbf{Y}\\), know density \\(\\mathbf{V}|\\mathbf{w},\\mathbf{Y}\\) density \\(\\mathbf{w}|\\mathbf{V},\\mathbf{Y}\\). Therefore can use Gibbs sampler sample \\((\\mathbf{w},\\mathbf{V})|\\mathbf{Y}\\). obtain, byproduct, marginal samples \\(\\mathbf{w}|\\mathbf{Y}\\) \\(\\mathbf{V}|\\mathbf{Y}\\). now provide brief presentation Gibbs sampler provide approximations means variances.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"gibbs-sampler","dir":"Articles","previous_headings":"Prediction","what":"Gibbs sampler","title":"Model prediction and estimation","text":"now briefly describe Gibbs sampler algorithm used . Let \\(\\mathbf{}\\) \\(N\\times n\\) matrix, whose \\((,j)\\)th entry given \\(\\mathbf{}_{ij} = \\varphi_j(\\mathbf{s}_i)\\). Therefore, \\[(X_n(\\mathbf{s}_1),\\ldots,X_n(\\mathbf{s}_N)) = \\mathbf{}\\mathbf{w},\\] \\[\\mathbf{Y} \\approx \\mathbf{}\\mathbf{w} + \\boldsymbol{\\varepsilon},\\] \\(\\boldsymbol{\\varepsilon} = (\\varepsilon_1,\\ldots,\\varepsilon_N)\\). consider representation, .e., assume \\[\\mathbf{Y} = \\mathbf{}\\mathbf{w} + \\boldsymbol{\\varepsilon},\\] error approximation \\(X(\\cdot)\\) \\(X_n(\\cdot)\\) captured measurement noise. Therefore, assumption \\[\\mathbf{Y}|\\mathbf{w} \\sim N(\\mathbf{}\\mathbf{w}, \\sigma_\\varepsilon^{2} \\mathbf{}).\\] Also recall \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}), \\sigma^2\\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1}).\\] Let \\[\\mathbf{m} = \\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})\\quad \\hbox{}\\quad \\mathbf{Q} = \\frac{1}{\\sigma^2}\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}\\mathbf{K}.\\] thus follows (see, also, Wallin Bolin (2015) Asar et al. (2020)) \\[\\mathbf{w} | \\mathbf{V}, \\mathbf{Y} \\sim N\\big(\\widetilde{\\mathbf{m}}, \\widetilde{\\mathbf{Q}}^{-1}),\\] \\[\\widetilde{\\mathbf{Q}} = \\mathbf{Q} + \\sigma_\\varepsilon^{-2} \\mathbf{}^\\top\\mathbf{}\\quad\\hbox{}\\quad \\widetilde{\\mathbf{m}} = \\widetilde{\\mathbf{Q}}^{-1}\\big(\\mathbf{Q}\\mathbf{m}+\\sigma_\\varepsilon^{-2}\\mathbf{}^\\top\\mathbf{Y}\\big).\\] compute conditional distribution \\(\\mathbf{V}|\\mathbf{w}, \\mathbf{Y}\\) one can see Wallin Bolin (2015), pp. 879, \\(V_1,\\ldots,V_n\\) conditionally independent given \\(\\mathbf{w}\\). Furthermore, also Proposition 1 Asar et al. (2020)) \\(V\\sim GIG(p,,b)\\), \\(GIG\\) stands generalized inverse Gaussian distribution parameters \\(p, \\) \\(b\\), , every \\(j=1,\\ldots,n\\), \\[V_j|\\mathbf{w},\\mathbf{Y} \\sim GIG\\Bigg(p-0.5, +\\frac{\\mu^2}{\\sigma^2}, b + \\frac{(\\mathbf{K}\\mathbf{w}+\\mathbf{h}\\mu)_j^2}{\\sigma^2}\\Bigg).\\] now position use Gibbs sampling algorithm: Provide initial values \\(\\mathbf{V}^{(0)}\\); Sample \\(\\mathbf{w}^{(1)} | \\mathbf{V}^{(0)},\\mathbf{Y}\\); Sample \\(\\mathbf{V}^{(1)} | \\mathbf{w}^{(1)}, \\mathbf{Y}\\); Continue sequentially sampling \\(\\mathbf{w}^{()}|\\mathbf{V}^{(-1)},\\mathbf{Y}\\), \\(\\mathbf{V}^{()}|\\mathbf{w}^{()}, \\mathbf{Y}\\) \\(=1,\\ldots,k\\). One stop equilibrium reached. obtain evidence equilibrium achieved, best consider one chain, starting different locations, see mixed well. might also useful see autocorrelation plots. Depending starting values, one might consider burn-samples, , one runs chain iterations, saves last position, throw away rest samples, use starting values. important observe samples \\(\\{\\mathbf{w}^{()},\\mathbf{V}^{()}\\}_{=1}^k\\) independent. However, general assumptions, Gibbs sampler provides samples satisfying law large numbers functionals sample. Therefore, one can use samples compute means variances.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"standard-mc-estimates","dir":"Articles","previous_headings":"Prediction","what":"Standard MC estimates","title":"Model prediction and estimation","text":"Suppose sample \\(\\mathbf{w}^{(1)},\\ldots, \\mathbf{w}^{(k)}\\) approximate mean \\[E[\\mathbf{}_p \\mathbf{w}  | \\mathbf{Y}] \\approx \\frac{1}{k} \\sum_{=1}^k \\mathbf{}_p\\mathbf{w}^{()}\\] approximate variance \\[V[\\mathbf{}_p \\mathbf{w}|\\mathbf{Y}] \\approx \\frac{1}{k} \\sum_{=1}^k (\\mathbf{}_p\\mathbf{w}^{()} - E[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}])^2,\\] \\(\\{\\mathbf{w}^{()}\\}_{=1}^k\\) sample generated using Gibbs sampler algorithm.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"rao-blackwellization-for-means-and-variances","dir":"Articles","previous_headings":"Prediction","what":"Rao-Blackwellization for means and variances","title":"Model prediction and estimation","text":"second way consists performing Rao-Blackwellization (Robert Casella, 2004) means variances. following Wallin Bolin (2015) \\[ \\begin{array}{ccl} E[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}] &=& \\int_\\mathbf{w} \\mathbf{}_p \\mathbf{w} \\pi(\\mathbf{w}|\\mathbf{Y})\\,d\\mathbf{w},\\\\ &=& \\int_\\mathbf{w} \\int_{\\mathbf{V}} \\mathbf{}_p \\mathbf{w} \\pi(\\mathbf{w}|\\mathbf{V},\\mathbf{Y})\\pi(\\mathbf{V}|\\mathbf{Y})\\,d\\mathbf{V}\\,d\\mathbf{w}\\\\ &=& \\int_\\mathbf{V} \\mathbf{}_p \\widetilde{\\mathbf{m}} \\pi(\\mathbf{V}|\\mathbf{Y})\\,d\\mathbf{V}, \\end{array} \\] \\(\\widetilde{\\mathbf{m}} = E[\\mathbf{w}|\\mathbf{V},\\mathbf{Y}]\\), expression given description Gibbs sampler. Thus, approximation \\[E[\\mathbf{}_p\\mathbf{w}|\\mathbf{Y}] \\approx \\frac{1}{k}\\sum_{=1}^k \\mathbf{}_p \\widetilde{\\mathbf{m}}^{()},\\] \\(\\widetilde{\\mathbf{m}}^{()} = \\widetilde{\\mathbf{m}}(\\mathbf{V}^{()})\\), , \\(\\widetilde{\\mathbf{m}}^{()}\\) computed based \\(\\mathbf{V}^{()}\\). Notice, also, \\(\\widetilde{\\mathbf{m}}\\) computed Gibbs sampling, imply additional cost. similar reasoning \\[V(\\mathbf{}_p \\mathbf{w}|\\mathbf{Y}) \\approx \\frac{1}{k}\\sum_{=1}^k\\mathbf{}_p^\\top (\\widetilde{\\mathbf{Q}}^{()})^{-1}\\mathbf{}_p,\\] \\(\\widetilde{\\mathbf{Q}}^{()}\\) conditional covariance matrix \\(\\mathbf{w}\\), given \\(\\mathbf{V}\\) \\(\\mathbf{Y}\\), evaluated \\(\\mathbf{V}^{()}\\).","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"spde-based-model-driven-by-nig-noise-with-gaussian-measurement-errors-in-1d","dir":"Articles","previous_headings":"Examples in R","what":"SPDE based model driven by NIG noise with Gaussian measurement errors in 1D","title":"Model prediction and estimation","text":"example consider latent process \\(X\\) solving equation \\[(\\kappa^2 - \\partial^2/\\partial t^2)X(t) = \\dot{\\mathcal{M}}(t),\\] \\(\\dot{\\mathcal{M}}\\) NIG-distributed white-noise. details NIG distribution well sample process refer reader Sampling processes given solutions SPDEs driven non-Gaussian noise vignette. also using notation vignette. Notice , , assuming \\(V_i\\) follow inverse Gaussian distribution parameters \\(\\nu\\) \\(\\nu h_i^2\\). take \\(\\kappa=1\\), \\(\\sigma_\\varepsilon=1\\), \\(\\sigma=1\\), \\(\\mu = 1\\), \\(\\mathcal{D}=[0,1]\\) \\(\\nu=0.5\\). also assume 10 observations \\[Y_i = X(t_i) + \\varepsilon_i,\\quad =1,\\ldots,10,\\] \\(t_1,\\ldots,t_{10}\\[0,1]\\). Notice \\(\\varepsilon_i \\sim N(0,1)\\). Let us now build matrix \\(K\\), generate \\(V\\) sample NIG model: consider mesh 10 equally spaced nodes. code sample process given .   now generate 9 uniformly distributed random locations determine locations observations. determine locations need build \\(\\) matrix obtain values process \\(X\\) locations. can build \\(\\) matrix using function inla.spde.make..  Now, let us assume want obtain prediction \\(X\\) point \\(t^\\ast = 5\\). end obtain predictions using methods, namely, standard MC Rao-Blackwellization. methods need Gibbs samples, let us build Gibbs samples. build 2 chains different starting values burn-samples. Recall \\(V_j \\sim IG(\\nu, h_j^2 \\cdot \\nu), j=1,\\ldots,10\\), \\(\\mu=1\\) \\(\\sigma=1\\), \\[V_j|\\mathbf{w},\\mathbf{Y} \\sim GIG(-1,\\nu + 1, \\nu\\cdot h_j^2 + (\\mathbf{K}\\mathbf{w}+\\mathbf{h})_j^2)\\] \\[\\mathbf{w} | \\mathbf{V}, \\mathbf{Y} \\sim N\\big( (\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}\\mathbf{K} + \\mathbf{}^\\top\\mathbf{})^{-1}(\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}(\\mathbf{V}-\\mathbf{h})+\\mathbf{}^\\top \\mathbf{Y}), (\\mathbf{K}{\\rm diag}(\\mathbf{V})^{-1}\\mathbf{K} + \\mathbf{}^\\top\\mathbf{})^{-1}\\big).\\] Let us sample 1000 times chain. Let us also record values \\(E[\\mathbf{w} | \\mathbf{V}, \\mathbf{Y}]\\) sampling. Let us organize data build traceplots. Let us compare posterior means: Let us begin building traceplots \\(V\\): \\(W\\):  traceplots appear healthy, stuck anywhere chain apparently mixed well. can also build autocorrelation plots. end let us prepare data frames. Now, let us plot autocorrelation plots \\(V\\):  Now, autocorrelation plots \\(W\\):  can see correlation low. now move forward obtain predictions \\(t^\\ast = 5/9\\). compute MC Rao-Blackwellization predictions.  notice Rao-Blackwellization approach converges much faster standard MC approach.","code":"library(INLA) library(ngme2) library(ggplot2) library(tidyr) set.seed(123)  loc_1d <- 0:9/9 mesh_1d <- inla.mesh.1d(loc_1d)  # inla.mesh.fem # inla.mesh.1d.fem(mesh_1d)$c1 + inla.mesh.1d.fem(mesh_1d)$g1 # attr(simulate(noise_nig(n=10, 1,1,0.5), seed=10), \"noise\")$h  # specify the model we use mu <- 1; sigma <- 1; nu <- 0.5 spde_1d <- model_matern(   kappa = 1,   loc = loc_1d,   mesh = mesh_1d,   noise = noise_nig(mu=mu, sigma=sigma, nu=nu) ) spde_1d$noise$h #>  [1] 0.05555556 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 #>  [7] 0.11111111 0.11111111 0.11111111 0.05555556 K <- spde_1d$C + spde_1d$G   W <- simulate(spde_1d, seed = 10) plot(loc_1d, W, type = \"l\") str(W) #>  num [1:10] -0.719 -0.716 -0.709 -0.708 -0.705 ... #>  - attr(*, \"noise\")=List of 17 #>   ..$ n_noise        : int 10 #>   ..$ h              : num [1:10] 0.0556 0.1111 0.1111 0.1111 0.1111 ... #>   ..$ noise_type     : chr \"nig\" #>   ..$ theta_V        : num 0.5 #>   ..$ V              : num [1:10] 0.000475 0.005676 0.003751 0.001964 0.014118 ... #>   ..$ theta_mu       : num 1 #>   ..$ theta_sigma    : num 0 #>   ..$ B_mu           : num [1:10, 1] 1 1 1 1 1 1 1 1 1 1 #>   ..$ B_sigma        : num [1:10, 1] 1 1 1 1 1 1 1 1 1 1 #>   ..$ n_theta_mu     : int 1 #>   ..$ n_theta_sigma  : int 1 #>   ..$ n_theta_V      : num 1 #>   ..$ fix_theta_mu   : logi FALSE #>   ..$ fix_theta_sigma: logi FALSE #>   ..$ fix_theta_V    : logi FALSE #>   ..$ fix_V          : logi FALSE #>   ..$ n_params       : int 3 #>   ..- attr(*, \"class\")= chr \"ngme_noise\"  V <- attr(W, \"noise\")$V plot(loc_1d, V, type = \"l\") new_loc_1d <- sort(runif(9))  A_matrix <- inla.spde.make.A(   mesh = inla.mesh.1d(loc_1d),   loc = new_loc_1d ) A_matrix #> 9 x 10 sparse Matrix of class \"dgCMatrix\" #>                                                                        #>  [1,] . . 0.3975624 0.6024376 .         .          .         .         #>  [2,] . . .         .         0.1034058 0.89659422 .         .         #>  [3,] . . .         .         .         0.65272182 0.3472782 .         #>  [4,] . . .         .         .         0.23543868 0.7645613 .         #>  [5,] . . .         .         .         0.09864781 0.9013522 .         #>  [6,] . . .         .         .         .          0.7647693 0.2352307 #>  [7,] . . .         .         .         .          0.6232258 0.3767742 #>  [8,] . . .         .         .         .          .         .         #>  [9,] . . .         .         .         .          .         .         #>                              #>  [1,] .          .           #>  [2,] .          .           #>  [3,] .          .           #>  [4,] .          .           #>  [5,] .          .           #>  [6,] .          .           #>  [7,] .          .           #>  [8,] 0.99414616 0.005853845 #>  [9,] 0.05157201 0.948427990 sigma_eps = 1  Y <- A_matrix %*% W + sigma_eps * rnorm(9)  plot(new_loc_1d, Y, type=\"h\") abline(0,0) # First step - Starting values for V # Considering a sample of inv-Gaussian as starting values for both chains h_nig_1d <- spde_1d$h V_1 <- matrix(ngme2::rig(10, nu, nu*h_nig_1d^2, seed = 1), nrow = 1) V_2 <- matrix(ngme2::rig(10, nu, nu*h_nig_1d^2, seed = 2), nrow = 1) W_1 <- matrix(0, nrow=1, ncol=10) W_2 <- matrix(0, nrow=1, ncol=10) N_sim = 1000  # Vector of conditional means E[w|V,Y] m_W_1 <- matrix(0, nrow=1, ncol=10) m_W_2 <- matrix(0, nrow=1, ncol=10)  # Recall that sigma_eps = 1  Asq <- t(A_matrix)%*%A_matrix / sigma_eps^2  # Recall that mu = 1 and sigma = 1 # Gibbs sampling for(i in 1:N_sim){   Q_1 <- K%*%diag(1/V_1[i,])%*%K/sigma^2   Q_2 <- K%*%diag(1/V_2[i,])%*%K/sigma^2    resp_1 <- Q_1%*%solve(K,(-h_nig_1d + V_1[i,])*mu) + t(A_matrix)%*%Y/sigma_eps^2   resp_2 <- Q_2%*%solve(K,(-h_nig_1d + V_2[i,])*mu) + t(A_matrix)%*%Y/sigma_eps^2    m_W_1 <- rbind(m_W_1, t(solve(Q_1 + Asq, resp_1)))   m_W_2 <- rbind(m_W_2, t(solve(Q_2 + Asq, resp_2)))    Chol_1 <- chol(Q_1 + Asq)   Chol_2 <- chol(Q_2 + Asq)    W_1 <- rbind(W_1, m_W_1[i+1,] + t(solve(Chol_1, rnorm(10))))   W_2 <- rbind(W_2, m_W_2[i+1,] + t(solve(Chol_2, rnorm(10))))   V_1 <- rbind(V_1, ngme2::rgig(10,                            -1,                            nu + (mu/sigma)^2,                            nu*h_nig_1d^2 + as.vector((K%*%W_1[i+1,] +h_nig_1d)^2)/sigma^2))   V_2 <- rbind(V_2, ngme2::rgig(10,                                 -1,                                 nu + (mu/sigma)^2,                                 nu*h_nig_1d^2 + as.vector((K%*%W_2[i+1,] +h_nig_1d)^2)/sigma^2)) } df_V <- data.frame(V = V_1[,1], chain = \"1\", coord = 1, idx = 1:(N_sim+1)) temp <- data.frame(V = V_2[,1], chain = \"2\", coord = 1, idx = 1:(N_sim+1)) df_V <- rbind(df_V, temp) for(i in 2:10){   temp_1 <- data.frame(V = V_1[,i], chain = \"1\", coord = i, idx = 1:(N_sim+1))   temp_2 <- data.frame(V = V_2[,i], chain = \"2\", coord = i, idx = 1:(N_sim+1))   df_V <- rbind(df_V, temp_1, temp_2) }  df_W <- data.frame(W = W_1[,1], chain = \"1\", coord = 1, idx = 1:(N_sim+1)) temp <- data.frame(W = W_2[,1], chain = \"2\", coord = 1, idx = 1:(N_sim+1)) df_W <- rbind(df_W, temp) for(i in 2:10){   temp_1 <- data.frame(W = W_1[,i], chain = \"1\", coord = i, idx = 1:(N_sim+1))   temp_2 <- data.frame(W = W_2[,i], chain = \"2\", coord = i, idx = 1:(N_sim+1))   df_W <- rbind(df_W, temp_1, temp_2) } V #>  [1] 0.0004749677 0.0056760013 0.0037506555 0.0019636490 0.0141178141 #>  [6] 0.0017224736 0.1070925727 0.0021844525 0.2940192918 0.0031267615 colMeans(V_1) #>  [1] 0.02766368 0.05981775 0.04680116 0.04470644 0.04357668 0.03881213 #>  [7] 0.04131640 0.05923212 0.03732508 0.02195442 colMeans(V_2) #>  [1] 0.02441686 0.05943484 0.04322910 0.05297342 0.04919148 0.04539081 #>  [7] 0.04780483 0.05558116 0.04325936 0.02092633  as.vector(W) #>  [1] -0.7194627 -0.7164203 -0.7085709 -0.7081622 -0.7047097 -0.7008863 #>  [7] -0.7014796 -0.7270974 -0.7429993 -0.7469908 colMeans(W_1) #>  [1] -0.8854605 -0.8849750 -0.8843456 -0.8834594 -0.8836279 -0.8849921 #>  [7] -0.8858674 -0.8871449 -0.8880770 -0.8885732 colMeans(W_2) #>  [1] -0.8847602 -0.8842303 -0.8828827 -0.8821748 -0.8820013 -0.8837345 #>  [7] -0.8855231 -0.8878549 -0.8891194 -0.8903518 ggplot(df_V, aes(x = idx, y = V, col = chain)) +   geom_line() + facet_wrap(~ coord, ncol=2) ggplot(df_W, aes(x = idx, y = W, col = chain)) +   geom_line() + facet_wrap(~ coord, ncol=2) acf_V <- as.vector(acf(V_1[,1], plot=FALSE)$acf) df_V_acf <- data.frame(acf = acf_V,                        chain = \"1\", coord = 1, lag = 0:(length(acf_V)-1)) acf_V <- as.vector(acf(V_2[,1], plot=FALSE)$acf) temp <- data.frame(acf = as.vector(acf(V_2[,1], plot=FALSE)$acf),                    chain = \"2\", coord = 1, lag = 0:(length(acf_V)-1)) df_V_acf <- rbind(df_V_acf, temp) for(i in 2:10){   acf_V <- as.vector(acf(V_1[,i], plot=FALSE)$acf)   temp_1 <- data.frame(acf = acf_V,                        chain = \"1\", coord = i, lag = 0:(length(acf_V)-1))   acf_V <- as.vector(acf(V_2[,i], plot=FALSE)$acf)   temp_2 <- data.frame(acf = acf_V,                        chain = \"2\", coord = i, lag = 0:(length(acf_V)-1))   df_V_acf <- rbind(df_V_acf, temp_1, temp_2) }  acf_W <- as.vector(acf(W_1[,1], plot=FALSE)$acf) df_W_acf <- data.frame(acf = acf_W,                        chain = \"1\", coord = 1, lag = 0:(length(acf_W)-1)) acf_W <- as.vector(acf(W_2[,1], plot=FALSE)$acf) temp <- data.frame(acf = acf_W, chain = \"2\",                    coord = 1, lag = 0:(length(acf_W)-1)) df_W_acf <- rbind(df_W_acf, temp) for(i in 2:10){   acf_W <- as.vector(acf(W_1[,i], plot=FALSE)$acf)   temp_1 <- data.frame(acf = acf_W,                        chain = \"1\", coord = i, lag = 0:(length(acf_W)-1))   acf_W <- as.vector(acf(W_2[,i], plot=FALSE)$acf)   temp_2 <- data.frame(acf = acf_W,                        chain = \"2\",                    coord = i, lag = 0:(length(acf_W)-1))   df_W_acf <- rbind(df_W_acf, temp_1, temp_2) } ggplot(df_V_acf, aes(x=lag,y=acf, col=chain)) +           geom_bar(stat = \"identity\", position = \"identity\") +   xlab('Lag') + ylab('ACF') + facet_wrap(~coord, ncol=2) ggplot(df_W_acf, aes(x=lag,y=acf, col=chain)) +           geom_bar(stat = \"identity\", position = \"identity\") +   xlab('Lag') + ylab('ACF') + facet_wrap(~coord, ncol=2) # Computing A matrix at t^\\ast  A_pred <- inla.spde.make.A(mesh_1d, loc = 5/9)  # MC_estimate:  AW_1 <- A_pred%*%t(W_1) MC_pred_1 <- cumsum(AW_1)/(1:length(AW_1))  RB_1 <- A_pred%*%t(m_W_1) RB_pred_1 <- cumsum(RB_1)/(1:length(AW_1))  df_pred <- data.frame(idx = 1:length(AW_1), MC = MC_pred_1,                       RB = RB_pred_1, chain = \"1\")  AW_2 <- A_pred%*%t(W_2) MC_pred_2 <- cumsum(AW_2)/(1:length(AW_2))  RB_2 <- A_pred%*%t(m_W_2) RB_pred_2 <- cumsum(RB_2)/(1:length(AW_2))  temp <- data.frame(idx = 1:length(AW_2), MC = MC_pred_2,                       RB = RB_pred_2, chain = \"2\")  df_pred <- rbind(df_pred, temp)  df_pred <- tidyr::pivot_longer(df_pred,      cols = c(\"MC\", \"RB\"),      names_to = \"Method\",      values_to = \"Prediction\")  ggplot(df_pred, aes(x = idx, y = Prediction, col=Method)) +   facet_wrap(~chain) + geom_line()"},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"model-estimation","dir":"Articles","previous_headings":"","what":"Model estimation","title":"Model prediction and estimation","text":"ngme2, employ maximum likelihood estimation stochastic gradient descent method estimate parameters.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"stochastic-gradient-descent-and-maximum-likelihood","dir":"Articles","previous_headings":"Model estimation","what":"Stochastic gradient descent and maximum likelihood","title":"Model prediction and estimation","text":"maximum likelihood estimation goal minimize \\(f({\\boldsymbol{\\theta}}) = -L({\\boldsymbol{\\theta}}; \\mathbf{Y})\\), \\(L\\) log-likelihood function \\(\\mathbf{Y}\\). non-Gaussian models additional complication log-likelihood function \\(L\\) known explicit form. way solve problem use Fisher’s identity (Fisher, 1925). See also Douc et al. (2014) details. Let \\(\\mathbf{U} = (U_1,\\ldots, U_n)\\) sequence observed random variables latent variables \\(\\mathbf{Z} = (Z_1,\\ldots,Z_n)\\), \\(Z_i\\) random variable \\(\\mathbb{R}^p\\). Assume joint distribution \\(\\mathbf{U}\\) \\(\\mathbf{Z}\\) parameterized \\({\\boldsymbol{\\theta}}\\), \\(\\mathbf{{\\boldsymbol{\\theta}}} \\\\Theta\\) \\(\\Theta\\subset\\mathbb{R}^p\\). Assume complete log-likelihood \\(L({\\boldsymbol{\\theta}}; \\mathbf{U},\\mathbf{Z})\\) (respect reference \\(\\sigma\\)-finite measure) differentiable respect \\({\\boldsymbol{\\theta}}\\) regular, sense one may differentiate integral sign. , marginal log-likelihood respect \\(\\mathbf{U}\\) satisfies \\[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{U}) = E_{\\mathbf{Z}}[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{U}, \\mathbf{Z})|\\mathbf{U}].\\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"standard-mc-approximation-of-the-gradient","dir":"Articles","previous_headings":"Model estimation","what":"Standard MC approximation of the gradient","title":"Model prediction and estimation","text":"context, assume \\(\\mathbf{w}\\) \\(\\mathbf{V}\\) hidden. Therefore, may use Fisher’s identity latent variable \\((\\mathbf{V},\\mathbf{w})\\) obtain \\[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}) = E_{\\mathbf{V},\\mathbf{w}}[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V}, \\mathbf{w})|\\mathbf{Y}].\\] Thus, idea use samples \\(\\mathbf{V}\\) \\(\\mathbf{w}\\) obtained Gibbs sampler approximate gradient \\[\\nabla_{{\\boldsymbol{\\theta}}}L({\\boldsymbol{\\theta}};\\mathbf{Y}) \\approx \\frac{1}{k} \\sum_{j=1}^k \\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V}^{(j)}, \\mathbf{w}^{(j)}).\\] end, compute gradients \\(\\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V}, \\mathbf{w})\\). \\[\\mathbf{Y}|\\mathbf{w} \\sim N(\\mathbf{}\\mathbf{w}, \\sigma_\\varepsilon^{-2} \\mathbf{}),\\] \\[\\mathbf{w}|\\mathbf{V} \\sim N(\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}), \\mathbf{K}^{-1}{\\rm diag}(\\mathbf{V})\\mathbf{K}^{-1})\\] \\(\\mathbf{V}\\) follows GIG distribution every \\(\\), \\(E[V_i]=h_i\\). Therefore, \\[\\begin{array}{ccl} L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y}) &=& -n\\log(\\sigma_\\varepsilon)-0.5\\sigma_\\varepsilon^{-2} (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}))\\\\ &-&0.5\\sigma_\\varepsilon^{-2}(\\mathbf{}(\\mathbf{w}-\\mathbf{m})^\\top{\\rm diag} (1/V_i) (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\mathbf{w}-\\mathbf{m})) + const, \\end{array}\\] \\(const\\) depend \\((\\mu,\\sigma)\\). Thus, \\[\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y}) =  \\sigma_\\varepsilon^{-2}\\mathbf{}\\mathbf{K}^{-1}(-\\mathbf{h}+\\mathbf{V}) {\\rm diag} (1/V_i)(\\mathbf{Y}  - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}) - \\mathbf{}(\\mathbf{w}-\\mathbf{m})).\\] Now, respect \\(\\sigma_\\varepsilon\\) \\[\\nabla_{\\sigma_\\varepsilon} L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y}) = -\\frac{n}{\\sigma_\\varepsilon} + \\frac{1}{\\sigma_\\varepsilon^3} (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\mathbf{w}-\\mathbf{m}))^\\top{\\rm diag} (1/V_i) (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\mathbf{w}-\\mathbf{m}))\\] proceeding analogously, obtain gradient respect \\(\\kappa^2\\) given \\[\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{w}, \\mathbf{V}) = tr(\\mathbf{C}\\mathbf{K}^{-1})- \\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)(\\mathbf{K}\\mathbf{w}+(\\mathbf{h}-\\mathbf{V})\\mu).\\] Finally, gradient parameter distribution \\(\\mathbf{V}\\), use Rao-Blackwellized version, see next subsection.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"rao-blackwellized-approximation-of-the-gradient","dir":"Articles","previous_headings":"Model estimation","what":"Rao-Blackwellized approximation of the gradient","title":"Model prediction and estimation","text":"Now, observe can compute log-likelihood \\(L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V})\\). Indeed, apply Fisher’s identity find \\[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V}) = E_\\mathbf{w}[\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y}, \\mathbf{V}, \\mathbf{w})|\\mathbf{Y},\\mathbf{V}].\\] , gradients, can approximate gradient \\(\\nabla_{\\boldsymbol{\\theta}} L({\\boldsymbol{\\theta}}; \\mathbf{Y})\\) taking mean samples \\(\\mathbf{V}\\) obtained Gibbs sampling: \\[\\nabla_{{\\boldsymbol{\\theta}}}L({\\boldsymbol{\\theta}};\\mathbf{Y}) \\approx \\frac{1}{k} \\sum_{j=1}^k \\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V}^{(j)}).\\] Let us now compute gradients \\(\\nabla_{{\\boldsymbol{\\theta}}} L({\\boldsymbol{\\theta}};\\mathbf{Y},\\mathbf{V})\\). begin computing \\(\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{V},\\mathbf{Y})\\). end, use expression \\(\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{w}, \\mathbf{V},\\mathbf{Y})\\) given previous subsection together \\(E[\\mathbf{w}|\\mathbf{V},\\mathbf{Y}] = \\widetilde{\\mathbf{m}}\\), conclude \\[\\nabla_\\mu L((\\mu,\\sigma_\\varepsilon); \\mathbf{V},\\mathbf{Y}) =  \\sigma_\\varepsilon^{-2}\\mathbf{}\\mathbf{K}^{-1}(-\\mathbf{h}+\\mathbf{V}) {\\rm diag} (1/V_i)(\\mathbf{Y}  - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V}) - \\mathbf{}(\\widetilde{\\mathbf{m}}-\\mathbf{m}))\\] Analogously, also obtain \\[\\nabla_{\\sigma_\\varepsilon} L((\\mu,\\sigma_\\varepsilon); \\mathbf{V},\\mathbf{Y}) = -\\frac{n}{\\sigma_\\varepsilon} + \\frac{1}{\\sigma_\\varepsilon^3} (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\widetilde{\\mathbf{m}}-\\mathbf{m}))^\\top{\\rm diag} (1/V_i) (\\mathbf{Y} - \\mathbf{}\\mathbf{K}^{-1}(-\\mu \\mathbf{h}+\\mu\\mathbf{V})-\\mathbf{}(\\widetilde{\\mathbf{m}}-\\mathbf{m})).\\] Now, notice \\[\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{w}, \\mathbf{V}) = tr(\\mathbf{C}\\mathbf{K}^{-1})- \\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\mathbf{w}-\\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)(\\mathbf{h}-\\mathbf{V})\\mu,\\] \\[E[\\mathbf{w}|\\mathbf{V},\\mathbf{Y}] = \\widetilde{\\mathbf{m}}\\] \\[E[\\mathbf{w}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\mathbf{w}|\\mathbf{V},\\mathbf{Y}] =  tr(\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{Q}}^{-1}) +   \\widetilde{\\mathbf{m}}^\\top\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{m}}\\] conclude \\[\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{V}) = tr(\\mathbf{C}\\mathbf{K}^{-1})- tr(\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{Q}}^{-1}) -   \\widetilde{\\mathbf{m}}^\\top\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{m}}-\\widetilde{\\mathbf{m}}^\\top \\mathbf{C}^\\top{\\rm diag} (1/V_i)(\\mathbf{h}-\\mathbf{V})\\mu.\\] Finally, gradient parameter distribution \\(\\mathbf{V}\\) depends distribution \\(\\mathbf{V}\\). illustrate present gradient respect parameter \\(\\nu\\) \\(\\mathbf{V}\\) follows inverse-Gaussian distribution, situation NIG noise. case \\[\\nabla_\\nu L(\\nu; \\mathbf{Y},\\mathbf{V}) = -\\sum_{j=1}^n \\frac{1}{2}\\Bigg(\\nu^{-1} -\\frac{h_{j}^2}{V_j} +V_j -h_j\\Bigg).\\]","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"a-remark-on-traces","dir":"Articles","previous_headings":"Model estimation > Rao-Blackwellized approximation of the gradient","what":"A remark on traces","title":"Model prediction and estimation","text":"gradients \\(\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{V})\\) \\(\\nabla_{\\kappa^2} L(\\kappa^2; \\mathbf{Y}, \\mathbf{w}, \\mathbf{V})\\), can see traces \\(tr(\\mathbf{C}\\mathbf{K}^{-1})\\) \\(tr(\\mathbf{C}^\\top{\\rm diag} (1/V_i)\\mathbf{K}\\widetilde{\\mathbf{Q}}^{-1})\\). traces contain inverses \\(\\mathbf{K}^{-1}\\) \\(\\widetilde{\\mathbf{Q}}^{-1}\\). efficient alternatives handling traces. instance, want compute \\(tr(AB^{-1})\\), \\(B\\) symmetric, sparsity \\(B\\) sparsity \\(\\), need compute elements \\(B^{-1}\\) coordinates non-zero entries. happens, instance, \\(tr(\\mathbf{C}\\mathbf{K}^{-1})\\). , compute trace efficient alternative. implemented ngme package.","code":""},{"path":"https://davidbolin.github.io/ngme2/articles/pred_and_est.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Model prediction and estimation","text":"Lindgren, F., Rue, H., Lindstrom, J. (2011). explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach. Journal Royal Statistical Society: Series B (Statistical Methodology), 73(4):423–498. Robert, C., G. Casella (2004). Monte Carlo statistical methods, Springer Texts Statistics, Springer, New York, USA. Wallin, J., Bollin, D. (2015). Geostatistical Modelling Using Non-Gaussian Matérn Fields. Scandinavian Journal Statistics. 42(3):872-890. Whittle, P. (1963). Stochastic-processes several dimensions. Bulletin International Statistical Institute, 40(2):974–994.","code":""},{"path":"https://davidbolin.github.io/ngme2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Author, maintainer. Xiaotian Jin. Author. Alexandre Simas. Author. Jonas Wallin. Author.","code":""},{"path":"https://davidbolin.github.io/ngme2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Jin X, Simas , Wallin J (2022). ngme2: Latent Mixed Effects Models Flexible Distributions. R package version 0.1.0, https://davidbolin.github.io/ngme2/.","code":"@Manual{,   title = {ngme2: Latent Mixed Effects Models With Flexible Distributions},   author = {David Bolin and Xiaotian Jin and Alexandre Simas and Jonas Wallin},   year = {2022},   note = {R package version 0.1.0},   url = {https://davidbolin.github.io/ngme2/}, }"},{"path":"https://davidbolin.github.io/ngme2/index.html","id":"the-ngme2-package","dir":"","previous_headings":"","what":"Latent Mixed Effects Models With Flexible Distributions","title":"Latent Mixed Effects Models With Flexible Distributions","text":"ngme2 R package used fitting non-gaussian mixed effects models. models fitted using maximum likelihood estimation preconditioned stochastic gradient descent. Basic statistical operations likelihood evaluations kriging predictions also implemented.","code":""},{"path":"https://davidbolin.github.io/ngme2/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Latent Mixed Effects Models With Flexible Distributions","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form Lβ(τu) = 𝒲. 𝒲 Gaussian white noise, L second-order differential operator, fractional power β > 0 determines smoothness u. See explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. package aims address non-Gaussian extension SPDE approach model replacing driven noise 𝒲 non-Gaussian noise ℳ. specificly, type-G Lévy process. increment type-G Lévy process can represented $$ \\gamma + \\mu V + \\sigma \\sqrt{V}Z, $$ γ, μ parameters, Z ∼ N(0,1) independent V, V positive infinitely divisible random variable. One example normal inverse Gaussian (NIG) noise. (See vignette(\"SPDE-approach\", package = \"ngme2\") details)","code":""},{"path":"https://davidbolin.github.io/ngme2/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Latent Mixed Effects Models With Flexible Distributions","text":"development version can installed using command See also Installation Configuration vignette.","code":"remotes::install_github(\"davidbolin/ngme2\", ref = \"devel\")"},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":null,"dir":"Reference","previous_headings":"","what":"Argo float dataset — argo_float","title":"Argo float dataset — argo_float","text":"Argo floats measurements.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Argo float dataset — argo_float","text":"","code":"data(\"argo_float\")"},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Argo float dataset — argo_float","text":"Data frame containing 274 observations 4 variables. lat Latitude. lon Longitude. sal Salinity. temp Temperature.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Argo float dataset — argo_float","text":"Data can obtained Argo float website.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/argo_float.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Argo float dataset — argo_float","text":"floats pressure case made aluminium 1.3m long 20cm diameter. weigh 40kg. top antenna communicate satellites fix float's position receive data. Also top temperature, salinity pressure sensors.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ngme noise with a list — create_noise","title":"Create ngme noise with a list — create_noise","text":"Create ngme noise list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ngme noise with a list — create_noise","text":"","code":"create_noise(x)"},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ngme noise with a list — create_noise","text":"x list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/create_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ngme noise with a list — create_noise","text":"list specification ngme","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":null,"dir":"Reference","previous_headings":"","what":"Specifying a latent process model (wrapper function for each model) — f","title":"Specifying a latent process model (wrapper function for each model) — f","text":"Function used defining smooth spatial terms within ngme model formulae. function wrapper function specific submodels. (see ngme_models_types() available models).","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specifying a latent process model (wrapper function for each model) — f","text":"","code":"f(   x = NULL,   model = \"ar1\",   replicates = NULL,   noise = noise_normal(),   control = ngme_control_f(),   data = NULL,   A = NULL,   A_pred = NULL,   theta_K = NULL,   W = NULL,   fix_W = NULL,   fix_theta_K = NULL,   index_pred = NULL,   debug = NULL,   index_NA = NULL,   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specifying a latent process model (wrapper function for each model) — f","text":"x symbol numerical value: index covariates build index model 1. string: type model, 2. ngme.spde object replicates Representing replicates noise 1. string: type model, 2. ngme.noise object (can also specified ngme model) control control variables f model data specifed inherit ngme formula Matrix connecting observation mesh A_pred Matrix connecting NA location mesh theta_K Unbounded parameter K W starting value process fix_W stop sampling W fix_theta_K fix estimation theta_K. index_pred index prediction debug Debug mode index_NA Logical vector, .na(response var.) ... additional arguments inherit data ngme function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specifying a latent process model (wrapper function for each model) — f","text":"list latent_in constructing latent model, e.g. , h, C, G, also 1. Information K matrix 2. Information noise 3. Control variables","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":null,"dir":"Reference","previous_headings":"","what":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"Density, distribution function, quantile function random generation generalised inverse-Gaussian distribution  parameters p, b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"","code":"dgig(x, p, a, b, log = FALSE)  rgig(n, p, a, b, seed = 0)  pgig(q, p, a, b, lower.tail = TRUE, log.p = FALSE)  qgig(prob, p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"x, q vector quantiles. p parameter p. , b parameters b. Must positive. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). prob vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"dgig gives density, pgig gives distribution function, qgig gives quantile function, rgig generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rgig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"generalised inverse-Gaussian distribution density given  $$f(x; p, , b) = ((/b)^{p/2})/(2K_p(\\sqrt{ab})) x^{p-1} \\exp\\{-(/2)x - (b/2)/x\\},$$  \\(K_p\\) modified Bessel function second kind order \\(p\\),  \\(x>0\\), \\(,b>0\\) \\(p\\\\mathbb{R}\\).  See Jørgensen (1982) details.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"Jørgensen, Bent (1982). Statistical Properties Generalized Inverse Gaussian Distribution. Lecture Notes Statistics. 9. New York–Berlin: Springer-Verlag. doi:10.1007/978-1-4612-5698-4","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/gig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Generalised Inverse-Gaussian (GIG) Distribution — gig","text":"","code":"rgig(20, p = 1, a = 1, b = 1) #>  [1] 2.7456135 4.6508068 1.6410261 1.1234277 1.6584761 0.6097993 0.4723194 #>  [8] 0.3679616 2.1419540 1.4687663 3.0398370 2.2056290 3.8793344 2.5430347 #> [15] 1.9452479 2.1215988 3.0252206 1.2017890 5.0633543 4.0324693 pgig(0.4, p = 1, a = 1, b = 1) #> [1] 0.02956016 qgig(0.8, p = 1, a = 1, b = 1) #> [1] 4.055929 plot(function(x){dgig(x, p = 1, a = 1, b = 1)}, main = \"Generalised inverse-Gaussian density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":null,"dir":"Reference","previous_headings":"","what":"The Inverse-Gaussian (IG) Distribution — ig","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"Density, distribution function, quantile function random generation inverse-Gaussian distribution  parameters b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"","code":"dig(x, a, b, log = FALSE)  rig(n, a, b, seed = 0)  pig(q, a, b, lower.tail = TRUE, log.p = FALSE)  qig(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"x, q vector quantiles. , b parameters b. Must positive. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"dig gives density, pig gives distribution function, qig gives quantile function, rig generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"inverse-Gaussian distribution density given  $$f(x; , b) = \\frac{\\sqrt{b}}{\\sqrt{2\\pi x^3}}\\exp(  -\\frac{}{2}x -\\frac{b}{2x} + \\sqrt{ab}),$$  \\(x>0\\) \\(,b>0\\). parameterization,  \\(E(X) = \\sqrt{b}/\\sqrt{}\\). See Tweedie (1957a, 1957b)  details.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"Tweedie, M. C. K. (1957a). \"Statistical Properties Inverse Gaussian Distributions \". Annals Mathematical Statistics. 28 (2): 362–377. doi:10.1214/aoms/1177706964 Tweedie, M. C. K. (1957b). \"Statistical Properties Inverse Gaussian Distributions II\". Annals Mathematical Statistics. 28 (3): 696–705. doi:10.1214/aoms/1177706881","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/ig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Inverse-Gaussian (IG) Distribution — ig","text":"","code":"rig(100, a = 1, b = 1) #>   [1] 0.2403543 2.6971103 0.5280727 0.1790327 1.7287594 0.8549390 0.2500877 #>   [8] 0.9945400 0.7656803 0.7402284 0.5633761 0.9264219 0.5697466 0.4782969 #>  [15] 0.3867939 1.6258684 0.5326742 1.5329864 0.6053782 1.9227589 2.8072790 #>  [22] 1.4751039 0.9017122 0.9511821 0.2608028 0.1252285 0.5386674 2.1560813 #>  [29] 0.0932991 0.2859527 0.6958437 0.3504658 3.5046756 0.3855693 0.4546618 #>  [36] 5.2306980 3.4363959 1.1517172 0.5291061 0.6348738 0.3206488 1.4361326 #>  [43] 1.4432999 1.1431964 0.3113267 1.2222519 0.5765496 0.6034871 0.6679567 #>  [50] 0.9615364 2.3521530 0.8697236 0.3520969 1.8728375 0.1655195 0.5098540 #>  [57] 0.1728391 1.1353816 0.3286761 0.3013626 0.3780377 0.3966572 0.3927896 #>  [64] 1.3366922 1.2797974 1.3954948 0.4339495 0.3152242 0.1470736 0.7801523 #>  [71] 0.6221980 0.4659217 0.1318928 0.2231985 2.1149994 0.3463988 0.3618301 #>  [78] 0.5916160 0.3539802 0.4045788 0.4528660 0.7800559 1.1659547 0.3741228 #>  [85] 0.4599639 2.1731173 2.0799303 0.1649119 1.3536073 0.4266351 1.5226360 #>  [92] 0.4206061 0.1394293 0.4425900 1.7775956 1.3165206 0.5032157 0.2438194 #>  [99] 0.5179713 1.1788900 pig(0.4, a = 1, b = 1) #> [1] 0.2706137 qig(0.8, a = 1, b = 1) #> [1] 1.447891 plot(function(x){dig(x, a = 1, b = 1)}, main = \"Inverse-Gaussian density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":null,"dir":"Reference","previous_headings":"","what":"The Inverse-Gamma (IGam) Distribution — igam","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"Density, distribution function, quantile function random generation inverse-Gamma distribution  parameters b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"","code":"digam(x, a, b, log = FALSE)  rigam(n, a, b)  pigam(q, a, b, lower.tail = TRUE, log.p = FALSE)  qigam(p, a, b, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"x, q vector quantiles. , b parameters b. Must positive. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"digam gives density, pigam gives distribution function, qigam gives quantile function, rigam generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"inverse-Gamma distribution density given  $$f(x; , b) = \\frac{b^}{\\Gamma()}x^{-1}\\exp(  -\\frac{b}{x}),$$  \\(x>0\\) \\(,b>0\\).","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/igam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Inverse-Gamma (IGam) Distribution — igam","text":"","code":"rigam(100, a = 1, b = 1) #>   [1]  0.4670936  0.8422582  3.3576943  8.4611811  0.8018036  0.3662147 #>   [7]  2.8864874  3.2071041  6.7954316 10.8990519  1.9291395  0.7576263 #>  [13] 36.5012157  0.5817417  0.4017295  2.7128121  2.2996277  1.0907709 #>  [19]  1.0000754 14.4124080  0.4294034  0.6930106 11.5561061  0.3623063 #>  [25]  5.9143954 11.9297873  0.6502078  0.7054466  1.8914429  0.7551636 #>  [31]  0.5776041  0.4188901  1.4609096  2.2600047  1.9127391  0.3107348 #>  [37]  0.6897279  0.4524559 29.8231916  0.9425737  0.3911584 50.9519979 #>  [43]  1.4608404  0.5043041  1.9627381  0.5073783  0.9188972  0.6469464 #>  [49]  0.8634626  0.4984181 21.8998664  1.2468285  0.2112498  1.1064784 #>  [55]  1.6023344  0.3632730  3.4253064  0.5899887  1.7590280  0.4253946 #>  [61]  3.8623489  3.4792426  6.4965632  9.6495698  3.7129224 31.4922880 #>  [67]  0.7031070  0.6076453  1.4852159  1.8809490 28.1400518  1.5153223 #>  [73]  1.6915888  2.2034463  1.4019482  1.1051001  0.6742581  0.6113716 #>  [79]  1.3211020  1.6477187  2.3652235  3.0881744  1.0018243  0.7825521 #>  [85]  0.5036534  3.3306264  0.9381900  1.4126726  1.5983642  0.8741822 #>  [91]  0.4651705  1.6400358 33.3276328  0.8993208  4.1784615  0.5373320 #>  [97] 22.9206126  0.4344469  5.1213743  0.6008903 pigam(0.4, a = 1, b = 1) #> [1] 0.082085 qigam(0.8, a = 1, b = 1) #> [1] 4.48142 plot(function(x){digam(x, a = 1, b = 1)}, main = \"Inverse-Gamma density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":null,"dir":"Reference","previous_headings":"","what":"taking mean over a list of nested lists — mean_list","title":"taking mean over a list of nested lists — mean_list","text":"taking mean list nested lists","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"taking mean over a list of nested lists — mean_list","text":"","code":"mean_list(lls)"},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"taking mean over a list of nested lists — mean_list","text":"lls list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"taking mean over a list of nested lists — mean_list","text":"list nested lists","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/mean_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"taking mean over a list of nested lists — mean_list","text":"","code":"ls <- list(   list(a=1, b=2, t=\"nig\", ll=list(a=1,b=2, w=\"ab\")),   list(a=3, b=5, t=\"nig\", ll=list(a=1,b=6, w=\"ab\")),   list(a=5, b=5, t=\"nig\", ll=list(a=4,b=2, w=\"ab\")) ) mean_list(ls) #> $a #> [1] 3 #>  #> $b #> [1] 4 #>  #> $t #> [1] \"nig\" #>  #> $ll #> $ll$a #> [1] 2 #>  #> $ll$b #> [1] 3.333333 #>  #> $ll$w #> [1] \"ab\" #>  #>"},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme AR(1) model specification — model_ar1","title":"ngme AR(1) model specification — model_ar1","text":"Generating C, G given index replicates","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme AR(1) model specification — model_ar1","text":"","code":"model_ar1(   x,   replicates = NULL,   index_NA = NULL,   data = NULL,   noise = noise_normal(),   alpha = 0.5,   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme AR(1) model specification — model_ar1","text":"x integer vector, time index AR(1) process replicates replicates process index_NA Logical vector, .na(response var.) data data, can specified f(), ngme() noise noise, can specified f() alpha initial value alpha ... extra arguments f()","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme AR(1) model specification — model_ar1","text":"list specification model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_ar1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme AR(1) model specification — model_ar1","text":"","code":"model_ar1(c(1:3, 1:3), replicates = c(1,1,1,2,2,2)) #> as(<dgTMatrix>, \"dgCMatrix\") is deprecated since Matrix 1.5-0; do as(., \"CsparseMatrix\") instead #> Ngme model: ar1 #> Model parameters:  #>     alpha = 0.5 #>  #> Noise type - normal #> Noise parameters:  #>     sigma = 1 f(xx, model = \"ar1\", data=list(xx = c(2,4,5)), noise=noise_nig()) #> Ngme model: ar1 #> Model parameters:  #>     alpha = 0.5 #>  #> Noise type - nig #> Noise parameters:  #>     mu = 0 #>     sigma = 1 #>     nu = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Matern SPDE model — model_matern","title":"Create a Matern SPDE model — model_matern","text":"Create Matern SPDE model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Matern SPDE model — model_matern","text":"","code":"model_matern(   loc = NULL,   replicates = NULL,   alpha = 2,   kappa = 1,   theta_kappa = NULL,   B_kappa = NULL,   mesh = NULL,   fem.mesh.matrices = NULL,   d = NULL,   index_NA = NULL,   A = NULL,   A_pred = NULL,   noise = noise_normal(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Matern SPDE model — model_matern","text":"loc numeric vector (1d) matrix column 2 (2d), location make index replicates replicates process alpha 2 4, SPDE smoothness parameter kappa parameterization kappa^2 C + G, stationary theta_kappa parameterization non-stationary B_kappa bases kappa mesh mesh argument fem.mesh.matrices specify FEM matrices d indicating dimension mesh (together fem.mesh.matrices) index_NA Logical vector, .na(response var.) Matrix connecting observation mesh A_pred Matrix connecting NA location mesh noise 1. string: type model, 2. ngme.noise object ... extra arguments f()","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Matern SPDE model — model_matern","text":"list (n, C (diagonal), G, B.kappa) constructing operator","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme model - random walk of order 1 — model_rw","title":"ngme model - random walk of order 1 — model_rw","text":"Generating C, G given index replicates size C G (n-1) * n, size V n-1","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme model - random walk of order 1 — model_rw","text":"","code":"model_rw(   x,   order = 1,   replicates = NULL,   data = NULL,   circular = FALSE,   index_NA = NULL,   noise = noise_normal(),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme model - random walk of order 1 — model_rw","text":"x numerical vector, covariates build index process order 1 2, order random walk model replicates replicates process data specifed inherit ngme formula circular whether mesh circular, .e. first one connected last index_NA Logical vector, .na(response variable) noise 1. string: type model, 2. ngme.noise object (can also specified ngme model) ... additional arguments","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme model - random walk of order 1 — model_rw","text":"list","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/model_rw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme model - random walk of order 1 — model_rw","text":"","code":"r1 <- model_rw(1:7, order = 1, circular = TRUE); r1$C + r1$G #> 6 x 6 sparse Matrix of class \"dgCMatrix\" #>                        #> [1,]  1 -1  .  .  .  . #> [2,]  .  1 -1  .  .  . #> [3,]  .  .  1 -1  .  . #> [4,]  .  .  .  1 -1  . #> [5,]  .  .  .  .  1 -1 #> [6,] -1  .  .  .  .  1 r2 <- model_rw(1:7, order = 1); r2$C + r2$G #> 6 x 7 sparse Matrix of class \"dgCMatrix\" #>                          #> [1,] 1 -1  .  .  .  .  . #> [2,] .  1 -1  .  .  .  . #> [3,] .  .  1 -1  .  .  . #> [4,] .  .  .  1 -1  .  . #> [5,] .  .  .  .  1 -1  . #> [6,] .  .  .  .  .  1 -1"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit an additice linear mixed effect model — ngme","title":"Fit an additice linear mixed effect model — ngme","text":"ngme function performs analysis non-gaussian additive models.  maximum likelihood estimation via stochastic gradient descent.  prediction unknown location can performed leaving response  variable NA. likelihood specified family. model estimation control can setted control using  ngme_control() function, see ?ngme_control details. See ngme_model_types() available models.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit an additice linear mixed effect model — ngme","text":"","code":"ngme(   formula,   data,   control = ngme_control(),   family = \"normal\",   beta = NULL,   seed = NULL,   start = NULL,   debug = FALSE )"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit an additice linear mixed effect model — ngme","text":"formula formula data dataframe list providing data (response variable can contain NA value,  NA value columns cause problem) control control variables, see ?ngme.control family likelihood type, measurement noise specification, 1. string 2. ngme noise obejct beta starting value fixed effects seed set seed pesudo random number generator start starting ngme object (usually object last fitting) debug toggle debug mode","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit an additice linear mixed effect model — ngme","text":"list outputs contains estimation operator paramters, noise parameters","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit an additice linear mixed effect model — ngme","text":"","code":"ngme(  formula = Y ~ x1 + f(    x2,    model = \"ar1\",    noise = noise_nig(),    theta_K = 0.5  ) + f(    model = model_rw(1:5, order=1, circular = TRUE),    noise = noise_normal(),  ),  family = noise_normal(sd = 0.5),  data = data.frame(Y = 1:5, x1 = 2:6, x2 = 3:7),  control = ngme_control(    estimation = FALSE  ) ) #> *** Ngme object *** #>  #> Fixed effects:  #>    beta = -1,  1 #>  #> Measurement noise:  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1 #>  #>  #> Latent models:  #> [[1]] #>   Ngme model: ar1 #>   Model parameters:  #>       alpha = 0.5 #>  #>   Noise type - nig #>   Noise parameters:  #>       mu = 0 #>       sigma = 1 #>       nu = 1 #> [[2]] #>   Ngme model: rw1 #>   Model parameters:  #>       No parameter needed. #>  #>   Noise type - normal #>   Noise parameters:  #>       sigma = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme2.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme2 — ngme2","title":"ngme2 — ngme2","text":"Inference prediction mixed effects models flexible non-Gaussian Gaussian distributions.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ngme2 — ngme2","text":"David Bolin <davidbolin@gmail.com>","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"Convert sparse matrix sparse dgCMatrix","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"","code":"ngme_as_sparse(G)"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"G matrix","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_as_sparse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert sparse matrix into sparse dgCMatrix — ngme_as_sparse","text":"sparse dgCMatrix","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate control specifications for ngme() function. — ngme_control","title":"Generate control specifications for ngme() function. — ngme_control","text":"configurations ngme estimation optimization process.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate control specifications for ngme() function. — ngme_control","text":"","code":"ngme_control(   burnin = 100,   iterations = 100,   gibbs_sample = 5,   stepsize = 1,   estimation = TRUE,   n_parallel_chain = 2,   stop_points = 10,   exchange_VW = TRUE,   n_slope_check = 3,   std_lim = 0.1,   trend_lim = 0.05,   print_check_info = TRUE,   opt_beta = TRUE,   fix_beta = FALSE,   max_relative_step = 0.1,   max_absolute_step = 0.5,   reduce_var = FALSE,   reduce_power = 0.75,   threshold = 1e-05,   window_size = 1 )"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate control specifications for ngme() function. — ngme_control","text":"burnin burn-periods iterations optimizing terations gibbs_sample number gibbs sampels stepsize stepsize estimation estimating parameters n_parallel_chain number parallel chains stop_points number stop points convergence check exchange_VW exchange last V W chian n_slope_check number stop points regression std_lim maximum allowed standard deviation trend_lim maximum allowed slope print_check_info print convergence information opt_beta logical, optimize fixed effect fix_beta logical, fix fixed effect max_relative_step max relative step allowed 1 iteration max_absolute_step max absolute step allowed 1 iteration reduce_var logical, reduce variace reduce_power numerical power reduce level threshold till start reduce variance window_size numerical, length window final estimates","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate control specifications for ngme() function. — ngme_control","text":"list control variables","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate control specifications for ngme() function. — ngme_control","text":"enable convergence check, need multiple chains running.  compare trend estimated parameter length  n_slope_check (linear regression) trend_lim.  compare standard devation estimated parameters (different chains)  std_lim.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate control specifications for f function — ngme_control_f","title":"Generate control specifications for f function — ngme_control_f","text":"Generate control specifications f function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate control specifications for f function — ngme_control_f","text":"","code":"ngme_control_f(   numer_grad = FALSE,   use_precond = FALSE,   use_num_hess = TRUE,   eps = 0.01 )"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate control specifications for f function — ngme_control_f","text":"numer_grad whether use numerical gradient use_precond whether use preconditioner use_num_hess whether use numerical hessian eps eps computing numerical gradient","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_control_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate control specifications for f function — ngme_control_f","text":"list control variables","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_model_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Show ngme mdoel types — ngme_model_types","title":"Show ngme mdoel types — ngme_model_types","text":"Show ngme mdoel types","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_model_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show ngme mdoel types — ngme_model_types","text":"","code":"ngme_model_types()"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_model_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show ngme mdoel types — ngme_model_types","text":"available types models","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"ngme noise specification — ngme_noise","title":"ngme noise specification — ngme_noise","text":"Function specifying ngme noise. Please use noise_nig noise_normal simpler usage. Use ngme_noise_types() check available types.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ngme noise specification — ngme_noise","text":"","code":"ngme_noise(   noise_type,   mu = 0,   sigma = 1,   nu = 1,   n = 1,   theta_mu = NULL,   B_mu = NULL,   theta_sigma = NULL,   B_sigma = NULL,   fix_theta_mu = FALSE,   fix_theta_sigma = FALSE,   fix_theta_V = FALSE,   V = NULL,   h = NULL,   fix_V = FALSE,   ... )  noise_normal(   sigma = NULL,   theta_sigma = NULL,   B_sigma = matrix(1, 1, 1),   n = nrow(B_sigma),   ... )  noise_nig(   mu = NULL,   sigma = NULL,   nu = NULL,   n = 1,   V = NULL,   theta_mu = NULL,   theta_sigma = NULL,   B_mu = matrix(1),   B_sigma = matrix(1),   ... )"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ngme noise specification — ngme_noise","text":"noise_type type noise, \"nig\", \"normal\" mu specify NIG noise parameter mu, see ?nig sigma specify noise parameter sigma, see ?nig nu specify NIG noise parameter nu (nu>0), see ?nig n number noise (= nrow(B_mu) = nrow(B_sigma)) theta_mu specify non-stationary noise using theta_mu B_mu Basis matrix mu (non-stationary) theta_sigma specify non-stationary noise using theta_sigma B_sigma Basis matrix sigma (non-stationary) fix_theta_mu fix parameter theta_mu fix_theta_sigma fix parameter theta_sigma fix_theta_V fix parameter theta_V V start value V h numerical vector (> 0), mesh width fix_V fix sampling V ... additional arguments","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ngme noise specification — ngme_noise","text":"list specification noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ngme noise specification — ngme_noise","text":"parameterization given ?nig. Moreover, specifying non-stationary mu sigma, $$\\mu = B_{\\mu} \\theta_{\\mu},$$ $$\\sigma = \\exp (B_{\\sigma} \\theta_{\\sigma}),$$","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ngme noise specification — ngme_noise","text":"","code":"noise_normal(n = 10, sigma = 2) #> Noise type - normal #> Noise parameters:  #>     sigma = 2 noise_nig(mu = 1, sigma = 2, nu = 1, n=10) #> Noise type - nig #> Noise parameters:  #>     mu = 1 #>     sigma = 2 #>     nu = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise_types.html","id":null,"dir":"Reference","previous_headings":"","what":"show ngme noise types — ngme_noise_types","title":"show ngme noise types — ngme_noise_types","text":"show ngme noise types","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"show ngme noise types — ngme_noise_types","text":"","code":"ngme_noise_types()"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_noise_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"show ngme noise types — ngme_noise_types","text":"available types noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse the formula for ngme function — ngme_parse_formula","title":"Parse the formula for ngme function — ngme_parse_formula","text":"Parse formula ngme function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse the formula for ngme function — ngme_parse_formula","text":"","code":"ngme_parse_formula(gf, data)"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse the formula for ngme function — ngme_parse_formula","text":"gf formula data data.frame","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_parse_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse the formula for ngme function — ngme_parse_formula","text":"1. plain formula without f function  2. latents_in - f function","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":null,"dir":"Reference","previous_headings":"","what":"Make observation matrix for time series — ngme_ts_make_A","title":"Make observation matrix for time series — ngme_ts_make_A","text":"Make observation matrix time series","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make observation matrix for time series — ngme_ts_make_A","text":"","code":"ngme_ts_make_A(loc, replicates = NULL, range = c(1, max(loc)))"},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make observation matrix for time series — ngme_ts_make_A","text":"loc integers (sorting, gaps > 1) replicates indicating replicate measure location range range mesh default range=(min(loc), max(loc))","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make observation matrix for time series — ngme_ts_make_A","text":"matrix (length(loc) * length(unique(loc)))","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/ngme_ts_make_A.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make observation matrix for time series — ngme_ts_make_A","text":"","code":"ngme_ts_make_A(c(1, 2, 2), replicates = c(1, 1, 2)) #> 3 x 4 sparse Matrix of class \"dgCMatrix\" #>              #> [1,] 1 . . . #> [2,] . 1 . . #> [3,] . . . 1 ngme_ts_make_A(c(1, 2, 2), range = c(1, 5)) #> 3 x 5 sparse Matrix of class \"dgCMatrix\" #>                #> [1,] 1 . . . . #> [2,] . 1 . . . #> [3,] . 1 . . ."},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":null,"dir":"Reference","previous_headings":"","what":"The Normal Inverse-Gaussian (GIG) Distribution — nig","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"Density, distribution function, quantile function random generation normal inverse-Gaussian distribution  parameters p, b.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"","code":"dnig(x, delta, mu, nu, sigma, log = FALSE)  rnig(n, delta, mu, nu, sigma, seed = 0)  pnig(q, delta, mu, nu, sigma, lower.tail = TRUE, log.p = FALSE)  qnig(p, delta, mu, nu, sigma, lower.tail = TRUE, log.p = FALSE)"},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"x, q vector quantiles. delta numeric value location parameter. mu numeric value shift parameter. nu numeric value shape parameter. sigma numeric value scaling parameter. log, log.p logical; TRUE, probabilities/densities \\(p\\) returned \\(log(p)\\). n, number observations. seed Seed random generation. lower.tail logical; TRUE, probabilities \\(P[X\\leq x]\\), otherwise, \\(P[X>x]\\). p vector probabilities.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"dnig gives density, pnig gives distribution function, qnig gives quantile function, rnig generates random deviates. Invalid arguments result return value NaN, warning. length result determined n rnig.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"normal inverse-Gaussian distribution density given  $$f(x; p, , b) =  \\frac{e^{\\nu+\\mu(x-\\delta)/\\sigma^2}\\sqrt{\\nu\\mu^2/\\sigma^2+\\nu^2}}{\\pi\\sqrt{\\nu\\sigma^2+(x-\\delta)^2}}  K_1(\\sqrt{(\\nu\\sigma^2+(x-\\delta)^2)(\\mu^2/\\sigma^4+\\nu/\\sigma^2)}),$$  \\(K_p\\) modified Bessel function second kind order \\(p\\),  \\(x>0\\), \\(\\nu>0\\) \\(\\mu,\\delta, \\sigma\\\\mathbb{R}\\).  See Barndorff-Nielsen (1977, 1978 1997) details.","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"Barndorff-Nielsen, O. (1977) Exponentially decreasing distributions logarithm particle size. Proceedings Royal Society London. Series , Mathematical Physical Sciences. Royal Society. 353, 401–409. doi:10.1098/rspa.1977.0041 Barndorff-Nielsen, O. (1978) Hyperbolic Distributions Distributions Hyperbolae, Scandinavian Journal Statistics. 5, 151–157. Barndorff-Nielsen, O. (1997) Normal Inverse Gaussian Distributions Stochastic Volatility Modelling, Scandinavian Journal Statistics. 24, 1-13. doi:10.1111/1467-9469.00045","code":""},{"path":[]},{"path":"https://davidbolin.github.io/ngme2/reference/nig.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Normal Inverse-Gaussian (GIG) Distribution — nig","text":"","code":"rnig(100, delta = 0, mu = 5, sigma = 1, nu = 1) #>   [1]  1.6988504  1.2882816  3.5785008  5.5695379  4.9514893  8.2962733 #>   [7] 23.5537941  1.1559919  7.5178596 12.0929481  1.5892683  2.4519694 #>  [13]  8.3260290 19.4785374  1.7083049  2.3059205  5.8144531  2.4128093 #>  [19]  1.9009554  2.0981295  9.4629460  1.9365616  1.4749157  2.8444938 #>  [25]  1.6158554 18.2262342  2.6159180  3.3497217  1.1298229  5.8995296 #>  [31] 13.7773149  1.4174816  8.1052321  1.4243713  3.4226776  2.4746980 #>  [37]  5.4363602  0.9433840  1.2592593  2.0023555  4.8687136  2.1809726 #>  [43]  2.8853197  0.5513268  1.2742729  0.5234704  2.0087010  2.0144503 #>  [49]  3.0103167  0.4141786  2.4364151  3.8873139  3.8328531  9.3777389 #>  [55] 21.4909498  2.0936552  3.7614437  5.1337249  1.8390138  3.8176140 #>  [61]  1.3488076  4.9420678  3.6986384  8.0825412  1.5944111 12.8649700 #>  [67] 16.2877513  2.4906081  1.1979778  3.1407346  2.9762147  2.4923583 #>  [73] 11.6523066  3.5704392  1.0322803  2.1157487  7.5791312  6.0520588 #>  [79]  3.7190986  2.7119610  3.8484269  1.6903426  1.8045329  5.5456868 #>  [85]  3.4244171  1.1381329  4.1207771  3.3161871  3.1485837  3.4616060 #>  [91]  3.9149325  4.5156349  4.0422856  0.8972903  0.8957929  4.6789328 #>  [97] 24.2444269  2.0731704  2.3035787 12.4289878 pnig(0.4, delta = 0, mu = 5, sigma = 1, nu = 1) #> [1] 0.01597497 qnig(0.8, delta = 0, mu = 5, sigma = 1, nu = 1) #> [1] 7.390234 plot(function(x){dnig(x, delta = 0, mu = 5, sigma = 1, nu = 1)}, main = \"Normal inverse-Gaussian density\", ylab = \"Probability density\", xlim = c(0,10))"},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"plot the density of noise (for stationary) — plot.ngme_noise","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"plot density noise (stationary)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"","code":"# S3 method for ngme_noise plot(x, y = NULL, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"x ngme_noise y another ngme_noise ... ...","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"plot","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/plot.ngme_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot the density of noise (for stationary) — plot.ngme_noise","text":"","code":"plot(noise_nig(mu=1, sigma=2, nu=1))"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ngme object — print.ngme","title":"Print ngme object — print.ngme","text":"Print ngme object","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ngme object — print.ngme","text":"","code":"# S3 method for ngme print(x, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ngme object — print.ngme","text":"x ngme object ... ignored","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ngme object — print.ngme","text":"list (noise specifications)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ngme model — print.ngme_model","title":"Print ngme model — print.ngme_model","text":"Print ngme model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ngme model — print.ngme_model","text":"","code":"# S3 method for ngme_model print(x, padding = 0, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ngme model — print.ngme_model","text":"x ngme model object padding number white space padding front ... ...","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ngme model — print.ngme_model","text":"list (model specifications)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ngme noise — print.ngme_noise","title":"Print ngme noise — print.ngme_noise","text":"Print ngme noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ngme noise — print.ngme_noise","text":"","code":"# S3 method for ngme_noise print(x, padding = 0, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ngme noise — print.ngme_noise","text":"x noise object padding number white space padding front ... ...","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/print.ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ngme noise — print.ngme_noise","text":"list (noise specifications)","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate latent process with noise — simulate.ngme_model","title":"Simulate latent process with noise — simulate.ngme_model","text":"Simulate latent process noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate latent process with noise — simulate.ngme_model","text":"","code":"# S3 method for ngme_model simulate(object, nsim = 1, seed = NULL, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate latent process with noise — simulate.ngme_model","text":"object ngme model specified f() function nsim ignored seed seed ... ignored","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate latent process with noise — simulate.ngme_model","text":"realization latent model","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate latent process with noise — simulate.ngme_model","text":"","code":"B_sigma <- matrix(1:10 / 10, nrow=10) simulate(noise_nig(n = 10, B_sigma = B_sigma)) #>  [1]  0.86412296 -0.62814398  0.02549067  0.88130107 -1.21620929  0.52899139 #>  [7]  0.21418783  0.88913383  0.35740016 -0.10842627 #> attr(,\"noise\") #> Noise type - nig #> Noise parameters:  #>     mu = 0 #>     sigma = 1 #>     nu = 1 simulate(noise_normal(theta_sigma = 1.5, B_sigma = B_sigma)) #>  [1] -1.0631319622  2.1847964844 -2.0558076615 -1.0041441609  2.4453208742 #>  [6] -1.4094954133  3.2551408062 -5.2203035111 -0.0164223796  0.0005910993 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 4.48 simulate(f(1:10, model = \"ar1\", theta_K = 0.4, noise = noise_nig())) #>  [1] -0.10044507 -0.51375358 -0.97384082 -0.01486735  0.65452376  0.10647473 #>  [7]  0.28569921  4.46710406  1.94664503  2.05664963 #> attr(,\"noise\") #> Noise type - nig #> Noise parameters:  #>     mu = 0 #>     sigma = 1 #>     nu = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate ngme noise — simulate.ngme_noise","title":"Simulate ngme noise — simulate.ngme_noise","text":"Simulate ngme noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate ngme noise — simulate.ngme_noise","text":"","code":"# S3 method for ngme_noise simulate(object, nsim = 1, seed = NULL, ...)"},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate ngme noise — simulate.ngme_noise","text":"object ngme noise object nsim ignored seed seed ... ignored","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate ngme noise — simulate.ngme_noise","text":"realization ngme noise","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/simulate.ngme_noise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate ngme noise — simulate.ngme_noise","text":"","code":"simulate(noise_normal(sd = 5, n = 10)) #>  [1]  0.2014276 -0.0402101 -0.7927967 -2.1978812  1.0487236 -0.5522832 #>  [7] -1.6628832 -0.8939876 -1.1953027 -1.5680917 #> attr(,\"noise\") #> Noise type - normal #> Noise parameters:  #>     sigma = 1"},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace plot of ngme fitting — traceplot","title":"Trace plot of ngme fitting — traceplot","text":"Trace plot ngme fitting","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace plot of ngme fitting — traceplot","text":"","code":"traceplot(ngme, param, f_index = 0, param_index = 1, transform = identity)"},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace plot of ngme fitting — traceplot","text":"ngme ngme object param parameter name f_index index process, 0 stands fixed effects measurement noise param_index paramter index non-stationary transform transformation","code":""},{"path":"https://davidbolin.github.io/ngme2/reference/traceplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace plot of ngme fitting — traceplot","text":"traceplot","code":""},{"path":"https://davidbolin.github.io/ngme2/news/index.html","id":"ngme2-development-version","dir":"Changelog","previous_headings":"","what":"ngme2 (development version)","title":"ngme2 (development version)","text":"First version package","code":""}]
