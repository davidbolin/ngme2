---
title: "Ngme2 AR(1) model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ngme2 AR(1) model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we will introduce the autoregressive model in `ngme2`.

## Description

An **autoregressive model of order 1 (AR(1))** specifies that the output variable depends linearly on its own previous values and on a stochastic term.
The simplest AR model is an AR(1) model, which is given by:

\begin{align}
X_1 &= \epsilon_1, \\
X_i &= \rho X_{i-1} + \epsilon_i, \; i = 2, \dots , n,
\end{align}
where $|\rho| < 1$, $\epsilon_1, ..,\epsilon_n$ is either i.i.d. **NIG** or **Gaussian** noise.

It is easy to verify that
$$ K{\bf X} = \boldsymbol\epsilon,$$
where
${\bf X} = (X_1, \dots, X_n)$,  ${\boldsymbol \epsilon} = (\epsilon_1, \dots, \epsilon_n)$, and
$$
K =
  \begin{bmatrix}
    1 \\
    -\rho &  1 \\
    & \ddots & \ddots \\
    & & -\rho &  1
  \end{bmatrix}.
$$

## Usage

Use the `f(model="ar1")` (in formula) to specify a AR(1) model.
Notice that AR(1) process is only well defined in the integer mesh (it can have gaps), see the following examples:

```{r ar-usage}
library(ngme2)
load_all()
set.seed(16)

m1 <- f(2001:2004, model="ar1", rho=-0.5, noise = noise_normal(), eval=T)
# check the operator matrix
m1$operator$K
```

## Simulation

Simulating an AR(1) model with `ngme2` is simple. Just pass the corresponding model into `simulate` function.

```{r ar-simulation, fig.align="center"}
n_obs <- 1000
day <- 1:n_obs
load_all()
ar1_model <- f(day, model="ar1", rho = 0.5,
  noise = noise_nig(mu = -3, sigma = 4, nu=0.4), eval=T)
W <- simulate(
  ar1_model, seed = 16
)

# check the acf to see the correlation
acf(W)
```

## Estimation

In this part we will show how to estiamte the AR model using `ngme` function.
Here we can use `control_opt` to modify the control variables for the `ngme`.
See `?control_opt` for more optioins.

```{r ar-estimation, fig.align="center", cache=TRUE}
x1 = runif(n_obs)
x2 = rexp(n_obs)
beta <- c(-1, 2)
X <- (model.matrix(~0+x1+x2))  # design matrix
# add some fixed effects and measurement nosie
Y <- as.numeric(X %*% beta) + W + rnorm(n_obs, sd = 1)

# Fit the model with the AR1 model
load_all()
ngme_out <- ngme(
  Y ~ 0+x1 + x2 + f(
    1:n_obs,
    # fix_W = T, W = W,
    name = "my_ar",
    model = "ar1",
    noise = noise_nig(),
    debug=T
  ),
  data = data.frame(x1=x1, x2=x2, Y=Y),
  control_opt = control_opt(
    burnin = 100,
    iterations = 100,
    std_lim = 0.6,
    n_parallel_chain = 4,
    max_absolute_step = 10,
    max_relative_step = 10,
    stop_points = 10,
    print_check_info = FALSE,
    seed = 3
  )
)
ngme_out

# traceplot of fixed effects and measurementn noise
traceplot(ngme_out)

# traceplot of ar1 model
traceplot(ngme_out, "my_ar")

# comparing the density of the noise estimated and the noise simulated
plot(ngme_out$replicates[[1]]$models[[1]]$noise,
  noise_nig(mu = -3, sigma = 4, nu=0.4))
```

```{r}
load_all()
```