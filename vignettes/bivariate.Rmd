---
title: "Bivariate models in Ngme2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bivariate models in Ngme2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Description

In this vignette, we will introduce the bivariate model which supports modeling two field and their correlation jointly.

The `f` function specification is similar to ordinary model, but with two fields.
Extra arguments for the `f` are:

1. `group`: a vector of labels to indicate the group of different observations. If `group` is provided in `ngme()` function, no need to provide in `f()` function again.

2. `sub_models`: characters of length 2 with names equal to one of the labels in `group`, specifying the sub-models for the two fields. e.g. `c(field1="rw1", field2="ar1")`

## Model structure

to-do

## Usage by example

It's better to understand with one exmaple. Say you have an time series model over 5 year from 2001 to 2005, with 2 fields *temperature* and *precipitation*. You want to model the two fields jointly, and their correlation. The data should look like

```{r toy-data}
temp <- c(32, 33, 35.5, 36); year_temp <- c(2001, 2002, 2003, 2004)
precip <- c(0.1, 0.2, 0.5, 1, 0.2); year_pre <- c(2001, 2002, 2003, 2004, 2005)

# bind them since we want to model them jointly
y <- c(temp, precip); year <- c(year_temp, year_pre)
labels <- c(rep("temp", 4), rep("precip", 5)) # group is label for 2 fields

x1 <- 1:9
data <- data.frame(y, year, x1, labels)
data
```

The model specification is like this, notice the way to specify 2 sub_models:

```{r toy-model}
load_all()
# 1st way: simply put model types, using both c() and list() are ok
bv1 <- f(
  year, model = "bv",
  # sub_models = c(precip="ar1", temp="rw1"),
  sub_models = list(precip="ar1", temp="rw1"),
  group = labels, # can be provided in ngme()
  noise = noise_normal(),
  eval=T # can be ignored in ngme()
)
bv1

# 2nd way: allow more argument for sub_models
bv2 <- f(
  year, model = "bv",
  sub_models = list(
    precip=list(model="ar1", rho=0.5),
    temp=list(model="rw1")
  ),
  group = labels, # can be provided in ngme()
  noise = noise_normal(),
  eval=T # can be ignored in ngme()
)
bv2
```

The previous example assume the common noise across the two fields.

But the bivariate model also allows for different driven nosie for each field, e.g. `precip` is driven by `nomral` noise, while `temp` is driven by `nig` noise. The model can be specified as:

```{r toy-model-noise}
load_all()
bv3 <- f(
  year, model = "bv",
  sub_models = list(precip="ar1", temp="rw1"),
  group = labels, # can be provided in ngme()
  noise = list(
    precip = noise_normal(),
    temp = noise_nig()
  ),
  eval = T # can be ignored in ngme()
)
bv3
simulate(bv3)
```

*Estimation example*

```{r}
load_all()
data
# noise_nig_simple() have 1 V
out = ngme(
  y ~ 0 + fe(~1, which_group = "temp") +
  fe(~1+x1, which_group = "precip") +
  f(year, model="rw1", which_group = "temp") +
  f(year,
    model = "bv",
    sub_models = list(precip="ar1", temp="rw1"),
    group = labels, # can be provided in ngme()
    noise = list(
      precip = noise_nig_simple(), temp = noise_nig(), #warning
      share_V = FALSE  #type-3
    )
  ),
  data = data,
  group = data$labels,
  control_opt = control_opt(
    estimation = T,
    iterations = 10
  )
)
out
out$replicates[[1]]$X
```

## A 2d matern example

1. Simulation

```{r}
load_all()
library(INLA)
pl01 <- cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5)
mesh <- inla.mesh.2d(
  loc.domain = pl01, cutoff = 0.2,
  max.edge = c(1,10)
)
mesh$n
n_obs <- 300
long <- runif(n_obs, 0, 10)
lat <- runif(n_obs, 0, 5)
group <- c(rep("sal", n_obs/2), rep("temp", n_obs/2))
head(data)

load_all()
true_model <- f(
    ~long + lat,
    mesh = mesh,
    model = "bv",
    sub_models = list(
      sal="matern",
      temp="matern"
    ),
    group = group,
    # noise = noise_nig(
    #   mu=-2, sigma=2, nu=1
    # ),
    noise = list(sal = noise_nig(
      mu = -2, sigma=1, nu=1
    ), temp = noise_nig(
      mu = 2, sigma=2, nu=0.5
    )),
    eval=T
  )
W <- simulate(true_model)
Y <- as.numeric(true_model$A %*% W); Y <- Y + rnorm(length(Y))
data <- data.frame(Y, long, lat)
```

2. Estimation

```{r}
load_all()
out <- ngme(
  Y ~ f(
    ~long + lat,
    mesh = mesh,
    model = "bv",
    name = "bv",
    sub_models = list(sal="matern", temp="matern"),
    group = group,
    debug=T,
    # noise = noise_nig()
    # noise = list(sal = noise_nig(), temp = noise_nig())
    noise = list(sal = noise_normal(), temp = noise_normal())
  ),
  data = data,
  control_opt = control_opt(
    estimation = T,
    iterations = 300,
    n_parallel_chain = 1,
    verbose = T,
    print_check_info = F
  )
)
out
str(out$replicates[[1]]$models[[1]]$noise)
traceplot(out, "bv")
out$replicates[[1]]$models[[1]]$noise$bv_noises[[2]]$h
```

## Correlated measurement noise

```{r}
load_all()

Y <- 1:5
loc1 <- c(2, 1, 1, 3, 2)
group <- c("s", "t", "s", "t", "t")

load_all()
# check the model
f(loc1, model="bv",
  sub_models = c(t="ar1", s="rw1"),
  group = group,
  which_group = c("t", "s"),
  eval = TRUE
)

noise_normal(
  corr_measurement = TRUE,
  index_corr = c(1,1,2,3,2)
)

# ngme
load_all()
m1 <- ngme(
  Y ~ f(
    loc1, model="bv",
    sub_models = c(t="ar1", s="rw1"),
  ),
  family = noise_normal(
    corr_measurement = TRUE,
    index_corr = c(1,1,2,3,2)
  ),
  group = group,
  data = data.frame(Y = Y, loc1 = loc1),
  control_opt = control_opt(
    estimation = T,
    iterations = 2,
    n_parallel_chain = 1
  )
)
m1
m1$replicates[[1]]$n_merr

```

1. simulation

```{r}
load_all()
n_obs <- 600
W <- simulate(f(1:n_obs, model="iid", eval=TRUE))

Cov_eps <- matrix(c(1, -0, -0, 1), nrow=2)
Cov_eps <- Cov_eps %x% diag(n_obs / 2)

# e~N(0, Cov_eps)
e <- MASS::mvrnorm(1, rep(0, n_obs), Cov_eps)
Y <- W + e

plot(head(e, n_obs/2), type="l")
lines(tail(e, n_obs/2), col="red")

load_all()
out <- ngme(
  Y ~ 0 + f(
    1:n_obs,
    model="ar1"
  ),
  family = noise_normal(
    fix_theta_sigma = T,
    corr_measurement = TRUE,
    index_corr = c(1: (n_obs/2), 1: (n_obs/2))
  ),
  data = data.frame(Y = Y),
  control_opt = control_opt(
    estimation = T,
    iterations = 300,
    n_parallel_chain = 1
  )
)
out
traceplot(out)
```

```{r}
library(devtools)
load_all()
n_obs <- 2000
W <- simulate(f(1:n_obs, rho = 0.5, model="ar1", eval=TRUE))

Cov_eps <- matrix(c(1, -0.9, -0.9, 1), nrow=2)
Cov_eps <- Cov_eps %x% diag(n_obs / 2)

# e~N(0, Cov_eps)
L <- t(chol(Cov_eps))
e <- L %*% rnorm(n_obs)

x1 <- rexp(n_obs)
x2 <- rnorm(n_obs)
Y <-  W +e + x1 * (-3) + x2 * 1.5

plot(head(e, n_obs/2), type="l")
lines(tail(e, n_obs/2), col="red")

# load_all()
out <- ngme(
  Y ~ 0 + x1 + x2+ f(
    1:n_obs,
    # fix_W = T, W = W,
    model="ar1"
  ),
  family = noise_normal(
    # fix_theta_sigma = T,
    corr_measurement = TRUE,
    index_corr = c(1: (n_obs/2), 1: (n_obs/2))
    # index_corr = "field1"
  ),
  data = data.frame(Y, x1, x2),
  control_opt = control_opt(
    estimation = T,
    iterations = 500,
    n_parallel_chain = 1
  )
)
traceplot(out, "field1")
traceplot(out )
out

```
