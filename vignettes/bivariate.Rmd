---
title: "Bivariate models in Ngme2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bivariate models in Ngme2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Description

In this vignette, we will introduce the bivariate model which supports modeling two field and their correlation jointly.

The `f` function specification is similar to ordinary model, but with two fields.
Extra arguments for the `f` are:

1. `group`: a vector of labels to indicate the group of different observations. If `group` is provided in `ngme()` function, no need to provide in `f()` function again.

2. `sub_models`: characters of length 2 with names equal to one of the labels in `group`, specifying the sub-models for the two fields. e.g. `c(field1="rw1", field2="ar1")`

## Model structure

to-do

## Usage by example

It's better to understand with one exmaple. Say you have an time series model over 5 year from 2001 to 2005, with 2 fields *temperature* and *precipitation*. You want to model the two fields jointly, and their correlation. The data should look like

```{r toy-data}
temp <- c(32, 33, 35.5, 36); year_temp <- c(2001, 2002, 2003, 2004)
precip <- c(0.1, 0.2, 0.5, 1, 0.2); year_pre <- c(2001, 2002, 2003, 2004, 2005)

# bind them since we want to model them jointly
y <- c(temp, precip); year <- c(year_temp, year_pre)
labels <- c(rep("temp", 4), rep("precip", 5)) # group is label for 2 fields

data <- data.frame(y, year, labels); data
```

The model specification is like this, notice the way to specify 2 sub_models:

```{r toy-model}
load_all()
# 1st way: simply put model types, using both c() and list() are ok
bv1 <- f(
  year, model = "bv",
  # sub_models = c(precip="ar1", temp="rw1"),
  sub_models = list(precip="ar1", temp="rw1"),
  group = labels, # can be provided in ngme()
  noise = noise_normal(),
  eval=T # can be ignored in ngme()
)
bv1

# 2nd way: allow more argument for sub_models
bv2 <- f(
  year, model = "bv",
  sub_models = list(
    precip=list(model="ar1", rho=0.5),
    temp=list(model="rw1")
  ),
  group = labels, # can be provided in ngme()
  noise = noise_normal(),
  eval=T # can be ignored in ngme()
)
bv2
```

The previous example assume the common noise across the two fields.

But the bivariate model also allows for different driven nosie for each field, e.g. `precip` is driven by `nomral` noise, while `temp` is driven by `nig` noise. The model can be specified as:

```{r toy-model-noise}
load_all()
bv3 <- f(
  year, model = "bv",
  sub_models = list(precip="ar1", temp="rw1"),
  group = labels, # can be provided in ngme()
  noise = list(
    precip = noise_normal(),
    temp = noise_nig()
  ),
  eval = T # can be ignored in ngme()
)
bv3
simulate(bv3)
# bv3$noise$h
```

*Estimation example*

```{r}
load_all()
ngme(
  y ~ 0 + fe(~1+x, which_group = "temp") +
  fe(~x, which_group = "precip") +
  f(year,
    model = "bv",
    sub_models = list(precip="ar1", temp="rw1"),
    group = labels, # can be provided in ngme()
    noise = list(precip = noise_normal(), temp = noise_nig())
  ),
  data = data,
  control_opt = control_opt(
    estimation = T,
    iterations = 10
  )
)
```

## A 2d matern example

```{r}
load_all()
library(INLA)
pl01 <- cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5)
mesh <- inla.mesh.2d(
  loc.domain = pl01, cutoff = 0.2,
  max.edge = c(2,10)
)
mesh$n
n_obs <- 100
long <- runif(n_obs, 0, 10)
lat <- runif(n_obs, 0, 5)
Y_sal <- rnorm(50); Y_temp <- rnorm(50)
group <- c(rep("sal", 50), rep("temp", 50))

data <- data.frame(Y=c(Y_sal, Y_temp), long, lat)
head(data)

load_all()
out <- ngme(
  Y ~ f(
    ~long + lat,
    mesh = mesh,
    model = "bv",
    sub_models = list(sal="matern", temp="matern"),
    group = group,
    noise = list(sal = noise_nig(), temp = noise_nig())
  ),
  data = data,
  control_opt = control_opt(
    estimation = T,
    iterations = 10,
    verbose = T,
    print_check_info = F
  )
)
out$replicates[[1]]$models[[1]]$noise$bv_noises[[2]]$h
```
