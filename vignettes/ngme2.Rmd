---
title: "Ngme2 - A new Flexible R Package for Latent non-Gaussian Models"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Ngme2 - A new Flexible R Package for Latent non-Gaussian Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(10)
```

## Introduction

In this vignette we provide a brief introduction to the `ngme2` package.

`ngme2` is the updated version of `ngme` (https://github.com/davidbolin/ngme), a package for estimating latent non-Gaussian models.
It follows a **3-layer structure** in design (the general block model, latent process models, and noises) for specifying the whole statistical model.
The latent process defines different operator structure, and the block model collects them together with the fixed effects and measurement noise.

### 1 Features

1. Support spatial models like Matern model with non-Gaussian noise.
2. Support models for temporal data like **AR1** and **random walk** of order 1 and 2.
3. Support replicates at same locations.
4. Support prediction at unknown locations.
5. Comparing to the previous version, it now supports multiple stochastic processes in the latent model.


### 2 Model Framework

The package `ngme2` provides methods for mixed effect models both for single response
variable case and multivariate response case (not yet).

1.For **single response** case, it has the following form:
$$
\begin{aligned}
Y = {\bf X}^{\top} {\bf \beta} + \sum_j {\bf A}_j W_j({\bf t}) + \epsilon.
\end{aligned}
$$

Here,

- $Y$ is the response variable,
- ${\bf X}$ is the matrix of fixed effects explanatory variables,
- ${\bf \beta}$ is the matrix of fixed effects coefficients,
- ${\bf A}_j$ is the observation matrix for each process,
- $W_j(t_j)$ is specified as a stochastic process,
- $\epsilon$ is measurement error.

Here, the process $W$ follows ${\bf K} W = z$,
where $z$ is either Gaussian or non-Gaussian noise.
${\bf K}$ is the operator matrix.

Here is a simple template for using the core function `ngme` to model the single response:

    ngme(
      formula=Y ~ x1 + x2 + f(index, model="ar", noise="nig"),
      data=data.frame(Y=Y, x1=x1, x2=x2, index=index),
      noise = noise_normal()
    )

Here, function `f` is for modeling the stochastic process W with Gaussian or non-Gaussian noise,
we will discuss this later.
`noise` stands for the measurement noise distribution. In this case, the model will have a Gaussian likelihood.

For **multivariate response** case, it has the following form:

Here is a another template for using the core function `ngme` to model the bivariate response:

    ngme(
      formula=Y1 | Y2 ~ x1 + x2 + f(index, model="ar", noise="nig") | f(time, model="matern"),
      data=data.frame(Y=Y, x1=x1, x2=x2, index=index, time=time),
      family="normal"
    )

### 3 Non-Gaussian Model

Here we assume the non-Gaussian process is a type-G Lévy process,
whose increments can be represented as location-scale mixtures:
$$\gamma + \mu V + \sigma \sqrt{V}Z,$$
where $\gamma, \mu, \sigma$ are parameters, $Z\sim N(0,1)$ and is independent of $V$, and $V$ is a positive infinitely divisible random variable.
It results in the following form, where $K$ is the operator part:

$$
KW|V \sim N(\gamma + \mu V, \sigma^2 \, diag(V)),
$$
also, $\mu$ and $\sigma$ can be non-stationary.

In `ngme2`, we focus mainly on the normal inverse Gaussian (NIG) model.
See `?nig` for more details.

### 4 Parameter Estimation

1. Ngme2 does maximum likelihood estimation through preconditioned stochastic gradient descent.
2. Multiple chains are run in parallel for better convergence checks.

<!-- See `vignette()` for more details. -->

## Ngme Model Structure

### Specify noise with `ngme_noise` object

The `ngme_noise` object is the most fundamental structure in `ngme2`.
The object is used to specify the driving noise of the stochastic process and the measurement noise.

For now we support two noises, one is **normal** noise, the other is the **NIG** noise.

The R class `ngme_noise` has the following interface:

```{r noise}
library(ngme2)

noise_normal(sigma = 1)                 # normal noise
noise_nig(mu = 1, sigma = 2, nu = 1) # nig noise
noise_nig(            # non-stationary nig noise
  B_mu=matrix(c(1:10), ncol=2),
  theta_mu = c(1, 2),
  B_sigma=matrix(c(1:10), ncol=2),
  theta_sigma = c(1,2),
  nu = 1)
```

The 3rd example is the non-stationary NIG noise,
where $\mu = \bf B_{\mu} \bf \theta_{\mu}$, and $\sigma = \exp(\bf B_{\sigma} \bf \theta_{\sigma})$.

```
ngme_noise(
  type,           # the type of noise
  theta_mu,       # mu parameter
  theta_sigma,    # sigma parameter
  theta_V,        # nu parameter
  B_mu,           # basis matrix for non-stationary mu
  B_sigma         # basis matrix for non-stationary sigma
)
```
It will construct the following noise structure:

\[
  - \mathbf{\mu} + \mathbf{\mu} V + \mathbf{\sigma} \sqrt{V} Z
\]

where $\mu = \bf B_{\mu} \bf \theta_{\mu}$, and $\sigma = \exp(\bf B_{\sigma} \bf \theta_{\sigma})$.
In this case, we can recover gaussian noise by setting **type="normal** and ignoring **theta_mu** and **theta_V**.
Or we can simply use helper function `noise_normal(sd=1)`

### Specify stochastic process with `f` function

The middle layer is the stochastic process, in R interface, it is represented as a `f` function.
The process can be specified by different noise structure. See `?ngme_model_types()` for more
details.

Some examples of using `f` function to specify `ngme_model`:

```{r f_model}
ngme2::f(1:10, model = "ar1",
  noise = noise_nig(), theta_K = 0.5)
```

One useful model would be the SPDE model with Gaussian or non-Gaussian noise, see the vignette
\code{vignette("SPDE-approach", package = "ngme2")} for details.

### Specifying latent models with formula in `ngme`

The latent model can be specified additively as a **formula** argument in `ngme` function
together with **fixed effects**.

We use R formula to specify the latent model.
We can specify the model using `f` within the formula.

For example, the following formula

```{r}
formula <- Y ~ x1 + f(
    x2,
    model = "ar1",
    noise = noise_nig(),
    theta_K = 0.5
  ) + f(
    model = model_rw(1:5, order=1, circular = TRUE),
    noise = noise_normal()
  )
```

corresponds to the model

$$
Y = \beta_0 + \beta_1 x_1 + W_1(x_2) + W_2(x_3) + \epsilon,
$$
where $W_1$ is an AR(1) process, $W_2$ is a random walk 1 process.
$x_2$ is random effects.. .
By default, we have intercept.
The distribution of the measurement error $\epsilon$ is given in the `ngme` function.

The entire model can be fitted, along with the specification of the distribution of the measurement error through the `ngme` function:

```{r ngme_block}
ngme(
  formula = formula,
  family = noise_normal(sigma = 0.5),
  data = data.frame(Y = 1:5, x1 = 2:6, x2 = 3:7),
  control = ngme_control(
    estimation = FALSE
  )
)
```

It gives the `ngme` object, which has three parts:

1. Fixed effects (intercept and x1)
2. Measurement noise (normal noise)
3. Latent models (contains 2 models, ar1 and rw1)

We can turn the `estimation = TRUE` to start estimating the model.

## A simple example - AR1 process with nig noise

Now let's see an example of an AR1 process with nig noise.
The process is defined as

$$
W_i = \alpha W_{i-1} + \epsilon_i,
$$
Here, $\epsilon_1, ..,\epsilon_n$ is the iid **NIG** noise.
And, it is easy to verify that
$$ K{\bf W} = \boldsymbol\epsilon,$$
where
$$
K =
  \begin{bmatrix}
    \alpha \\
    -1 &  \alpha \\
    & \ddots & \ddots \\
    & & -1 &  \alpha
  \end{bmatrix}
$$

```{r simulate_ar1}
n_obs <- 500
sigma_eps <- 0.5
alpha <- 0.5
mu = 2; delta = -mu
sigma <- 3
nu <- 1

# First we generate V. V_i follows inverse Gaussian distribution
trueV <- ngme2::rig(n_obs, nu, nu, seed = 10)

# Then generate the nig noise
noise <- delta + mu*trueV + sigma * sqrt(trueV) * rnorm(n_obs)
trueW <- Reduce(function(x,y){y + alpha*x}, noise, accumulate = T)
Y = trueW + rnorm(n_obs, mean=0, sd=sigma_eps)

# Add some fixed effects
x1 = runif(n_obs)
x2 = rexp(n_obs)
beta <- c(-3, -1, 2)
X <- (model.matrix(Y ~ x1 + x2))  # design matrix
Y = as.numeric(Y + X %*% beta)
```

Now let's fit the model using `ngme`. Here we can use `ngme_control` to modify the
control variables for the `ngme`. See `?ngme_control` for more optioins.

```{r fit_ar1, cache=TRUE}
# # Fit the model with the AR1 model
ngme_out <- ngme(
  Y ~ x1 + x2 + f(
    1:n_obs,
    model = "ar1",
    noise = noise_nig(),
    theta_K = 0.9  # starting point for the alpha (parameter of K)
  ),
  data=data.frame(x1=x1, x2=x2, Y=Y),
  control = ngme_control(
    burnin = 100,
    iterations = 1000,
    std_lim = 0.4,
    gibbs_sample = 5,
    n_parallel_chain = 4,
    stop_points = 10,
    print_check_info = FALSE
  ),
  seed = 3
)
```

Next we can read the result directly from the object.

```{r out}
ngme_out
```

As we can see, the model converges in 350 iterations.
The estimation results are close to the real parameter.

We can also use the `traceplot` function to see the estimation traceplot.
```{r traceplot, fig.align="center", fig.width=6,fig.height=6,  fig.cap="Parameters of the AR1 model"}
library(ggplot2)
library(grid)
library(gridExtra)
pl <- lapply(c("alpha", "mu", "sigma", "nu"), function(.x)
  traceplot(ngme_out, param = .x, f_index = 1));
marrangeGrob(pl, nrow=2, ncol=2)
```

We can also do a density comparison with the estimated noise and the true NIG noise:

```{r compare-density}
plot(
  ngme_out$latents[[1]]$noise,
  noise_nig(mu = mu, sigma = sigma, nu = nu)
)
```

## Paraná dataset

```{r load-packages}
library(INLA)
library(splancs)
library(lattice)
library(ggplot2)
library(grid)
library(gridExtra)
library(viridis)
```

The rainfall data from Paraná (Brazil) is collected by the National Water Agency in Brazil (Agencia Nacional de Águas, ANA, in Portuguese).
ANA collects data from many locations over Brazil, and all these data are freely available from the ANA website (http://www3.ana.gov.br/portal/ANA).

We will briefly illustrate the command we use, and the result of the estimation.

```{r read-parana}
data(PRprec)
data(PRborder)

# Create INLA mesh
coords <- as.matrix(PRprec[, 1:2])
prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100))
prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2)

# monthly mean at each location
Y <- rowMeans(PRprec[, 12 + 1:31]) # 2 + Octobor

ind <- !is.na(Y) # non-NA index
Y <- Y_mean <- Y[ind]
coords <- as.matrix(PRprec[ind, 1:2])
seaDist <- apply(spDists(coords, PRborder[1034:1078, ],
  longlat = TRUE
), 1, min)
```

Plot the data:

```{r plot-data, message=FALSE,fig.width=6,fig.height=6,fig.align='center', echo=FALSE, fig.cap="Mean of the rainfall in Octobor 2012 in Paraná"}
ggplot() +
  geom_point(aes(
    x = coords[, 1], y = coords[, 2],
    colour = Y
  ), size = 2, alpha = 1) +
  scale_color_gradientn(colours = viridis(100)) +
  geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +
  geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[
    1034:1078,
    2
  ]), colour = "red")
```

```{r fit-parana, cache=TRUE}
# leave 0.1 Y as prediction area
# n <- length(Y)
# ind_pred <- sample(1:n, size = 0.1 * n)
# Y_pred <- Y[ind_pred]
# Y[ind_pred] <- NA

matern_spde <- model_matern(
  loc = coords,
  mesh = prmesh
)

out <- ngme(
  formula = Y ~ 1 +
    f(inla.group(seaDist), model = "rw1", circular=T, noise = noise_normal()) +
    f(model = matern_spde, noise = noise_normal()),
  data = list(
    Y = Y
  ),
  family = noise_nig(),
  control = ngme_control(
    estimation = T,
    iterations = 1000,
    n_slope_check = 4,
    stop_points = 10,
    std_lim = 0.1,
    n_parallel_chain = 4,
    print_check_info = FALSE
  ),
  seed = 16
)
out

# traceplots

## fixed effects
traceplot(out, f_index = 0, param = "beta")
## measurement noise
traceplot(out, f_index = 0, param = "mu")
traceplot(out, f_index = 0, param = "sigma")
traceplot(out, f_index = 0, param = "nu")

## rw
traceplot(out, f_index = 1, param = "sigma")

## spde model
traceplot(out, f_index = 2, param = "kappa")
traceplot(out, f_index = 2, param = "sigma")
```

Parameter estimation results:

```{r est-result, echo=FALSE}
res1 <- data.frame(
  intercept    = format(out$beta, digits=3),
  noise_mu     = format(out$noise$theta_mu, digits=3),
  noise_sigma  = format(exp(out$noise$theta_sigma), digits=3),
  noise_nu     = format(out$noise$theta_V, digits=3),
  rw_sigma     = format(out$latents[[1]]$noise$theta_sigma, digits=3),
  ma_kappa     = format(exp(out$latents[[2]]$theta_K), digits=3),
  ma_sigma     = format(exp(out$latents[[2]]$noise$theta_sigma), digits=3)
)
knitr::kable(res1, caption = "Estimations for the model")
```

### Prediction

```{r predict, cache=TRUE}
nxy <- c(150, 100)
projgrid <- rSPDE::rspde.mesh.projector(prmesh,
  xlim = range(PRborder[, 1]),
  ylim = range(PRborder[, 2]), dims = nxy
)

xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2]))

coord.prd <- projgrid$lattice$loc[xy.in, ]
plot(coord.prd, type = "p", cex = 0.1)
lines(PRborder)
points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = "red")

seaDist.prd <- apply(spDists(coord.prd,
  PRborder[1034:1078, ],
  longlat = TRUE
), 1, min)

# construct data
n_prd <- nrow(coord.prd)
Y2 <- c(Y, rep(NA, n_prd))
seaDist2 <- c(seaDist, seaDist.prd)

matern_spde <- model_matern(
  loc = rbind(coords, coord.prd),
  mesh = prmesh,
  index_NA = is.na(Y2)
)

# use previous estimation results by setting start=out
out2 <- ngme(
  formula = Y ~ 1 +
    f(inla.group(seaDist), model = "rw1", noise = noise_normal()) +
    f(model = matern_spde, noise = noise_nig()) +
    f(model = matern_spde, noise = noise_normal()),
  data = list(
    Y = Y2,
    seaDist = seaDist2
  ),
  family = noise_nig(),
  control = ngme_control(
    estimation = F,
    iterations = 1000,
    n_slope_check = 4,
    stop_points = 10,
    std_lim = 0.1,
    n_parallel_chain = 8,
    print_check_info = TRUE
  ),
  seed = 416,
  start = out
)
out2

# Now we plot prediction
lp <- attr(out2, "prediction")$lp
ggplot() +
  geom_point(aes(
    x = coord.prd[, 1], y = coord.prd[, 2],
    colour = lp[is.na(Y2)]
  ), size = 2, alpha = 1) +
  geom_point(aes(
    x = coords[, 1], y = coords[, 2],
    colour = Y_mean
  ), size = 2, alpha = 1) +
  scale_color_gradientn(colours = viridis(100)) +
  geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +
  geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[
    1034:1078,
    2
  ]), colour = "red")
```



