---
title: "Space-time (tensor product) model in Ngme2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Space-time (tensor product) model in Ngme2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Description

In this vignette, we will show how to fit a tensor product model using ngme2. One useful example of this kind of model is the separable space-time model.

The separable space-time model is defined by the Kronecker product between the precision matrices of the spatial and temporal random effects. Additional information about separable space-time models can be found in Cameletti et al. (2013).

The operator matrix $K$ of the tensor product model can be expressed by: $K = K_l \otimes K_r$ where $K_l$ and $K_r$ are the operator for the 2 sub-models.

## Usage

The R interface for tensor product model needs map as a list of 2 indices and 2 operators namely `first` and `second` to build the model.


The following is one simple example of how to build the space-time (1d location) model.

Here the mesh of the model will be ordered according to the order of the time index (year).

```{r setup, message=FALSE, warning=FALSE}
# load packages
library(INLA)
library(ngme2)

time = c(2001, 2001, 2003, 2002, 2003, 2002, 2001)
loc  = c(3, 2, 1, 1, 2, 2, 1)

m0 <- f(map=list(time, loc), model="tp", first=ar1(time), second=rw1(loc))
m0

# The map from the underlying mesh to our observations
m0$A
```

Here the 1st, 2nd, 7th object are from first year (column 1 to 3), the 3rd, 5th are from second year (column 4 to 6), and the 4th, 6th are from third year (column 7 to 9).

In general, we need to provide a list of 2 indices (from the data), and also provide the 2 meshes to the 2 underlying models separately (e.g. time and space).

Next we will see a useful AR(1) x Matern 2d example.

## Simulation - (AR1 x Matern 2d case)

Now let's turn to simualte and estimate the tensor-product model.

```{r}
##############################  simulation
set.seed(16)
mesh2d <- inla.mesh.2d(
  loc.domain = cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5),
  max.edge = c(2, 10)
)

# generate random loc for each n_ar
n_obs <- c(13, 22, 14, 20, 32) # observation for each year
year <- rep(2001:2005, times = n_obs)
x <- runif(sum(n_obs)) * 10; y <- runif(sum(n_obs)) * 5

true_model <- ngme2::f(
  map = list(year, ~x+y),
  model = "tp", name="tp",
  first = ar1(year),
  second = matern(mesh = mesh2d)
)

W <- simulate(true_model)
AW <- as.numeric(true_model$A %*% W)
n_obs <- length(AW)
Y_obs <- AW + rnorm(n_obs, sd=0.5)
df <- data.frame(year, x, y, Y_obs)

##############################  estimation
out <- ngme(
  Y_obs ~ 0 +
  f(map = list(year, ~x+y),
    model="tp",
    name="tp",
    first = ar1(year),
    second = matern(mesh = mesh2d),
    control = control_f(numer_grad = T)
  ),
  data = df,
  family = "normal",
  control_opt = control_opt(
    iterations = 10,
    n_parallel_chain = 1,
    estimation = F,
    verbose = T,
    stepsize = 1
  ),
  debug = F
)
# out

# cross_validation(out)
# traceplot(out, "tp")
# traceplot(out, "tp")
```
