---
title: "Space-time (tensor product) model in Ngme2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Space-time (tensor product) model in Ngme2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

In this vignette, we will show how to fit the separable space-time (tensor product) model using Ngme2.

The separable space-time model is defined by the Kronecker product between the precision matrices of the spatial and temporal random effects. Additional information about separable space-time models can be found in Cameletti et al. (2013).

## Model structure

Remember that, for the univariate model, it can be written as:
$$ \mathcal{L} \mathbf{X}(s) = \mathcal{M},$$ where $\mathcal{L}$ is some operator, $\mathcal{M}$ represents the noise (Gaussian or non-Gaussian).

After we discretize (see e.g. [Ngme2 Matern SPDE model](SPDE-model.html) for details) the operator $\mathcal{L}$, we will get the operator matrix $K$.

In the tensor product model, the operator matrix $K$ can be constructed by other two operator matrices of two models:

$$K = K_l \otimes K_r.$$

## One simple example

The R interface for tensor product model requries map as a list of 2 indices and 2 operators namely `first` and `second` to build the model.

The following is one simple example of how to build the space-time (1d location) model.

Here the mesh of the model will be ordered according to the order of the time index (year).

```{r setup, message=FALSE, warning=FALSE}
# load packages
library(INLA)
library(ngme2)

time = c(2001, 2001, 2003, 2002, 2003, 2002, 2001)
loc  = c(3.3, 2.0, 1.0, 1.0, 2.0, 2.0, 1.0)

m0 <- f(
  map=list(time, loc),
  model="tp",
  first=list(model="ar1"),
  second=list(model="rw1")
)
m0

# The map from the underlying mesh to our observations
m0$A
```

Here the 1st, 2nd, 7th object are from first year (column 1 to 3), the 3rd, 5th are from second year (column 4 to 6), and the 4th, 6th are from third year (column 7 to 9).

In general, we need to provide a list of 2 indices (from the data), and also provide the 2 meshes to the 2 underlying models separately (e.g. time and space).

Next we will see a useful AR(1) x Matern 2d example.

## A AR(1) x Matern 2d example

Now let's turn to simualte and estimate the tensor-product model.

```{r ar-matern, cache=TRUE}
##############################  simulation
set.seed(16)
mesh2d <- inla.mesh.2d(
  loc.domain = cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5),
  max.edge = c(1, 10),
  cutoff = 0.1
)
mesh2d$n

# generate random loc for each year
n_obs <- c(102, 85, 120, 105, 109) # observation for each year
year <- rep(2001:2005, times = n_obs)

# 2d coordinate
x <- runif(sum(n_obs)) * 10;
y <- runif(sum(n_obs)) * 5

# set the model for simulation
true_model <- ngme2::f(
  map = list(year, ~x+y),
  model = "tp",
  first = list(model="ar1", rho = 0.5),
  second = list(model="matern", mesh = mesh2d),
  noise = noise_nig(mu=-2, sigma=1, nu=2)
)

W <- simulate(true_model)
AW <- as.numeric(true_model$A %*% W)
Y_obs <- AW + rnorm(length(AW), sd = 0.5)
df <- data.frame(year, x, y, Y_obs)

##############################  estimation
ngme_fit <- ngme(
  Y_obs ~ 0 + f(
    map = list(year, ~x+y),
    model="tp",
    name="tp",
    first = list(model="ar1"),
    second = list(model="matern", mesh = mesh2d),
    noise = noise_nig()
    # control = control_f(numer_grad = T)
  ),
  data = df,
  family = "normal",
  control_opt = control_opt(
    iterations = 300,
    n_parallel_chain = 4,
    max_absolute_step = 0.5,
    preconditioner = "full"
  ),
  debug = FALSE
)

ngme_fit
# see the trajectory of estimation
# traceplot(ngme_fit, "tp")
# traceplot(ngme_fit)
```
