---
title: "Space-time (tensor product) model in Ngme2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Space-time (tensor product) model in Ngme2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Description

In this vignette, we will show how to fit a tensor product model using ngme2. One useful example of this kind of model is the separable space-time model.

The separable space-time model is defined by the Kronecker product between the precision matrices of the spatial and temporal random effects. Additional information about separable space-time models can be found in Cameletti et al. (2013).

The operator matrix $K$ of the tensor product model can be expressed by: $K = K_l \otimes K_r$ where $K_l$ and $K_r$ are the operator for the 2 sub-models.

```{r setup, message=FALSE, warning=FALSE}
library(INLA)
library(ngme2)
```

## Usage

The R interface for tensor product model similar to the other models, except it require 2 extra field, namely `first` and `second`.

The operator matrix of `first` and `second` field are exactly the first side and second side of the Kronecker product.

The following example gives a simple space-time model with a separable covariance structure.

```{r}
mesh_1d <- inla.mesh.1d(1:10)
time <- 1:3; time_rep <- rep(time, each=5)
loc <- 1:5; loc_rep <- rep(loc, 3)
cbind(time_rep, loc_rep)

tp_model <- f(
  map = list(time_rep, loc_rep),
  model = "tp",
  first = ar1(time_rep),
  second = matern(mesh=mesh_1d),
  complete = FALSE,
  noise = noise_nig()
)

tp_model <- f(
  map = list(time_rep, loc_rep),
  model = "tp",
  first = ar1(mesh = time_rep),
  second = matern(mesh = mesh_1d),
  complete = FALSE,
  noise = noise_nig()
)

tp_model$A
```


## Simulation - (AR1 x Matern 2d case)

Now let's turn to simualte and estimate the tensor-product model.

```{r}
set.seed(16)
##############################  simulation
mesh2d <- inla.mesh.2d(
  loc.domain = cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5),
  max.edge = c(2, 10)
)

# generate random loc for each n_ar
n_obs <- c(13, 22, 14, 20, 32) # observation for each year
year <- rep(2001:2005, times = n_obs)
x <- runif(sum(n_obs)) * 10; y <- runif(sum(n_obs)) * 5

true_model <- ngme2::f(
  map = list(year, ~x+y),
  model = "tp", name="tp",
  first = ar1(year),
  second = matern(mesh = mesh2d)
)

W <- simulate(true_model)
AW <- as.numeric(true_model$A %*% W)
n_obs <- length(AW)
Y_obs <- AW + rnorm(n_obs, sd=0.5)
df <- data.frame(year, x, y, Y_obs)

##############################  estimation
out <- ngme(
  Y_obs ~ 0 +
  f(map = list(year, ~x+y),
    model="tp",
    name="tp",
    first = ar1(year),
    second = matern(mesh = mesh2d),
    control = control_f(numer_grad = T)
  ),
  data = df,
  family = "normal",
  control_opt = control_opt(
    iterations = 10,
    n_parallel_chain = 1,
    estimation = T,
    verbose = T,
    stepsize = 1
  ),
  debug = F
)
out

cross_validation(out)
traceplot(out, "tp")
traceplot(out, "tp")
```
