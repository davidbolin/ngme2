---
title: "Tensor product model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tensor product model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Description

In this vignette, we will show how to fit a tensor product model using ngme2. One useful example of this kind of model is the separable space-time model.

The separable space-time model is defined by the Kronecker product between the precision matrices of the spatial and temporal random effects. Additional information about separable space-time models can be found in Cameletti et al. (2013).

The operator matrix $K$ of the tensor product model can be expressed by: $K = K_l \otimes K_r$ where $K_l$ and $K_r$ are the operator for the 2 sub-models.

```{r setup}
library(ngme2)
library(INLA)
load_all()
```

## Usage

The R interface for tensor product model similar to the other models, except it require 2 extra field, namely `first` and `second`.

The operator matrix of `first` and `second` field are exactly the first side and second side of the Kronecker product.

The following example gives a simple space-time model with a separable covariance structure.

```{r}
mesh_1d <- inla.mesh.1d(1:10)
time <- 1:3; time_rep <- rep(time, each=5)
loc <- 1:5; loc_rep <- rep(loc, 3)
cbind(time_rep, loc_rep)

tp_model <- f(
  model="tp",
  first = ar1(time_rep),
  second = matern(loc_rep, mesh=mesh_1d),
  complete = FALSE,
  noise = noise_nig(),
  eval=TRUE # ignore this when in formula of ngme()
)

dim(tp_model$operator$A)
```


## Simulation - (AR1 x Matern 2d case)

Now let's turn to simualte and estimate the tensor-product model.

```{r}
set.seed(16)
library(INLA)

##############################  simulation
mesh2d <- inla.mesh.2d(
  loc.domain = cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5),
  max.edge = c(0.5, 10)
)

# generate random loc for each n_ar
n_obs <- c(13, 22, 14, 20, 32) # observation for each year
year <- rep(2001:2005, times = n_obs)
year

locs <- list()
for (i in 1:length(n_obs)) {
  # simulate n_obs in each year
  locs[[i]] <- cbind(runif(n_obs[[i]], 0, 10), runif(n_obs[[i]], 0, 5))
}
loc <- do.call(rbind, locs)

true_model <- f(
  model = "tp", name="tp",
  first = ar1(year),
  second = matern(loc, mesh = mesh2d),
  eval=T
)

W <- simulate(true_model)
AW <- as.numeric(true_model$A %*% W)
n_obs <- length(AW)
Y <- AW + rnorm(n_obs, sd=0.5)

##############################  estimation
# str(f(model=matern, group=ar, noise=noise_nig())$model_second$noise)
out <- ngme(
  Y ~ 0 + f(
    model = "tp",
    name="tp",
    first = ar1(year),
    second = matern(loc, mesh = mesh2d),
    control = control_f(numer_grad = T)
  ),
  data = data.frame(Y=Y),
  family = "normal",
  control_opt = control_opt(
    iterations = 1,
    n_parallel_chain = 4,
    estimation = T,
    verbose = T,
    stepsize = 1
  ),
  debug = FALSE
)

out
traceplot(out)
traceplot(out, "tp")
```
